import _defineProperty from '@babel/runtime/helpers/defineProperty';
import assert from 'assert';
import BN from 'bn.js';
import { blob, struct, u8, nu64 } from 'buffer-layout';
import { sendAndConfirmTransaction as sendAndConfirmTransaction$1, TransactionInstruction, Transaction, SystemProgram, PublicKey } from '@solana/web3.js';

/**
 * Layout for a public key
 */

const publicKey = (property = 'publicKey') => {
  return blob(32, property);
};
/**
 * Layout for a 64bit unsigned value
 */

const uint64 = (property = 'uint64') => {
  return blob(8, property);
};

function sendAndConfirmTransaction(title, connection, transaction, ...signers) {
  return sendAndConfirmTransaction$1(connection, transaction, signers, {
    skipPreflight: false,
    commitment: 'recent',
    preflightCommitment: 'recent'
  });
}

/**
 * Some amount of tokens
 */

class Numberu64 extends BN {
  /**
   * Convert to Buffer representation
   */
  toBuffer() {
    const a = super.toArray().reverse();
    const b = Buffer.from(a);

    if (b.length === 8) {
      return b;
    }

    assert(b.length < 8, 'Numberu64 too large');
    const zeroPad = Buffer.alloc(8);
    b.copy(zeroPad);
    return zeroPad;
  }
  /**
   * Construct a Numberu64 from Buffer representation
   */


  static fromBuffer(buffer) {
    assert(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);
    return new BN([...buffer].reverse().map(i => `00${i.toString(16)}`.slice(-2)).join(''), 16);
  }

}
/**
 * Information about a token swap
 */

/**
 * @private
 */
const TokenSwapLayout = struct([u8('isInitialized'), u8('nonce'), publicKey('tokenAccountA'), publicKey('tokenAccountB'), publicKey('tokenPool'), uint64('feesNumerator'), uint64('feesDenominator')]);
/**
 * An ERC20-like Token
 */

class TokenSwap {
  /**
   * @private
   */

  /**
   * The public key identifying this token
   */

  /**
   * Program Identifier for the Token Swap program
   */

  /**
   * Fee payer
   */

  /**
   * Create a Token object attached to the specific token
   *
   * @param connection The connection to use
   * @param token Public key of the token
   * @param programId Optional token programId, uses the system programId by default
   * @param payer Payer of fees
   */
  constructor(connection, tokenSwap, programId, payer) {
    _defineProperty(this, "connection", void 0);

    _defineProperty(this, "tokenSwap", void 0);

    _defineProperty(this, "programId", void 0);

    _defineProperty(this, "payer", void 0);

    Object.assign(this, {
      connection,
      tokenSwap,
      programId,
      payer
    });
  }
  /**
   * Get the minimum balance for the token swap account to be rent exempt
   *
   * @return Number of lamports required
   */


  static async getMinBalanceRentForExemptTokenSwap(connection) {
    return await connection.getMinimumBalanceForRentExemption(TokenSwapLayout.span);
  }

  static createInitSwapInstruction(tokenSwapAccount, authority, nonce, tokenAccountA, tokenAccountB, tokenPool, tokenAccountPool, tokenProgramId, swapProgramId, feeNumerator, feeDenominator) {
    const keys = [{
      pubkey: tokenSwapAccount.publicKey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authority,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: tokenAccountA,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: tokenAccountB,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: tokenPool,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: tokenAccountPool,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: tokenProgramId,
      isSigner: false,
      isWritable: false
    }];
    const commandDataLayout = struct([u8('instruction'), nu64('feeNumerator'), nu64('feeDenominator'), u8('nonce')]);
    let data = Buffer.alloc(1024);
    {
      const encodeLength = commandDataLayout.encode({
        instruction: 0,
        // InitializeSwap instruction
        feeNumerator,
        feeDenominator,
        nonce
      }, data);
      data = data.slice(0, encodeLength);
    }
    return new TransactionInstruction({
      keys,
      programId: swapProgramId,
      data
    });
  }
  /**
   * Create a new Token Swap
   *
   * @param connection The connection to use
   * @param payer Pays for the transaction
   * @param tokenSwapAccount The token swap account
   * @param authority The authority over the swap and accounts
   * @param tokenAccountA: The Swap's Token A account
   * @param tokenAccountB: The Swap's Token B account
   * @param tokenPool The pool token
   * @param tokenAccountPool The pool token account
   * @param tokenProgramId The program id of the token program
   * @param feeNumerator Numerator of the fee ratio
   * @param feeDenominator Denominator of the fee ratio
   * @param swapProgramId Program ID of the token-swap program
   * @return Token object for the newly minted token, Public key of the account holding the total supply of new tokens
   */


  static async createTokenSwap(connection, payer, tokenSwapAccount, authority, tokenAccountA, tokenAccountB, tokenPool, tokenAccountPool, tokenProgramId, nonce, feeNumerator, feeDenominator, swapProgramId) {
    let transaction;
    const tokenSwap = new TokenSwap(connection, tokenSwapAccount.publicKey, swapProgramId, payer); // Allocate memory for the account

    const balanceNeeded = await TokenSwap.getMinBalanceRentForExemptTokenSwap(connection);
    transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: payer.publicKey,
      newAccountPubkey: tokenSwapAccount.publicKey,
      lamports: balanceNeeded,
      space: TokenSwapLayout.span,
      programId: swapProgramId
    }));
    const instruction = TokenSwap.createInitSwapInstruction(tokenSwapAccount, authority, nonce, tokenAccountA, tokenAccountB, tokenPool, tokenAccountPool, tokenProgramId, swapProgramId, feeNumerator, feeDenominator);
    transaction.add(instruction);
    await sendAndConfirmTransaction('createAccount and InitializeSwap', connection, transaction, payer, tokenSwapAccount);
    return tokenSwap;
  }
  /**
   * Retrieve tokenSwap information
   */


  async getInfo() {
    const accountInfo = await this.connection.getAccountInfo(this.tokenSwap);

    if (accountInfo === null) {
      throw new Error('Failed to find token swap account');
    }

    if (!accountInfo.owner.equals(this.programId)) {
      throw new Error(`Invalid token swap owner: ${JSON.stringify(accountInfo.owner)}`);
    }

    const data = Buffer.from(accountInfo.data);
    const tokenSwapInfo = TokenSwapLayout.decode(data);

    if (!tokenSwapInfo.isInitialized) {
      throw new Error(`Invalid token swap state`);
    } // already properly filled in
    // tokenSwapInfo.nonce = tokenSwapInfo.nonce;


    tokenSwapInfo.tokenAccountA = new PublicKey(tokenSwapInfo.tokenAccountA);
    tokenSwapInfo.tokenAccountB = new PublicKey(tokenSwapInfo.tokenAccountB);
    tokenSwapInfo.tokenPool = new PublicKey(tokenSwapInfo.tokenPool);
    tokenSwapInfo.feesNumerator = Numberu64.fromBuffer(tokenSwapInfo.feesNumerator);
    tokenSwapInfo.feesDenominator = Numberu64.fromBuffer(tokenSwapInfo.feesDenominator);
    tokenSwapInfo.feeRatio = tokenSwapInfo.feesNumerator.toNumber() / tokenSwapInfo.feesDenominator.toNumber();
    return tokenSwapInfo;
  }
  /**
   * Swap the tokens in the pool
   *
   * @param authority Authority
   * @param source Source account
   * @param swapSource Base account to swap into, must be a source token
   * @param swapDestination Base account to swap from, must be a destination token
   * @param destination Destination token account
   * @param tokenProgramId Token program id
   * @param amount Amount to transfer from source account
   */


  async swap(authority, source, swapSource, swapDestination, destination, tokenProgramId, amountIn, minimumAmountOut) {
    return await sendAndConfirmTransaction('swap', this.connection, new Transaction().add(TokenSwap.swapInstruction(this.tokenSwap, authority, source, swapSource, swapDestination, destination, this.programId, tokenProgramId, amountIn, minimumAmountOut)), this.payer);
  }

  static swapInstruction(tokenSwap, authority, source, swapSource, swapDestination, destination, swapProgramId, tokenProgramId, amountIn, minimumAmountOut) {
    const dataLayout = struct([u8('instruction'), uint64('amountIn'), uint64('minimumAmountOut')]);
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode({
      instruction: 1,
      // Swap instruction
      amountIn: new Numberu64(amountIn).toBuffer(),
      minimumAmountOut: new Numberu64(minimumAmountOut).toBuffer()
    }, data);
    const keys = [{
      pubkey: tokenSwap,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authority,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: source,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: swapSource,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: swapDestination,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: destination,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: tokenProgramId,
      isSigner: false,
      isWritable: false
    }];
    return new TransactionInstruction({
      keys,
      programId: swapProgramId,
      data
    });
  }
  /**
   * Deposit some tokens into the pool
   *
   * @param authority Authority
   * @param sourceA Source account A
   * @param sourceB Source account B
   * @param intoA Base account A to deposit into
   * @param intoB Base account B to deposit into
   * @param poolToken Pool token
   * @param poolAccount Pool account to deposit the generated tokens
   * @param tokenProgramId Token program id
   * @param amount Amount of pool token to deposit, token A and B amount are set by the exchange rate relative to the total pool token supply
   */


  async deposit(authority, sourceA, sourceB, intoA, intoB, poolToken, poolAccount, tokenProgramId, poolTokenAmount, maximumTokenA, maximumTokenB) {
    return await sendAndConfirmTransaction('deposit', this.connection, new Transaction().add(TokenSwap.depositInstruction(this.tokenSwap, authority, sourceA, sourceB, intoA, intoB, poolToken, poolAccount, this.programId, tokenProgramId, poolTokenAmount, maximumTokenA, maximumTokenB)), this.payer);
  }

  static depositInstruction(tokenSwap, authority, sourceA, sourceB, intoA, intoB, poolToken, poolAccount, swapProgramId, tokenProgramId, poolTokenAmount, maximumTokenA, maximumTokenB) {
    const dataLayout = struct([u8('instruction'), uint64('poolTokenAmount'), uint64('maximumTokenA'), uint64('maximumTokenB')]);
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode({
      instruction: 2,
      // Deposit instruction
      poolTokenAmount: new Numberu64(poolTokenAmount).toBuffer(),
      maximumTokenA: new Numberu64(maximumTokenA).toBuffer(),
      maximumTokenB: new Numberu64(maximumTokenB).toBuffer()
    }, data);
    const keys = [{
      pubkey: tokenSwap,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authority,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: sourceA,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: sourceB,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: intoA,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: intoB,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: poolToken,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: poolAccount,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: tokenProgramId,
      isSigner: false,
      isWritable: false
    }];
    return new TransactionInstruction({
      keys,
      programId: swapProgramId,
      data
    });
  }
  /**
   * Withdraw the token from the pool at the current ratio
   *
   * @param authority Authority
   * @param sourcePoolAccount Source pool account
   * @param poolToken Pool token
   * @param fromA Base account A to withdraw from
   * @param fromB Base account B to withdraw from
   * @param userAccountA Token A user account
   * @param userAccountB token B user account
   * @param tokenProgramId Token program id
   * @param amount Amount of pool token to withdraw, token A and B amount are set by the exchange rate relative to the total pool token supply
   */


  async withdraw(authority, poolMint, sourcePoolAccount, fromA, fromB, userAccountA, userAccountB, tokenProgramId, poolTokenAmount, minimumTokenA, minimumTokenB) {
    return await sendAndConfirmTransaction('withdraw', this.connection, new Transaction().add(TokenSwap.withdrawInstruction(this.tokenSwap, authority, poolMint, sourcePoolAccount, fromA, fromB, userAccountA, userAccountB, this.programId, tokenProgramId, poolTokenAmount, minimumTokenA, minimumTokenB)), this.payer);
  }

  static withdrawInstruction(tokenSwap, authority, poolMint, sourcePoolAccount, fromA, fromB, userAccountA, userAccountB, swapProgramId, tokenProgramId, poolTokenAmount, minimumTokenA, minimumTokenB) {
    const dataLayout = struct([u8('instruction'), uint64('poolTokenAmount'), uint64('minimumTokenA'), uint64('minimumTokenB')]);
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode({
      instruction: 3,
      // Withdraw instruction
      poolTokenAmount: new Numberu64(poolTokenAmount).toBuffer(),
      minimumTokenA: new Numberu64(minimumTokenA).toBuffer(),
      minimumTokenB: new Numberu64(minimumTokenB).toBuffer()
    }, data);
    const keys = [{
      pubkey: tokenSwap,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authority,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: poolMint,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: sourcePoolAccount,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: fromA,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: fromB,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: userAccountA,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: userAccountB,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: tokenProgramId,
      isSigner: false,
      isWritable: false
    }];
    return new TransactionInstruction({
      keys,
      programId: swapProgramId,
      data
    });
  }

}

export { Numberu64, TokenSwap, TokenSwapLayout };
//# sourceMappingURL=index.esm.js.map
