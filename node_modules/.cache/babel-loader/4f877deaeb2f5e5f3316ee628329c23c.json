{"ast":null,"code":"var _jsxFileName = \"/home/yclnl/yclnl.github.io/src/context/market.tsx\";\nimport React, { useCallback, useContext, useEffect, useState } from \"react\";\nimport { POOLS_WITH_AIRDROP } from \"./../models/airdrops\";\nimport { MINT_TO_MARKET } from \"./../models/marketOverrides\";\nimport { convert, getPoolName, getTokenName, STABLE_COINS } from \"./../utils/utils\";\nimport { useConnectionConfig } from \"./../utils/connection\";\nimport { cache, getMultipleAccounts, MintParser, useCachedPool } from \"./../utils/accounts\";\nimport { Market, MARKETS, Orderbook, TOKEN_MINTS } from \"@project-serum/serum\";\nimport { Connection, PublicKey } from \"@solana/web3.js\";\nimport { useMemo } from \"react\";\nimport { EventEmitter } from \"./../utils/eventEmitter\";\nconst INITAL_LIQUIDITY_DATE = new Date(\"2020-10-27\");\nconst REFRESH_INTERVAL = 30000;\nconst MarketsContext = React.createContext(null);\nconst marketEmitter = new EventEmitter();\nexport function MarketProvider({\n  children = null\n}) {\n  const {\n    endpoint\n  } = useConnectionConfig();\n  const {\n    pools\n  } = useCachedPool();\n  const accountsToObserve = useMemo(() => new Map(), []);\n  const connection = useMemo(() => new Connection(endpoint, \"recent\"), [endpoint]);\n  const marketByMint = useMemo(() => {\n    return [...new Set(pools.map(p => p.pubkeys.holdingMints).flat()).values()].reduce((acc, key) => {\n      const mintAddress = key.toBase58();\n      const SERUM_TOKEN = TOKEN_MINTS.find(a => a.address.toBase58() === mintAddress);\n      const marketAddress = MINT_TO_MARKET[mintAddress];\n      const marketName = `${SERUM_TOKEN === null || SERUM_TOKEN === void 0 ? void 0 : SERUM_TOKEN.name}/USDC`;\n      const marketInfo = MARKETS.find(m => m.name === marketName || m.address.toBase58() === marketAddress);\n\n      if (marketInfo) {\n        acc.set(mintAddress, {\n          marketInfo\n        });\n      }\n\n      return acc;\n    }, new Map());\n  }, [pools]);\n  useEffect(() => {\n    let timer = 0;\n\n    const updateData = async () => {\n      await refreshAccounts(connection, [...accountsToObserve.keys()]); // TODO: only raise mints that changed\n\n      marketEmitter.raiseMarketUpdated(new Set([...marketByMint.keys()]));\n      timer = window.setTimeout(() => updateData(), REFRESH_INTERVAL);\n    };\n\n    const initalQuery = async () => {\n      const reverseSerumMarketCache = new Map();\n      [...marketByMint.keys()].forEach(mint => {\n        const m = marketByMint.get(mint);\n\n        if (m) {\n          reverseSerumMarketCache.set(m.marketInfo.address.toBase58(), mint);\n        }\n      });\n      const allMarkets = [...marketByMint.values()].map(m => {\n        return m.marketInfo.address.toBase58();\n      });\n      await getMultipleAccounts(connection, // only query for markets that are not in cahce\n      allMarkets.filter(a => cache.get(a) === undefined), \"single\").then(({\n        keys,\n        array\n      }) => {\n        allMarkets.forEach(() => {});\n        return array.map((item, index) => {\n          const marketAddress = keys[index];\n          const mintAddress = reverseSerumMarketCache.get(marketAddress);\n\n          if (mintAddress) {\n            const market = marketByMint.get(mintAddress);\n\n            if (market) {\n              const programId = market.marketInfo.programId;\n              const id = market.marketInfo.address;\n              cache.add(id, item, (id, acc) => {\n                const decoded = Market.getLayout(programId).decode(acc.data);\n                const details = {\n                  pubkey: id,\n                  account: { ...acc\n                  },\n                  info: decoded\n                };\n                cache.registerParser(details.info.baseMint, MintParser);\n                cache.registerParser(details.info.quoteMint, MintParser);\n                cache.registerParser(details.info.bids, OrderBookParser);\n                cache.registerParser(details.info.asks, OrderBookParser);\n                return details;\n              });\n            }\n          }\n\n          return item;\n        });\n      });\n      const toQuery = new Set();\n      allMarkets.forEach(m => {\n        const market = cache.get(m);\n\n        if (!market) {\n          return;\n        }\n\n        const decoded = market;\n\n        if (!cache.get(decoded.info.baseMint)) {\n          toQuery.add(decoded.info.baseMint.toBase58());\n        }\n\n        if (!cache.get(decoded.info.baseMint)) {\n          toQuery.add(decoded.info.quoteMint.toBase58());\n        }\n\n        toQuery.add(decoded.info.bids.toBase58());\n        toQuery.add(decoded.info.asks.toBase58()); // TODO: only update when someone listnes to it\n      });\n      await refreshAccounts(connection, [...toQuery.keys()]);\n      marketEmitter.raiseMarketUpdated(new Set([...marketByMint.keys()])); // start update loop\n\n      updateData();\n    };\n\n    initalQuery();\n    return () => {\n      window.clearTimeout(timer);\n    };\n  }, [pools, marketByMint]);\n  const midPriceInUSD = useCallback(mintAddress => {\n    var _marketByMint$get;\n\n    return getMidPrice((_marketByMint$get = marketByMint.get(mintAddress)) === null || _marketByMint$get === void 0 ? void 0 : _marketByMint$get.marketInfo.address.toBase58(), mintAddress);\n  }, [marketByMint]);\n  const subscribeToMarket = useCallback(mintAddress => {\n    const info = marketByMint.get(mintAddress);\n    const market = cache.get((info === null || info === void 0 ? void 0 : info.marketInfo.address.toBase58()) || \"\");\n\n    if (!market) {\n      return () => {};\n    }\n\n    const bid = market.info.bids.toBase58();\n    const ask = market.info.asks.toBase58();\n    accountsToObserve.set(bid, (accountsToObserve.get(bid) || 0) + 1);\n    accountsToObserve.set(ask, (accountsToObserve.get(ask) || 0) + 1); // TODO: add event queue to query for last trade\n\n    return () => {\n      accountsToObserve.set(bid, (accountsToObserve.get(bid) || 0) - 1);\n      accountsToObserve.set(ask, (accountsToObserve.get(ask) || 0) - 1); // cleanup\n\n      [...accountsToObserve.keys()].forEach(key => {\n        if ((accountsToObserve.get(key) || 0) <= 0) {\n          accountsToObserve.delete(key);\n        }\n      });\n    };\n  }, [marketByMint]);\n  return /*#__PURE__*/React.createElement(MarketsContext.Provider, {\n    value: {\n      midPriceInUSD,\n      marketEmitter,\n      accountsToObserve,\n      marketByMint,\n      subscribeToMarket\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 221,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport const useMarkets = () => {\n  const context = useContext(MarketsContext);\n  return context;\n};\nexport const useMidPriceInUSD = mint => {\n  const {\n    midPriceInUSD,\n    subscribeToMarket,\n    marketEmitter\n  } = useContext(MarketsContext);\n  const [price, setPrice] = useState(0);\n  useEffect(() => {\n    let subscription = subscribeToMarket(mint);\n\n    const update = () => {\n      if (midPriceInUSD) {\n        setPrice(midPriceInUSD(mint));\n      }\n    };\n\n    update();\n    const dispose = marketEmitter.onMarket(update);\n    return () => {\n      subscription();\n      dispose();\n    };\n  }, [midPriceInUSD, mint]);\n  return {\n    price,\n    isBase: price === 1.0\n  };\n};\nexport const useEnrichedPools = pools => {\n  const context = useContext(MarketsContext);\n  const {\n    env\n  } = useConnectionConfig();\n  const [enriched, setEnriched] = useState([]);\n  const marketsByMint = context === null || context === void 0 ? void 0 : context.marketByMint;\n  useEffect(() => {\n    const mints = [...new Set([...(marketsByMint === null || marketsByMint === void 0 ? void 0 : marketsByMint.keys())]).keys()];\n    const subscriptions = mints.map(m => context === null || context === void 0 ? void 0 : context.subscribeToMarket(m));\n\n    const update = () => {\n      setEnriched(createEnrichedPools(pools, marketsByMint, env));\n    };\n\n    const dispose = context === null || context === void 0 ? void 0 : context.marketEmitter.onMarket(update);\n    update();\n    return () => {\n      dispose && dispose();\n      subscriptions.forEach(dispose => dispose && dispose());\n    };\n  }, [env, pools, marketsByMint]);\n  return enriched;\n}; // TODO:\n// 1. useEnrichedPools\n//      combines market and pools and user info\n// 2. ADD useMidPrice with event to refresh price\n// that could subscribe to multiple markets and trigger refresh of those markets only when there is active subscription\n\nfunction createEnrichedPools(pools, marketByMint, env) {\n  const TODAY = new Date();\n\n  if (!marketByMint) {\n    return [];\n  }\n\n  const result = pools.filter(p => p.pubkeys.holdingMints && p.pubkeys.holdingMints.length > 1).map((p, index) => {\n    var _p$pubkeys$holdingMin, _marketByMint$get2, _marketByMint$get3;\n\n    const mints = (p.pubkeys.holdingMints || []).map(a => a.toBase58()).sort();\n    const indexA = mints[0] === ((_p$pubkeys$holdingMin = p.pubkeys.holdingMints[0]) === null || _p$pubkeys$holdingMin === void 0 ? void 0 : _p$pubkeys$holdingMin.toBase58()) ? 0 : 1;\n    const indexB = indexA === 0 ? 1 : 0;\n    const accountA = cache.getAccount(p.pubkeys.holdingAccounts[indexA]);\n    const mintA = cache.getMint(mints[0]);\n    const accountB = cache.getAccount(p.pubkeys.holdingAccounts[indexB]);\n    const mintB = cache.getMint(mints[1]);\n    const baseReserveUSD = getMidPrice(((_marketByMint$get2 = marketByMint.get(mints[0])) === null || _marketByMint$get2 === void 0 ? void 0 : _marketByMint$get2.marketInfo.address.toBase58()) || \"\", mints[0]) * convert(accountA, mintA);\n    const quoteReserveUSD = getMidPrice(((_marketByMint$get3 = marketByMint.get(mints[1])) === null || _marketByMint$get3 === void 0 ? void 0 : _marketByMint$get3.marketInfo.address.toBase58()) || \"\", mints[1]) * convert(accountB, mintB);\n    const poolMint = cache.getMint(p.pubkeys.mint);\n\n    if (poolMint === null || poolMint === void 0 ? void 0 : poolMint.supply.eqn(0)) {\n      return;\n    }\n\n    let airdropYield = calculateAirdropYield(p, marketByMint, baseReserveUSD, quoteReserveUSD);\n    let volume = 0;\n    let fees = 0;\n    let apy = airdropYield;\n\n    if (p.pubkeys.feeAccount) {\n      const feeAccount = cache.getAccount(p.pubkeys.feeAccount);\n\n      if (poolMint && feeAccount && feeAccount.info.mint.toBase58() === p.pubkeys.mint.toBase58()) {\n        const feeBalance = feeAccount === null || feeAccount === void 0 ? void 0 : feeAccount.info.amount.toNumber();\n        const supply = poolMint === null || poolMint === void 0 ? void 0 : poolMint.supply.toNumber();\n        const ownedPct = feeBalance / supply;\n        const poolOwnerFees = ownedPct * baseReserveUSD + ownedPct * quoteReserveUSD;\n        volume = poolOwnerFees / 0.0004;\n        fees = volume * 0.003;\n\n        if (fees !== 0) {\n          const baseVolume = ownedPct * baseReserveUSD / 0.0004;\n          const quoteVolume = ownedPct * quoteReserveUSD / 0.0004; // Aproximation not true for all pools we need to fine a better way\n\n          const daysSinceInception = Math.floor((TODAY.getTime() - INITAL_LIQUIDITY_DATE.getTime()) / (24 * 3600 * 1000));\n          const apy0 = parseFloat(baseVolume / daysSinceInception * 0.003 * 356) / baseReserveUSD;\n          const apy1 = parseFloat(quoteVolume / daysSinceInception * 0.003 * 356) / quoteReserveUSD;\n          apy = apy + Math.max(apy0, apy1);\n        }\n      }\n    }\n\n    const lpMint = cache.getMint(p.pubkeys.mint);\n    const name = getPoolName(env, p);\n    const link = `#/?pair=${getPoolName(env, p, false).replace(\"/\", \"-\")}`;\n    return {\n      key: p.pubkeys.account.toBase58(),\n      id: index,\n      name,\n      names: mints.map(m => getTokenName(env, m)),\n      address: p.pubkeys.mint.toBase58(),\n      link,\n      mints,\n      liquidityA: convert(accountA, mintA),\n      liquidityAinUsd: baseReserveUSD,\n      liquidityB: convert(accountB, mintB),\n      liquidityBinUsd: quoteReserveUSD,\n      supply: lpMint && ((lpMint === null || lpMint === void 0 ? void 0 : lpMint.supply.toNumber()) / Math.pow(10, (lpMint === null || lpMint === void 0 ? void 0 : lpMint.decimals) || 0)).toFixed(9),\n      fees,\n      liquidity: baseReserveUSD + quoteReserveUSD,\n      volume,\n      apy: Number.isFinite(apy) ? apy : 0,\n      raw: p\n    };\n  }).filter(p => p !== undefined);\n  return result;\n}\n\nfunction calculateAirdropYield(p, marketByMint, baseReserveUSD, quoteReserveUSD) {\n  let airdropYield = 0;\n  let poolWithAirdrop = POOLS_WITH_AIRDROP.find(drop => drop.pool.equals(p.pubkeys.mint));\n\n  if (poolWithAirdrop) {\n    airdropYield = poolWithAirdrop.airdrops.reduce((acc, item) => {\n      var _marketByMint$get4;\n\n      const market = (_marketByMint$get4 = marketByMint.get(item.mint.toBase58())) === null || _marketByMint$get4 === void 0 ? void 0 : _marketByMint$get4.marketInfo.address;\n\n      if (market) {\n        const midPrice = getMidPrice(market === null || market === void 0 ? void 0 : market.toBase58(), item.mint.toBase58());\n        acc = acc + // airdrop yield\n        item.amount * midPrice / (baseReserveUSD + quoteReserveUSD) * (365 / 30);\n      }\n\n      return acc;\n    }, 0);\n  }\n\n  return airdropYield;\n}\n\nconst OrderBookParser = (id, acc) => {\n  const decoded = Orderbook.LAYOUT.decode(acc.data);\n  const details = {\n    pubkey: id,\n    account: { ...acc\n    },\n    info: decoded\n  };\n  return details;\n};\n\nconst getMidPrice = (marketAddress, mintAddress) => {\n  var _cache$get, _cache$get2, _cache$get3, _cache$get4;\n\n  const SERUM_TOKEN = TOKEN_MINTS.find(a => a.address.toBase58() === mintAddress);\n\n  if (STABLE_COINS.has((SERUM_TOKEN === null || SERUM_TOKEN === void 0 ? void 0 : SERUM_TOKEN.name) || \"\")) {\n    return 1.0;\n  }\n\n  if (!marketAddress) {\n    return 0.0;\n  }\n\n  const marketInfo = cache.get(marketAddress);\n\n  if (!marketInfo) {\n    return 0.0;\n  }\n\n  const decodedMarket = marketInfo.info;\n  const baseMintDecimals = ((_cache$get = cache.get(decodedMarket.baseMint)) === null || _cache$get === void 0 ? void 0 : _cache$get.info.decimals) || 0;\n  const quoteMintDecimals = ((_cache$get2 = cache.get(decodedMarket.quoteMint)) === null || _cache$get2 === void 0 ? void 0 : _cache$get2.info.decimals) || 0;\n  const market = new Market(decodedMarket, baseMintDecimals, quoteMintDecimals, undefined, decodedMarket.programId);\n  const bids = (_cache$get3 = cache.get(decodedMarket.bids)) === null || _cache$get3 === void 0 ? void 0 : _cache$get3.info;\n  const asks = (_cache$get4 = cache.get(decodedMarket.asks)) === null || _cache$get4 === void 0 ? void 0 : _cache$get4.info;\n\n  if (bids && asks) {\n    const bidsBook = new Orderbook(market, bids.accountFlags, bids.slab);\n    const asksBook = new Orderbook(market, asks.accountFlags, asks.slab);\n    const bestBid = bidsBook.getL2(1);\n    const bestAsk = asksBook.getL2(1);\n\n    if (bestBid.length > 0 && bestAsk.length > 0) {\n      return (bestBid[0][0] + bestAsk[0][0]) / 2.0;\n    }\n  }\n\n  return 0;\n};\n\nconst refreshAccounts = async (connection, keys) => {\n  if (keys.length === 0) {\n    return [];\n  }\n\n  return getMultipleAccounts(connection, keys, \"single\").then(({\n    keys,\n    array\n  }) => {\n    return array.map((item, index) => {\n      const address = keys[index];\n      return cache.add(new PublicKey(address), item);\n    });\n  });\n};","map":{"version":3,"sources":["/home/yclnl/yclnl.github.io/src/context/market.tsx"],"names":["React","useCallback","useContext","useEffect","useState","POOLS_WITH_AIRDROP","MINT_TO_MARKET","convert","getPoolName","getTokenName","STABLE_COINS","useConnectionConfig","cache","getMultipleAccounts","MintParser","useCachedPool","Market","MARKETS","Orderbook","TOKEN_MINTS","Connection","PublicKey","useMemo","EventEmitter","INITAL_LIQUIDITY_DATE","Date","REFRESH_INTERVAL","MarketsContext","createContext","marketEmitter","MarketProvider","children","endpoint","pools","accountsToObserve","Map","connection","marketByMint","Set","map","p","pubkeys","holdingMints","flat","values","reduce","acc","key","mintAddress","toBase58","SERUM_TOKEN","find","a","address","marketAddress","marketName","name","marketInfo","m","set","timer","updateData","refreshAccounts","keys","raiseMarketUpdated","window","setTimeout","initalQuery","reverseSerumMarketCache","forEach","mint","get","allMarkets","filter","undefined","then","array","item","index","market","programId","id","add","decoded","getLayout","decode","data","details","pubkey","account","info","registerParser","baseMint","quoteMint","bids","OrderBookParser","asks","toQuery","clearTimeout","midPriceInUSD","getMidPrice","subscribeToMarket","bid","ask","delete","useMarkets","context","useMidPriceInUSD","price","setPrice","subscription","update","dispose","onMarket","isBase","useEnrichedPools","env","enriched","setEnriched","marketsByMint","mints","subscriptions","createEnrichedPools","TODAY","result","length","sort","indexA","indexB","accountA","getAccount","holdingAccounts","mintA","getMint","accountB","mintB","baseReserveUSD","quoteReserveUSD","poolMint","supply","eqn","airdropYield","calculateAirdropYield","volume","fees","apy","feeAccount","feeBalance","amount","toNumber","ownedPct","poolOwnerFees","baseVolume","quoteVolume","daysSinceInception","Math","floor","getTime","apy0","parseFloat","apy1","max","lpMint","link","replace","names","liquidityA","liquidityAinUsd","liquidityB","liquidityBinUsd","pow","decimals","toFixed","liquidity","Number","isFinite","raw","poolWithAirdrop","drop","pool","equals","airdrops","midPrice","LAYOUT","has","decodedMarket","baseMintDecimals","quoteMintDecimals","bidsBook","accountFlags","slab","asksBook","bestBid","getL2","bestAsk"],"mappings":"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","sourcesContent":["import React, { useCallback, useContext, useEffect, useState } from \"react\";\nimport { POOLS_WITH_AIRDROP } from \"./../models/airdrops\";\nimport { MINT_TO_MARKET } from \"./../models/marketOverrides\";\nimport {\n  convert,\n  getPoolName,\n  getTokenName,\n  STABLE_COINS,\n} from \"./../utils/utils\";\nimport { ENV, useConnectionConfig } from \"./../utils/connection\";\nimport {\n  cache,\n  getMultipleAccounts,\n  MintParser,\n  ParsedAccountBase,\n  useCachedPool,\n} from \"./../utils/accounts\";\nimport { Market, MARKETS, Orderbook, TOKEN_MINTS } from \"@project-serum/serum\";\nimport { AccountInfo, Connection, PublicKey } from \"@solana/web3.js\";\nimport { useMemo } from \"react\";\nimport { PoolInfo } from \"../models\";\nimport { EventEmitter } from \"./../utils/eventEmitter\";\n\nexport interface MarketsContextState {\n  midPriceInUSD: (mint: string) => number;\n  marketEmitter: EventEmitter;\n  accountsToObserve: Map<string, number>;\n  marketByMint: Map<string, SerumMarket>;\n\n  subscribeToMarket: (mint: string) => () => void;\n}\n\nconst INITAL_LIQUIDITY_DATE = new Date(\"2020-10-27\");\nconst REFRESH_INTERVAL = 30_000;\n\nconst MarketsContext = React.createContext<MarketsContextState | null>(null);\n\nconst marketEmitter = new EventEmitter();\n\nexport function MarketProvider({ children = null as any }) {\n  const { endpoint } = useConnectionConfig();\n  const { pools } = useCachedPool();\n  const accountsToObserve = useMemo(() => new Map<string, number>(), []);\n\n  const connection = useMemo(() => new Connection(endpoint, \"recent\"), [\n    endpoint,\n  ]);\n\n  const marketByMint = useMemo(() => {\n    return [\n      ...new Set(pools.map((p) => p.pubkeys.holdingMints).flat()).values(),\n    ].reduce((acc, key) => {\n      const mintAddress = key.toBase58();\n\n      const SERUM_TOKEN = TOKEN_MINTS.find(\n        (a) => a.address.toBase58() === mintAddress\n      );\n\n      const marketAddress = MINT_TO_MARKET[mintAddress];\n      const marketName = `${SERUM_TOKEN?.name}/USDC`;\n      const marketInfo = MARKETS.find(\n        (m) => m.name === marketName || m.address.toBase58() === marketAddress\n      );\n\n      if (marketInfo) {\n        acc.set(mintAddress, {\n          marketInfo,\n        });\n      }\n\n      return acc;\n    }, new Map<string, SerumMarket>()) as Map<string, SerumMarket>;\n  }, [pools]);\n\n  useEffect(() => {\n    let timer = 0;\n\n    const updateData = async () => {\n      await refreshAccounts(connection, [...accountsToObserve.keys()]);\n\n      // TODO: only raise mints that changed\n      marketEmitter.raiseMarketUpdated(new Set([...marketByMint.keys()]));\n\n      timer = window.setTimeout(() => updateData(), REFRESH_INTERVAL);\n    };\n\n    const initalQuery = async () => {\n      const reverseSerumMarketCache = new Map<string, string>();\n      [...marketByMint.keys()].forEach((mint) => {\n        const m = marketByMint.get(mint);\n        if (m) {\n          reverseSerumMarketCache.set(m.marketInfo.address.toBase58(), mint);\n        }\n      });\n\n      const allMarkets = [...marketByMint.values()].map((m) => {\n        return m.marketInfo.address.toBase58();\n      });\n\n      await getMultipleAccounts(\n        connection,\n        // only query for markets that are not in cahce\n        allMarkets.filter((a) => cache.get(a) === undefined),\n        \"single\"\n      ).then(({ keys, array }) => {\n        allMarkets.forEach(() => { });\n\n        return array.map((item, index) => {\n          const marketAddress = keys[index];\n          const mintAddress = reverseSerumMarketCache.get(marketAddress);\n          if (mintAddress) {\n            const market = marketByMint.get(mintAddress);\n\n            if (market) {\n              const programId = market.marketInfo.programId;\n              const id = market.marketInfo.address;\n              cache.add(id, item, (id, acc) => {\n                const decoded = Market.getLayout(programId).decode(acc.data);\n\n                const details = {\n                  pubkey: id,\n                  account: {\n                    ...acc,\n                  },\n                  info: decoded,\n                } as ParsedAccountBase;\n\n                cache.registerParser(details.info.baseMint, MintParser);\n                cache.registerParser(details.info.quoteMint, MintParser);\n                cache.registerParser(details.info.bids, OrderBookParser);\n                cache.registerParser(details.info.asks, OrderBookParser);\n\n                return details;\n              });\n            }\n          }\n\n          return item;\n        });\n      });\n\n      const toQuery = new Set<string>();\n      allMarkets.forEach((m) => {\n        const market = cache.get(m);\n        if (!market) {\n          return;\n        }\n\n        const decoded = market;\n\n        if (!cache.get(decoded.info.baseMint)) {\n          toQuery.add(decoded.info.baseMint.toBase58());\n        }\n\n        if (!cache.get(decoded.info.baseMint)) {\n          toQuery.add(decoded.info.quoteMint.toBase58());\n        }\n\n        toQuery.add(decoded.info.bids.toBase58());\n        toQuery.add(decoded.info.asks.toBase58());\n\n        // TODO: only update when someone listnes to it\n      });\n\n      await refreshAccounts(connection, [...toQuery.keys()]);\n\n      marketEmitter.raiseMarketUpdated(new Set([...marketByMint.keys()]));\n\n      // start update loop\n      updateData();\n    };\n\n    initalQuery();\n\n    return () => {\n      window.clearTimeout(timer);\n    };\n  }, [pools, marketByMint]);\n\n  const midPriceInUSD = useCallback(\n    (mintAddress: string) => {\n      return getMidPrice(\n        marketByMint.get(mintAddress)?.marketInfo.address.toBase58(),\n        mintAddress\n      );\n    },\n    [marketByMint]\n  );\n\n  const subscribeToMarket = useCallback(\n    (mintAddress: string) => {\n      const info = marketByMint.get(mintAddress);\n      const market = cache.get(info?.marketInfo.address.toBase58() || \"\");\n      if (!market) {\n        return () => { };\n      }\n\n      const bid = market.info.bids.toBase58();\n      const ask = market.info.asks.toBase58();\n      accountsToObserve.set(bid, (accountsToObserve.get(bid) || 0) + 1);\n      accountsToObserve.set(ask, (accountsToObserve.get(ask) || 0) + 1);\n\n      // TODO: add event queue to query for last trade\n\n      return () => {\n        accountsToObserve.set(bid, (accountsToObserve.get(bid) || 0) - 1);\n        accountsToObserve.set(ask, (accountsToObserve.get(ask) || 0) - 1);\n\n        // cleanup\n        [...accountsToObserve.keys()].forEach((key) => {\n          if ((accountsToObserve.get(key) || 0) <= 0) {\n            accountsToObserve.delete(key);\n          }\n        });\n      };\n    },\n    [marketByMint]\n  );\n\n  return (\n    <MarketsContext.Provider\n      value={{\n        midPriceInUSD,\n        marketEmitter,\n        accountsToObserve,\n        marketByMint,\n        subscribeToMarket,\n      }}\n    >\n      {children}\n    </MarketsContext.Provider>\n  );\n}\n\nexport const useMarkets = () => {\n  const context = useContext(MarketsContext);\n  return context as MarketsContextState;\n};\n\nexport const useMidPriceInUSD = (mint: string) => {\n  const { midPriceInUSD, subscribeToMarket, marketEmitter } = useContext(\n    MarketsContext\n  ) as MarketsContextState;\n  const [price, setPrice] = useState<number>(0);\n\n  useEffect(() => {\n    let subscription = subscribeToMarket(mint);\n    const update = () => {\n      if (midPriceInUSD) {\n        setPrice(midPriceInUSD(mint));\n      }\n    };\n\n    update();\n    const dispose = marketEmitter.onMarket(update);\n\n    return () => {\n      subscription();\n      dispose();\n    };\n  }, [midPriceInUSD, mint]);\n\n  return { price, isBase: price === 1.0 };\n};\n\nexport const useEnrichedPools = (pools: PoolInfo[]) => {\n  const context = useContext(MarketsContext);\n  const { env } = useConnectionConfig();\n  const [enriched, setEnriched] = useState<any[]>([]);\n\n  const marketsByMint = context?.marketByMint;\n\n  useEffect(() => {\n    const mints = [...new Set([...marketsByMint?.keys()]).keys()];\n\n    const subscriptions = mints.map((m) => context?.subscribeToMarket(m));\n\n    const update = () => {\n      setEnriched(createEnrichedPools(pools, marketsByMint, env));\n    };\n\n    const dispose = context?.marketEmitter.onMarket(update);\n\n    update();\n\n    return () => {\n      dispose && dispose();\n      subscriptions.forEach((dispose) => dispose && dispose());\n    };\n  }, [env, pools, marketsByMint]);\n\n  return enriched;\n};\n\n// TODO:\n// 1. useEnrichedPools\n//      combines market and pools and user info\n// 2. ADD useMidPrice with event to refresh price\n// that could subscribe to multiple markets and trigger refresh of those markets only when there is active subscription\n\nfunction createEnrichedPools(\n  pools: PoolInfo[],\n  marketByMint: Map<string, SerumMarket> | undefined,\n  env: ENV\n) {\n  const TODAY = new Date();\n\n  if (!marketByMint) {\n    return [];\n  }\n\n  const result = pools\n    .filter((p) => p.pubkeys.holdingMints && p.pubkeys.holdingMints.length > 1)\n    .map((p, index) => {\n      const mints = (p.pubkeys.holdingMints || [])\n        .map((a) => a.toBase58())\n        .sort();\n      const indexA = mints[0] === p.pubkeys.holdingMints[0]?.toBase58() ? 0 : 1;\n      const indexB = indexA === 0 ? 1 : 0;\n      const accountA = cache.getAccount(p.pubkeys.holdingAccounts[indexA]);\n      const mintA = cache.getMint(mints[0]);\n      const accountB = cache.getAccount(p.pubkeys.holdingAccounts[indexB]);\n      const mintB = cache.getMint(mints[1]);\n\n      const baseReserveUSD =\n        getMidPrice(\n          marketByMint.get(mints[0])?.marketInfo.address.toBase58() || \"\",\n          mints[0]\n        ) * convert(accountA, mintA);\n      const quoteReserveUSD =\n        getMidPrice(\n          marketByMint.get(mints[1])?.marketInfo.address.toBase58() || \"\",\n          mints[1]\n        ) * convert(accountB, mintB);\n\n      const poolMint = cache.getMint(p.pubkeys.mint);\n      if (poolMint?.supply.eqn(0)) {\n        return;\n      }\n\n      let airdropYield = calculateAirdropYield(\n        p,\n        marketByMint,\n        baseReserveUSD,\n        quoteReserveUSD\n      );\n\n      let volume = 0;\n      let fees = 0;\n      let apy = airdropYield;\n      if (p.pubkeys.feeAccount) {\n        const feeAccount = cache.getAccount(p.pubkeys.feeAccount);\n\n        if (\n          poolMint &&\n          feeAccount &&\n          feeAccount.info.mint.toBase58() === p.pubkeys.mint.toBase58()\n        ) {\n          const feeBalance = feeAccount?.info.amount.toNumber();\n          const supply = poolMint?.supply.toNumber();\n\n          const ownedPct = feeBalance / supply;\n\n          const poolOwnerFees =\n            ownedPct * baseReserveUSD + ownedPct * quoteReserveUSD;\n          volume = poolOwnerFees / 0.0004;\n          fees = volume * 0.003;\n\n          if (fees !== 0) {\n            const baseVolume = (ownedPct * baseReserveUSD) / 0.0004;\n            const quoteVolume = (ownedPct * quoteReserveUSD) / 0.0004;\n\n            // Aproximation not true for all pools we need to fine a better way\n            const daysSinceInception = Math.floor(\n              (TODAY.getTime() - INITAL_LIQUIDITY_DATE.getTime()) /\n              (24 * 3600 * 1000)\n            );\n            const apy0 =\n              parseFloat(\n                ((baseVolume / daysSinceInception) * 0.003 * 356) as any\n              ) / baseReserveUSD;\n            const apy1 =\n              parseFloat(\n                ((quoteVolume / daysSinceInception) * 0.003 * 356) as any\n              ) / quoteReserveUSD;\n\n            apy = apy + Math.max(apy0, apy1);\n          }\n        }\n      }\n\n      const lpMint = cache.getMint(p.pubkeys.mint);\n\n      const name = getPoolName(env, p);\n      const link = `#/?pair=${getPoolName(env, p, false).replace(\"/\", \"-\")}`;\n\n      return {\n        key: p.pubkeys.account.toBase58(),\n        id: index,\n        name,\n        names: mints.map((m) => getTokenName(env, m)),\n        address: p.pubkeys.mint.toBase58(),\n        link,\n        mints,\n        liquidityA: convert(accountA, mintA),\n        liquidityAinUsd: baseReserveUSD,\n        liquidityB: convert(accountB, mintB),\n        liquidityBinUsd: quoteReserveUSD,\n        supply:\n          lpMint &&\n          (\n            lpMint?.supply.toNumber() / Math.pow(10, lpMint?.decimals || 0)\n          ).toFixed(9),\n        fees,\n        liquidity: baseReserveUSD + quoteReserveUSD,\n        volume,\n        apy: Number.isFinite(apy) ? apy : 0,\n        raw: p,\n      };\n    })\n    .filter((p) => p !== undefined);\n  return result;\n}\n\nfunction calculateAirdropYield(\n  p: PoolInfo,\n  marketByMint: Map<string, SerumMarket>,\n  baseReserveUSD: number,\n  quoteReserveUSD: number\n) {\n  let airdropYield = 0;\n  let poolWithAirdrop = POOLS_WITH_AIRDROP.find((drop) =>\n    drop.pool.equals(p.pubkeys.mint)\n  );\n  if (poolWithAirdrop) {\n    airdropYield = poolWithAirdrop.airdrops.reduce((acc, item) => {\n      const market = marketByMint.get(item.mint.toBase58())?.marketInfo.address;\n      if (market) {\n        const midPrice = getMidPrice(market?.toBase58(), item.mint.toBase58());\n\n        acc =\n          acc +\n          // airdrop yield\n          ((item.amount * midPrice) / (baseReserveUSD + quoteReserveUSD)) *\n          (365 / 30);\n      }\n\n      return acc;\n    }, 0);\n  }\n  return airdropYield;\n}\n\nconst OrderBookParser = (id: PublicKey, acc: AccountInfo<Buffer>) => {\n  const decoded = Orderbook.LAYOUT.decode(acc.data);\n\n  const details = {\n    pubkey: id,\n    account: {\n      ...acc,\n    },\n    info: decoded,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nconst getMidPrice = (marketAddress?: string, mintAddress?: string) => {\n  const SERUM_TOKEN = TOKEN_MINTS.find(\n    (a) => a.address.toBase58() === mintAddress\n  );\n\n  if (STABLE_COINS.has(SERUM_TOKEN?.name || \"\")) {\n    return 1.0;\n  }\n\n  if (!marketAddress) {\n    return 0.0;\n  }\n\n  const marketInfo = cache.get(marketAddress);\n  if (!marketInfo) {\n    return 0.0;\n  }\n\n  const decodedMarket = marketInfo.info;\n\n  const baseMintDecimals =\n    cache.get(decodedMarket.baseMint)?.info.decimals || 0;\n  const quoteMintDecimals =\n    cache.get(decodedMarket.quoteMint)?.info.decimals || 0;\n\n  const market = new Market(\n    decodedMarket,\n    baseMintDecimals,\n    quoteMintDecimals,\n    undefined,\n    decodedMarket.programId\n  );\n\n  const bids = cache.get(decodedMarket.bids)?.info;\n  const asks = cache.get(decodedMarket.asks)?.info;\n\n  if (bids && asks) {\n    const bidsBook = new Orderbook(market, bids.accountFlags, bids.slab);\n    const asksBook = new Orderbook(market, asks.accountFlags, asks.slab);\n\n    const bestBid = bidsBook.getL2(1);\n    const bestAsk = asksBook.getL2(1);\n\n    if (bestBid.length > 0 && bestAsk.length > 0) {\n      return (bestBid[0][0] + bestAsk[0][0]) / 2.0;\n    }\n  }\n\n  return 0;\n};\n\nconst refreshAccounts = async (connection: Connection, keys: string[]) => {\n  if (keys.length === 0) {\n    return [];\n  }\n\n  return getMultipleAccounts(connection, keys, \"single\").then(\n    ({ keys, array }) => {\n      return array.map((item, index) => {\n        const address = keys[index];\n        return cache.add(new PublicKey(address), item);\n      });\n    }\n  );\n};\n\ninterface SerumMarket {\n  marketInfo: {\n    address: PublicKey;\n    name: string;\n    programId: PublicKey;\n    deprecated: boolean;\n  };\n\n  // 1st query\n  marketAccount?: AccountInfo<Buffer>;\n\n  // 2nd query\n  mintBase?: AccountInfo<Buffer>;\n  mintQuote?: AccountInfo<Buffer>;\n  bidAccount?: AccountInfo<Buffer>;\n  askAccount?: AccountInfo<Buffer>;\n  eventQueue?: AccountInfo<Buffer>;\n\n  midPrice?: (mint?: PublicKey) => number;\n}\n"]},"metadata":{},"sourceType":"module"}