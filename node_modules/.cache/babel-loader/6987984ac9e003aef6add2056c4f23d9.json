{"ast":null,"code":"import _regeneratorRuntime from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport assert from 'assert';\nimport BN from 'bn.js';\nimport { blob, struct, u32, u8 } from 'buffer-layout';\nimport { sendAndConfirmTransaction as sendAndConfirmTransaction$1, PublicKey, Account, Transaction, SystemProgram, TransactionInstruction, SYSVAR_RENT_PUBKEY } from '@solana/web3.js';\n/**\n * Layout for a public key\n */\n\nvar publicKey = function publicKey() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'publicKey';\n  return blob(32, property);\n};\n/**\n * Layout for a 64bit unsigned value\n */\n\n\nvar uint64 = function uint64() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'uint64';\n  return blob(8, property);\n};\n\nfunction sendAndConfirmTransaction(title, connection, transaction) {\n  for (var _len = arguments.length, signers = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    signers[_key - 3] = arguments[_key];\n  }\n\n  return sendAndConfirmTransaction$1(connection, transaction, signers, {\n    skipPreflight: false,\n    commitment: 'recent',\n    preflightCommitment: 'recent'\n  });\n}\n/**\n * 64-bit value\n */\n\n\nvar u64 = /*#__PURE__*/function (_BN) {\n  _inherits(u64, _BN);\n\n  var _super = _createSuper(u64);\n\n  function u64() {\n    _classCallCheck(this, u64);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(u64, [{\n    key: \"toBuffer\",\n\n    /**\n     * Convert to Buffer representation\n     */\n    value: function toBuffer() {\n      var a = _get(_getPrototypeOf(u64.prototype), \"toArray\", this).call(this).reverse();\n\n      var b = Buffer.from(a);\n\n      if (b.length === 8) {\n        return b;\n      }\n\n      assert(b.length < 8, 'u64 too large');\n      var zeroPad = Buffer.alloc(8);\n      b.copy(zeroPad);\n      return zeroPad;\n    }\n    /**\n     * Construct a u64 from Buffer representation\n     */\n\n  }], [{\n    key: \"fromBuffer\",\n    value: function fromBuffer(buffer) {\n      assert(buffer.length === 8, \"Invalid buffer length: \".concat(buffer.length));\n      return new BN(_toConsumableArray(buffer).reverse().map(function (i) {\n        return \"00\".concat(i.toString(16)).slice(-2);\n      }).join(''), 16);\n    }\n  }]);\n\n  return u64;\n}(BN);\n\nfunction isAccount(accountOrPublicKey) {\n  return 'publicKey' in accountOrPublicKey;\n}\n\nvar AuthorityTypeCodes = {\n  MintTokens: 0,\n  FreezeAccount: 1,\n  AccountOwner: 2,\n  CloseAccount: 3\n}; // The address of the special mint for wrapped native token.\n\nvar NATIVE_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n/**\n * Information about the mint\n */\n\nvar MintLayout = struct([u32('mintAuthorityOption'), publicKey('mintAuthority'), uint64('supply'), u8('decimals'), u8('isInitialized'), u32('freezeAuthorityOption'), publicKey('freezeAuthority')]);\n/**\n * Information about an account\n */\n\n/**\n * @private\n */\n\nvar AccountLayout = struct([publicKey('mint'), publicKey('owner'), uint64('amount'), u32('delegateOption'), publicKey('delegate'), u8('state'), u32('isNativeOption'), uint64('isNative'), uint64('delegatedAmount'), u32('closeAuthorityOption'), publicKey('closeAuthority')]);\n/**\n * Information about an multisig\n */\n\n/**\n * @private\n */\n\nvar MultisigLayout = struct([u8('m'), u8('n'), u8('is_initialized'), publicKey('signer1'), publicKey('signer2'), publicKey('signer3'), publicKey('signer4'), publicKey('signer5'), publicKey('signer6'), publicKey('signer7'), publicKey('signer8'), publicKey('signer9'), publicKey('signer10'), publicKey('signer11')]);\n/**\n * An ERC20-like Token\n */\n\nvar Token = /*#__PURE__*/function () {\n  /**\n   * @private\n   */\n\n  /**\n   * The public key identifying this mint\n   */\n\n  /**\n   * Program Identifier for the Token program\n   */\n\n  /**\n   * Fee payer\n   */\n\n  /**\n   * Create a Token object attached to the specific mint\n   *\n   * @param connection The connection to use\n   * @param token Public key of the mint\n   * @param programId token programId\n   * @param payer Payer of fees\n   */\n  function Token(connection, publicKey, programId, payer) {\n    _classCallCheck(this, Token);\n\n    _defineProperty(this, \"connection\", void 0);\n\n    _defineProperty(this, \"publicKey\", void 0);\n\n    _defineProperty(this, \"programId\", void 0);\n\n    _defineProperty(this, \"payer\", void 0);\n\n    Object.assign(this, {\n      connection: connection,\n      publicKey: publicKey,\n      programId: programId,\n      payer: payer\n    });\n  }\n  /**\n   * Get the minimum balance for the mint to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n\n\n  _createClass(Token, [{\n    key: \"createAccount\",\n\n    /**\n     * Create and initialize a new account.\n     *\n     * This account may then be used as a `transfer()` or `approve()` destination\n     *\n     * @param owner User account that will own the new account\n     * @return Public key of the new empty account\n     */\n    value: function () {\n      var _createAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(owner) {\n        var balanceNeeded, newAccount, transaction, mintPublicKey;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return Token.getMinBalanceRentForExemptAccount(this.connection);\n\n              case 2:\n                balanceNeeded = _context.sent;\n                newAccount = new Account();\n                transaction = new Transaction();\n                transaction.add(SystemProgram.createAccount({\n                  fromPubkey: this.payer.publicKey,\n                  newAccountPubkey: newAccount.publicKey,\n                  lamports: balanceNeeded,\n                  space: AccountLayout.span,\n                  programId: this.programId\n                }));\n                mintPublicKey = this.publicKey;\n                transaction.add(Token.createInitAccountInstruction(this.programId, mintPublicKey, newAccount.publicKey, owner)); // Send the two instructions\n\n                _context.next = 10;\n                return sendAndConfirmTransaction('createAccount and InitializeAccount', this.connection, transaction, this.payer, newAccount);\n\n              case 10:\n                return _context.abrupt(\"return\", newAccount.publicKey);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function createAccount(_x) {\n        return _createAccount.apply(this, arguments);\n      }\n\n      return createAccount;\n    }()\n    /**\n     * Create and initialize a new account on the special native token mint.\n     *\n     * In order to be wrapped, the account must have a balance of native tokens\n     * when it is initialized with the token program.\n     *\n     * This function sends lamports to the new account before initializing it.\n     *\n     * @param connection A solana web3 connection\n     * @param programId The token program ID\n     * @param owner The owner of the new token account\n     * @param payer The source of the lamports to initialize, and payer of the initialization fees.\n     * @param amount The amount of lamports to wrap\n     * @return {Promise<PublicKey>} The new token account\n     */\n\n  }, {\n    key: \"createMultisig\",\n\n    /**\n     * Create and initialize a new multisig.\n     *\n     * This account may then be used for multisignature verification\n     *\n     * @param m Number of required signatures\n     * @param signers Full set of signers\n     * @return Public key of the new multisig account\n     */\n    value: function () {\n      var _createMultisig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(m, signers) {\n        var multisigAccount, balanceNeeded, transaction, keys, dataLayout, data;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                multisigAccount = new Account(); // Allocate memory for the account\n\n                _context2.next = 3;\n                return Token.getMinBalanceRentForExemptMultisig(this.connection);\n\n              case 3:\n                balanceNeeded = _context2.sent;\n                transaction = new Transaction();\n                transaction.add(SystemProgram.createAccount({\n                  fromPubkey: this.payer.publicKey,\n                  newAccountPubkey: multisigAccount.publicKey,\n                  lamports: balanceNeeded,\n                  space: MultisigLayout.span,\n                  programId: this.programId\n                })); // create the new account\n\n                keys = [{\n                  pubkey: multisigAccount.publicKey,\n                  isSigner: false,\n                  isWritable: true\n                }, {\n                  pubkey: SYSVAR_RENT_PUBKEY,\n                  isSigner: false,\n                  isWritable: false\n                }];\n                signers.forEach(function (signer) {\n                  return keys.push({\n                    pubkey: signer,\n                    isSigner: false,\n                    isWritable: false\n                  });\n                });\n                dataLayout = struct([u8('instruction'), u8('m')]);\n                data = Buffer.alloc(dataLayout.span);\n                dataLayout.encode({\n                  instruction: 2,\n                  // InitializeMultisig instruction\n                  m: m\n                }, data);\n                transaction.add({\n                  keys: keys,\n                  programId: this.programId,\n                  data: data\n                }); // Send the two instructions\n\n                _context2.next = 14;\n                return sendAndConfirmTransaction('createAccount and InitializeMultisig', this.connection, transaction, this.payer, multisigAccount);\n\n              case 14:\n                return _context2.abrupt(\"return\", multisigAccount.publicKey);\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function createMultisig(_x2, _x3) {\n        return _createMultisig.apply(this, arguments);\n      }\n\n      return createMultisig;\n    }()\n    /**\n     * Retrieve mint information\n     */\n\n  }, {\n    key: \"getMintInfo\",\n    value: function () {\n      var _getMintInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var info, data, mintInfo;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.connection.getAccountInfo(this.publicKey);\n\n              case 2:\n                info = _context3.sent;\n\n                if (!(info === null)) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                throw new Error('Failed to find mint account');\n\n              case 5:\n                if (info.owner.equals(this.programId)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Invalid mint owner: \".concat(JSON.stringify(info.owner)));\n\n              case 7:\n                if (!(info.data.length != MintLayout.span)) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                throw new Error(\"Invalid mint size\");\n\n              case 9:\n                data = Buffer.from(info.data);\n                mintInfo = MintLayout.decode(data);\n\n                if (mintInfo.mintAuthorityOption === 0) {\n                  mintInfo.mintAuthority = null;\n                } else {\n                  mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n                }\n\n                mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n                mintInfo.isInitialized = mintInfo.isInitialized != 0;\n\n                if (mintInfo.freezeAuthorityOption === 0) {\n                  mintInfo.freezeAuthority = null;\n                } else {\n                  mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n                }\n\n                return _context3.abrupt(\"return\", mintInfo);\n\n              case 16:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getMintInfo() {\n        return _getMintInfo.apply(this, arguments);\n      }\n\n      return getMintInfo;\n    }()\n    /**\n     * Retrieve account information\n     *\n     * @param account Public key of the account\n     */\n\n  }, {\n    key: \"getAccountInfo\",\n    value: function () {\n      var _getAccountInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(account, commitment) {\n        var info, data, accountInfo;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.connection.getAccountInfo(account, commitment);\n\n              case 2:\n                info = _context4.sent;\n\n                if (!(info === null)) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                throw new Error('Failed to find account');\n\n              case 5:\n                if (info.owner.equals(this.programId)) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Invalid account owner\");\n\n              case 7:\n                if (!(info.data.length != AccountLayout.span)) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                throw new Error(\"Invalid account size\");\n\n              case 9:\n                data = Buffer.from(info.data);\n                accountInfo = AccountLayout.decode(data);\n                accountInfo.mint = new PublicKey(accountInfo.mint);\n                accountInfo.owner = new PublicKey(accountInfo.owner);\n                accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n                if (accountInfo.delegateOption === 0) {\n                  accountInfo.delegate = null;\n                  accountInfo.delegatedAmount = new u64();\n                } else {\n                  accountInfo.delegate = new PublicKey(accountInfo.delegate);\n                  accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n                }\n\n                accountInfo.isInitialized = accountInfo.state !== 0;\n                accountInfo.isFrozen = accountInfo.state === 2;\n\n                if (accountInfo.isNativeOption === 1) {\n                  accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n                  accountInfo.isNative = true;\n                } else {\n                  accountInfo.rentExemptReserve = null;\n                  accountInfo.isNative = false;\n                }\n\n                if (accountInfo.closeAuthorityOption === 0) {\n                  accountInfo.closeAuthority = null;\n                } else {\n                  accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n                }\n\n                if (accountInfo.mint.equals(this.publicKey)) {\n                  _context4.next = 21;\n                  break;\n                }\n\n                throw new Error(\"Invalid account mint: \".concat(JSON.stringify(accountInfo.mint), \" !== \").concat(JSON.stringify(this.publicKey)));\n\n              case 21:\n                return _context4.abrupt(\"return\", accountInfo);\n\n              case 22:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getAccountInfo(_x4, _x5) {\n        return _getAccountInfo.apply(this, arguments);\n      }\n\n      return getAccountInfo;\n    }()\n    /**\n     * Retrieve Multisig information\n     *\n     * @param multisig Public key of the account\n     */\n\n  }, {\n    key: \"getMultisigInfo\",\n    value: function () {\n      var _getMultisigInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(multisig) {\n        var info, data, multisigInfo;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.connection.getAccountInfo(multisig);\n\n              case 2:\n                info = _context5.sent;\n\n                if (!(info === null)) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                throw new Error('Failed to find multisig');\n\n              case 5:\n                if (info.owner.equals(this.programId)) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Invalid multisig owner\");\n\n              case 7:\n                if (!(info.data.length != MultisigLayout.span)) {\n                  _context5.next = 9;\n                  break;\n                }\n\n                throw new Error(\"Invalid multisig size\");\n\n              case 9:\n                data = Buffer.from(info.data);\n                multisigInfo = MultisigLayout.decode(data);\n                multisigInfo.signer1 = new PublicKey(multisigInfo.signer1);\n                multisigInfo.signer2 = new PublicKey(multisigInfo.signer2);\n                multisigInfo.signer3 = new PublicKey(multisigInfo.signer3);\n                multisigInfo.signer4 = new PublicKey(multisigInfo.signer4);\n                multisigInfo.signer5 = new PublicKey(multisigInfo.signer5);\n                multisigInfo.signer6 = new PublicKey(multisigInfo.signer6);\n                multisigInfo.signer7 = new PublicKey(multisigInfo.signer7);\n                multisigInfo.signer8 = new PublicKey(multisigInfo.signer8);\n                multisigInfo.signer9 = new PublicKey(multisigInfo.signer9);\n                multisigInfo.signer10 = new PublicKey(multisigInfo.signer10);\n                multisigInfo.signer11 = new PublicKey(multisigInfo.signer11);\n                return _context5.abrupt(\"return\", multisigInfo);\n\n              case 23:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getMultisigInfo(_x6) {\n        return _getMultisigInfo.apply(this, arguments);\n      }\n\n      return getMultisigInfo;\n    }()\n    /**\n     * Transfer tokens to another account\n     *\n     * @param source Source account\n     * @param destination Destination account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Number of tokens to transfer\n     */\n\n  }, {\n    key: \"transfer\",\n    value: function () {\n      var _transfer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(source, destination, owner, multiSigners, amount) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (isAccount(owner)) {\n                  ownerPublicKey = owner.publicKey;\n                  signers = [owner];\n                } else {\n                  ownerPublicKey = owner;\n                  signers = multiSigners;\n                }\n\n                _context6.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['Transfer', this.connection, new Transaction().add(Token.createTransferInstruction(this.programId, source, destination, ownerPublicKey, multiSigners, amount)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function transfer(_x7, _x8, _x9, _x10, _x11) {\n        return _transfer.apply(this, arguments);\n      }\n\n      return transfer;\n    }()\n    /**\n     * Grant a third-party permission to transfer up the specified number of tokens from an account\n     *\n     * @param account Public key of the account\n     * @param delegate Account authorized to perform a transfer tokens from the source account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Maximum number of tokens the delegate may transfer\n     */\n\n  }, {\n    key: \"approve\",\n    value: function () {\n      var _approve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(account, delegate, owner, multiSigners, amount) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (isAccount(owner)) {\n                  ownerPublicKey = owner.publicKey;\n                  signers = [owner];\n                } else {\n                  ownerPublicKey = owner;\n                  signers = multiSigners;\n                }\n\n                _context7.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['Approve', this.connection, new Transaction().add(Token.createApproveInstruction(this.programId, account, delegate, ownerPublicKey, multiSigners, amount)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function approve(_x12, _x13, _x14, _x15, _x16) {\n        return _approve.apply(this, arguments);\n      }\n\n      return approve;\n    }()\n    /**\n     * Remove approval for the transfer of any remaining tokens\n     *\n     * @param account Public key of the account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     */\n\n  }, {\n    key: \"revoke\",\n    value: function () {\n      var _revoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(account, owner, multiSigners) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (isAccount(owner)) {\n                  ownerPublicKey = owner.publicKey;\n                  signers = [owner];\n                } else {\n                  ownerPublicKey = owner;\n                  signers = multiSigners;\n                }\n\n                _context8.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['Revoke', this.connection, new Transaction().add(Token.createRevokeInstruction(this.programId, account, ownerPublicKey, multiSigners)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function revoke(_x17, _x18, _x19) {\n        return _revoke.apply(this, arguments);\n      }\n\n      return revoke;\n    }()\n    /**\n     * Assign a new authority to the account\n     *\n     * @param account Public key of the account\n     * @param newAuthority New authority of the account\n     * @param authorityType Type of authority to set\n     * @param currentAuthority Current authority of the account\n     * @param multiSigners Signing accounts if `currentAuthority` is a multiSig\n     */\n\n  }, {\n    key: \"setAuthority\",\n    value: function () {\n      var _setAuthority = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(account, newAuthority, authorityType, currentAuthority, multiSigners) {\n        var currentAuthorityPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (isAccount(currentAuthority)) {\n                  currentAuthorityPublicKey = currentAuthority.publicKey;\n                  signers = [currentAuthority];\n                } else {\n                  currentAuthorityPublicKey = currentAuthority;\n                  signers = multiSigners;\n                }\n\n                _context9.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['SetAuthority', this.connection, new Transaction().add(Token.createSetAuthorityInstruction(this.programId, account, newAuthority, authorityType, currentAuthorityPublicKey, multiSigners)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function setAuthority(_x20, _x21, _x22, _x23, _x24) {\n        return _setAuthority.apply(this, arguments);\n      }\n\n      return setAuthority;\n    }()\n    /**\n     * Mint new tokens\n     *\n     * @param dest Public key of the account to mint to\n     * @param authority Minting authority\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount Amount to mint\n     */\n\n  }, {\n    key: \"mintTo\",\n    value: function () {\n      var _mintTo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(dest, authority, multiSigners, amount) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (isAccount(authority)) {\n                  ownerPublicKey = authority.publicKey;\n                  signers = [authority];\n                } else {\n                  ownerPublicKey = authority;\n                  signers = multiSigners;\n                }\n\n                _context10.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['MintTo', this.connection, new Transaction().add(Token.createMintToInstruction(this.programId, this.publicKey, dest, ownerPublicKey, multiSigners, amount)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function mintTo(_x25, _x26, _x27, _x28) {\n        return _mintTo.apply(this, arguments);\n      }\n\n      return mintTo;\n    }()\n    /**\n     * Burn tokens\n     *\n     * @param account Account to burn tokens from\n     * @param owner Account owner\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Amount to burn\n     */\n\n  }, {\n    key: \"burn\",\n    value: function () {\n      var _burn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(account, owner, multiSigners, amount) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (isAccount(owner)) {\n                  ownerPublicKey = owner.publicKey;\n                  signers = [owner];\n                } else {\n                  ownerPublicKey = owner;\n                  signers = multiSigners;\n                }\n\n                _context11.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['Burn', this.connection, new Transaction().add(Token.createBurnInstruction(this.programId, this.publicKey, account, ownerPublicKey, multiSigners, amount)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function burn(_x29, _x30, _x31, _x32) {\n        return _burn.apply(this, arguments);\n      }\n\n      return burn;\n    }()\n    /**\n     * Close account\n     *\n     * @param account Account to close\n     * @param dest Account to receive the remaining balance of the closed account\n     * @param authority Authority which is allowed to close the account\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     */\n\n  }, {\n    key: \"closeAccount\",\n    value: function () {\n      var _closeAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(account, dest, authority, multiSigners) {\n        var authorityPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (isAccount(authority)) {\n                  authorityPublicKey = authority.publicKey;\n                  signers = [authority];\n                } else {\n                  authorityPublicKey = authority;\n                  signers = multiSigners;\n                }\n\n                _context12.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['CloseAccount', this.connection, new Transaction().add(Token.createCloseAccountInstruction(this.programId, account, dest, authorityPublicKey, multiSigners)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function closeAccount(_x33, _x34, _x35, _x36) {\n        return _closeAccount.apply(this, arguments);\n      }\n\n      return closeAccount;\n    }()\n    /**\n     * Freeze account\n     *\n     * @param account Account to freeze\n     * @param authority The mint freeze authority\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     */\n\n  }, {\n    key: \"freezeAccount\",\n    value: function () {\n      var _freezeAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(account, authority, multiSigners) {\n        var authorityPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (isAccount(authority)) {\n                  authorityPublicKey = authority.publicKey;\n                  signers = [authority];\n                } else {\n                  authorityPublicKey = authority;\n                  signers = multiSigners;\n                }\n\n                _context13.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['FreezeAccount', this.connection, new Transaction().add(Token.createFreezeAccountInstruction(this.programId, account, this.publicKey, authorityPublicKey, multiSigners)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function freezeAccount(_x37, _x38, _x39) {\n        return _freezeAccount.apply(this, arguments);\n      }\n\n      return freezeAccount;\n    }()\n    /**\n     * Thaw account\n     *\n     * @param account Account to thaw\n     * @param authority The mint freeze authority\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     */\n\n  }, {\n    key: \"thawAccount\",\n    value: function () {\n      var _thawAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(account, authority, multiSigners) {\n        var authorityPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                if (isAccount(authority)) {\n                  authorityPublicKey = authority.publicKey;\n                  signers = [authority];\n                } else {\n                  authorityPublicKey = authority;\n                  signers = multiSigners;\n                }\n\n                _context14.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['ThawAccount', this.connection, new Transaction().add(Token.createThawAccountInstruction(this.programId, account, this.publicKey, authorityPublicKey, multiSigners)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function thawAccount(_x40, _x41, _x42) {\n        return _thawAccount.apply(this, arguments);\n      }\n\n      return thawAccount;\n    }()\n    /**\n     * Transfer tokens to another account, asserting the token mint and decimals\n     *\n     * @param source Source account\n     * @param destination Destination account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Number of tokens to transfer\n     * @param decimals Number of decimals in transfer amount\n     */\n\n  }, {\n    key: \"transfer2\",\n    value: function () {\n      var _transfer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(source, destination, owner, multiSigners, amount, decimals) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                if (isAccount(owner)) {\n                  ownerPublicKey = owner.publicKey;\n                  signers = [owner];\n                } else {\n                  ownerPublicKey = owner;\n                  signers = multiSigners;\n                }\n\n                _context15.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['Transfer2', this.connection, new Transaction().add(Token.createTransfer2Instruction(this.programId, source, this.publicKey, destination, ownerPublicKey, multiSigners, amount, decimals)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n                return _context15.abrupt(\"return\", _context15.sent);\n\n              case 4:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function transfer2(_x43, _x44, _x45, _x46, _x47, _x48) {\n        return _transfer2.apply(this, arguments);\n      }\n\n      return transfer2;\n    }()\n    /**\n     * Grant a third-party permission to transfer up the specified number of tokens from an account,\n     * asserting the token mint and decimals\n     *\n     * @param account Public key of the account\n     * @param delegate Account authorized to perform a transfer tokens from the source account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Maximum number of tokens the delegate may transfer\n     * @param decimals Number of decimals in approve amount\n     */\n\n  }, {\n    key: \"approve2\",\n    value: function () {\n      var _approve2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(account, delegate, owner, multiSigners, amount, decimals) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                if (isAccount(owner)) {\n                  ownerPublicKey = owner.publicKey;\n                  signers = [owner];\n                } else {\n                  ownerPublicKey = owner;\n                  signers = multiSigners;\n                }\n\n                _context16.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['Approve2', this.connection, new Transaction().add(Token.createApprove2Instruction(this.programId, account, this.publicKey, delegate, ownerPublicKey, multiSigners, amount, decimals)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function approve2(_x49, _x50, _x51, _x52, _x53, _x54) {\n        return _approve2.apply(this, arguments);\n      }\n\n      return approve2;\n    }()\n    /**\n     * Mint new tokens, asserting the token mint and decimals\n     *\n     * @param dest Public key of the account to mint to\n     * @param authority Minting authority\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount Amount to mint\n     * @param decimals Number of decimals in amount to mint\n     */\n\n  }, {\n    key: \"mintTo2\",\n    value: function () {\n      var _mintTo2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(dest, authority, multiSigners, amount, decimals) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                if (isAccount(authority)) {\n                  ownerPublicKey = authority.publicKey;\n                  signers = [authority];\n                } else {\n                  ownerPublicKey = authority;\n                  signers = multiSigners;\n                }\n\n                _context17.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['MintTo2', this.connection, new Transaction().add(Token.createMintTo2Instruction(this.programId, this.publicKey, dest, ownerPublicKey, multiSigners, amount, decimals)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function mintTo2(_x55, _x56, _x57, _x58, _x59) {\n        return _mintTo2.apply(this, arguments);\n      }\n\n      return mintTo2;\n    }()\n    /**\n     * Burn tokens, asserting the token mint and decimals\n     *\n     * @param account Account to burn tokens from\n     * @param owner Account owner\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Amount to burn\n     * @param decimals Number of decimals in amount to burn\n     */\n\n  }, {\n    key: \"burn2\",\n    value: function () {\n      var _burn2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(account, owner, multiSigners, amount, decimals) {\n        var ownerPublicKey, signers;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                if (isAccount(owner)) {\n                  ownerPublicKey = owner.publicKey;\n                  signers = [owner];\n                } else {\n                  ownerPublicKey = owner;\n                  signers = multiSigners;\n                }\n\n                _context18.next = 3;\n                return sendAndConfirmTransaction.apply(void 0, ['Burn2', this.connection, new Transaction().add(Token.createBurn2Instruction(this.programId, this.publicKey, account, ownerPublicKey, multiSigners, amount, decimals)), this.payer].concat(_toConsumableArray(signers)));\n\n              case 3:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function burn2(_x60, _x61, _x62, _x63, _x64) {\n        return _burn2.apply(this, arguments);\n      }\n\n      return burn2;\n    }()\n    /**\n     * Construct an InitializeMint instruction\n     *\n     * @param programId SPL Token program account\n     * @param mint Token mint account\n     * @param decimals Number of decimals in token account amounts\n     * @param mintAuthority Minting authority\n     * @param freezeAuthority Optional authority that can freeze token accounts\n     */\n\n  }], [{\n    key: \"getMinBalanceRentForExemptMint\",\n    value: function () {\n      var _getMinBalanceRentForExemptMint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(connection) {\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.next = 2;\n                return connection.getMinimumBalanceForRentExemption(MintLayout.span);\n\n              case 2:\n                return _context19.abrupt(\"return\", _context19.sent);\n\n              case 3:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19);\n      }));\n\n      function getMinBalanceRentForExemptMint(_x65) {\n        return _getMinBalanceRentForExemptMint.apply(this, arguments);\n      }\n\n      return getMinBalanceRentForExemptMint;\n    }()\n    /**\n     * Get the minimum balance for the account to be rent exempt\n     *\n     * @return Number of lamports required\n     */\n\n  }, {\n    key: \"getMinBalanceRentForExemptAccount\",\n    value: function () {\n      var _getMinBalanceRentForExemptAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(connection) {\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                _context20.next = 2;\n                return connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n\n              case 2:\n                return _context20.abrupt(\"return\", _context20.sent);\n\n              case 3:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20);\n      }));\n\n      function getMinBalanceRentForExemptAccount(_x66) {\n        return _getMinBalanceRentForExemptAccount.apply(this, arguments);\n      }\n\n      return getMinBalanceRentForExemptAccount;\n    }()\n    /**\n     * Get the minimum balance for the multsig to be rent exempt\n     *\n     * @return Number of lamports required\n     */\n\n  }, {\n    key: \"getMinBalanceRentForExemptMultisig\",\n    value: function () {\n      var _getMinBalanceRentForExemptMultisig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(connection) {\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.next = 2;\n                return connection.getMinimumBalanceForRentExemption(MultisigLayout.span);\n\n              case 2:\n                return _context21.abrupt(\"return\", _context21.sent);\n\n              case 3:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21);\n      }));\n\n      function getMinBalanceRentForExemptMultisig(_x67) {\n        return _getMinBalanceRentForExemptMultisig.apply(this, arguments);\n      }\n\n      return getMinBalanceRentForExemptMultisig;\n    }()\n    /**\n     * Create and initialize a token.\n     *\n     * @param connection The connection to use\n     * @param payer Fee payer for transaction\n     * @param mintAuthority Account or multisig that will control minting\n     * @param freezeAuthority Optional account or multisig that can freeze token accounts\n     * @param decimals Location of the decimal place\n     * @param programId Optional token programId, uses the system programId by default\n     * @return Token object for the newly minted token\n     */\n\n  }, {\n    key: \"createMint\",\n    value: function () {\n      var _createMint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(connection, payer, mintAuthority, freezeAuthority, decimals, programId) {\n        var mintAccount, token, balanceNeeded, transaction;\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                mintAccount = new Account();\n                token = new Token(connection, mintAccount.publicKey, programId, payer); // Allocate memory for the account\n\n                _context22.next = 4;\n                return Token.getMinBalanceRentForExemptMint(connection);\n\n              case 4:\n                balanceNeeded = _context22.sent;\n                transaction = new Transaction();\n                transaction.add(SystemProgram.createAccount({\n                  fromPubkey: payer.publicKey,\n                  newAccountPubkey: mintAccount.publicKey,\n                  lamports: balanceNeeded,\n                  space: MintLayout.span,\n                  programId: programId\n                }));\n                transaction.add(Token.createInitMintInstruction(programId, mintAccount.publicKey, decimals, mintAuthority, freezeAuthority)); // Send the two instructions\n\n                _context22.next = 10;\n                return sendAndConfirmTransaction('createAccount and InitializeMint', connection, transaction, payer, mintAccount);\n\n              case 10:\n                return _context22.abrupt(\"return\", token);\n\n              case 11:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22);\n      }));\n\n      function createMint(_x68, _x69, _x70, _x71, _x72, _x73) {\n        return _createMint.apply(this, arguments);\n      }\n\n      return createMint;\n    }()\n  }, {\n    key: \"createWrappedNativeAccount\",\n    value: function () {\n      var _createWrappedNativeAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(connection, programId, owner, payer, amount) {\n        var balanceNeeded, newAccount, transaction;\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.next = 2;\n                return Token.getMinBalanceRentForExemptAccount(connection);\n\n              case 2:\n                balanceNeeded = _context23.sent;\n                // Create a new account\n                newAccount = new Account();\n                transaction = new Transaction();\n                transaction.add(SystemProgram.createAccount({\n                  fromPubkey: payer.publicKey,\n                  newAccountPubkey: newAccount.publicKey,\n                  lamports: balanceNeeded,\n                  space: AccountLayout.span,\n                  programId: programId\n                })); // Send lamports to it (these will be wrapped into native tokens by the token program)\n\n                transaction.add(SystemProgram.transfer({\n                  fromPubkey: payer.publicKey,\n                  toPubkey: newAccount.publicKey,\n                  lamports: amount\n                })); // Assign the new account to the native token mint.\n                // the account will be initialized with a balance equal to the native token balance.\n                // (i.e. amount)\n\n                transaction.add(Token.createInitAccountInstruction(programId, NATIVE_MINT, newAccount.publicKey, owner)); // Send the three instructions\n\n                _context23.next = 10;\n                return sendAndConfirmTransaction('createAccount, transfer, and initializeAccount', connection, transaction, payer, newAccount);\n\n              case 10:\n                return _context23.abrupt(\"return\", newAccount.publicKey);\n\n              case 11:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23);\n      }));\n\n      function createWrappedNativeAccount(_x74, _x75, _x76, _x77, _x78) {\n        return _createWrappedNativeAccount.apply(this, arguments);\n      }\n\n      return createWrappedNativeAccount;\n    }()\n  }, {\n    key: \"createInitMintInstruction\",\n    value: function createInitMintInstruction(programId, mint, decimals, mintAuthority, freezeAuthority) {\n      var keys = [{\n        pubkey: mint,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }];\n      var commandDataLayout = struct([u8('instruction'), u8('decimals'), publicKey('mintAuthority'), u8('option'), publicKey('freezeAuthority')]);\n      var data = Buffer.alloc(1024);\n      {\n        var encodeLength = commandDataLayout.encode({\n          instruction: 0,\n          // InitializeMint instruction\n          decimals: decimals,\n          mintAuthority: mintAuthority.toBuffer(),\n          option: freezeAuthority === null ? 0 : 1,\n          freezeAuthority: (freezeAuthority || new PublicKey()).toBuffer()\n        }, data);\n        data = data.slice(0, encodeLength);\n      }\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct an InitializeAccount instruction\n     *\n     * @param programId SPL Token program account\n     * @param mint Token mint account\n     * @param account New account\n     * @param owner Owner of the new account\n     */\n\n  }, {\n    key: \"createInitAccountInstruction\",\n    value: function createInitAccountInstruction(programId, mint, account, owner) {\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: mint,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }];\n      var dataLayout = struct([u8('instruction')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 1 // InitializeAccount instruction\n\n      }, data);\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Transfer instruction\n     *\n     * @param programId SPL Token program account\n     * @param source Source account\n     * @param destination Destination account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount Number of tokens to transfer\n     */\n\n  }, {\n    key: \"createTransferInstruction\",\n    value: function createTransferInstruction(programId, source, destination, owner, multiSigners, amount) {\n      var dataLayout = struct([u8('instruction'), uint64('amount')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 3,\n        // Transfer instruction\n        amount: new u64(amount).toBuffer()\n      }, data);\n      var keys = [{\n        pubkey: source,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: destination,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct an Approve instruction\n     *\n     * @param programId SPL Token program account\n     * @param account Public key of the account\n     * @param delegate Account authorized to perform a transfer of tokens from the source account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Maximum number of tokens the delegate may transfer\n     */\n\n  }, {\n    key: \"createApproveInstruction\",\n    value: function createApproveInstruction(programId, account, delegate, owner, multiSigners, amount) {\n      var dataLayout = struct([u8('instruction'), uint64('amount')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 4,\n        // Approve instruction\n        amount: new u64(amount).toBuffer()\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: delegate,\n        isSigner: false,\n        isWritable: false\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Revoke instruction\n     *\n     * @param programId SPL Token program account\n     * @param account Public key of the account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     */\n\n  }, {\n    key: \"createRevokeInstruction\",\n    value: function createRevokeInstruction(programId, account, owner, multiSigners) {\n      var dataLayout = struct([u8('instruction')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 5 // Approve instruction\n\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a SetAuthority instruction\n     *\n     * @param programId SPL Token program account\n     * @param account Public key of the account\n     * @param newAuthority New authority of the account\n     * @param authorityType Type of authority to set\n     * @param currentAuthority Current authority of the specified type\n     * @param multiSigners Signing accounts if `currentAuthority` is a multiSig\n     */\n\n  }, {\n    key: \"createSetAuthorityInstruction\",\n    value: function createSetAuthorityInstruction(programId, account, newAuthority, authorityType, currentAuthority, multiSigners) {\n      var commandDataLayout = struct([u8('instruction'), u8('authorityType'), u8('option'), publicKey('newAuthority')]);\n      var data = Buffer.alloc(1024);\n      {\n        var encodeLength = commandDataLayout.encode({\n          instruction: 6,\n          // SetAuthority instruction\n          authorityType: AuthorityTypeCodes[authorityType],\n          option: newAuthority === null ? 0 : 1,\n          newAuthority: (newAuthority || new PublicKey()).toBuffer()\n        }, data);\n        data = data.slice(0, encodeLength);\n      }\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: currentAuthority,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: currentAuthority,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a MintTo instruction\n     *\n     * @param programId SPL Token program account\n     * @param mint Public key of the mint\n     * @param dest Public key of the account to mint to\n     * @param authority The mint authority\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount Amount to mint\n     */\n\n  }, {\n    key: \"createMintToInstruction\",\n    value: function createMintToInstruction(programId, mint, dest, authority, multiSigners, amount) {\n      var dataLayout = struct([u8('instruction'), uint64('amount')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 7,\n        // MintTo instruction\n        amount: new u64(amount).toBuffer()\n      }, data);\n      var keys = [{\n        pubkey: mint,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: dest,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: authority,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: authority,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Burn instruction\n     *\n     * @param programId SPL Token program account\n     * @param mint Mint for the account\n     * @param account Account to burn tokens from\n     * @param owner Owner of the account\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount amount to burn\n     */\n\n  }, {\n    key: \"createBurnInstruction\",\n    value: function createBurnInstruction(programId, mint, account, owner, multiSigners, amount) {\n      var dataLayout = struct([u8('instruction'), uint64('amount')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 8,\n        // Burn instruction\n        amount: new u64(amount).toBuffer()\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: mint,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Close instruction\n     *\n     * @param programId SPL Token program account\n     * @param account Account to close\n     * @param dest Account to receive the remaining balance of the closed account\n     * @param authority Account Close authority\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     */\n\n  }, {\n    key: \"createCloseAccountInstruction\",\n    value: function createCloseAccountInstruction(programId, account, dest, owner, multiSigners) {\n      var dataLayout = struct([u8('instruction')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 9 // CloseAccount instruction\n\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: dest,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Freeze instruction\n     *\n     * @param programId SPL Token program account\n     * @param account Account to freeze\n     * @param mint Mint account\n     * @param authority Mint freeze authority\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     */\n\n  }, {\n    key: \"createFreezeAccountInstruction\",\n    value: function createFreezeAccountInstruction(programId, account, mint, authority, multiSigners) {\n      var dataLayout = struct([u8('instruction')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 10 // FreezeAccount instruction\n\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: mint,\n        isSigner: false,\n        isWritable: false\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: authority,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: authority,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Thaw instruction\n     *\n     * @param programId SPL Token program account\n     * @param account Account to thaw\n     * @param mint Mint account\n     * @param authority Mint freeze authority\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     */\n\n  }, {\n    key: \"createThawAccountInstruction\",\n    value: function createThawAccountInstruction(programId, account, mint, authority, multiSigners) {\n      var dataLayout = struct([u8('instruction')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 11 // ThawAccount instruction\n\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: mint,\n        isSigner: false,\n        isWritable: false\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: authority,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: authority,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Transfer2 instruction\n     *\n     * @param programId SPL Token program account\n     * @param source Source account\n     * @param mint Mint account\n     * @param destination Destination account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount Number of tokens to transfer\n     * @param decimals Number of decimals in transfer amount\n     */\n\n  }, {\n    key: \"createTransfer2Instruction\",\n    value: function createTransfer2Instruction(programId, source, mint, destination, owner, multiSigners, amount, decimals) {\n      var dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 12,\n        // Transfer2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals: decimals\n      }, data);\n      var keys = [{\n        pubkey: source,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: mint,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: destination,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct an Approve2 instruction\n     *\n     * @param programId SPL Token program account\n     * @param account Public key of the account\n     * @param mint Mint account\n     * @param delegate Account authorized to perform a transfer of tokens from the source account\n     * @param owner Owner of the source account\n     * @param multiSigners Signing accounts if `owner` is a multiSig\n     * @param amount Maximum number of tokens the delegate may transfer\n     * @param decimals Number of decimals in approve amount\n     */\n\n  }, {\n    key: \"createApprove2Instruction\",\n    value: function createApprove2Instruction(programId, account, mint, delegate, owner, multiSigners, amount, decimals) {\n      var dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 13,\n        // Approve2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals: decimals\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: mint,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: delegate,\n        isSigner: false,\n        isWritable: false\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a MintTo2 instruction\n     *\n     * @param programId SPL Token program account\n     * @param mint Public key of the mint\n     * @param dest Public key of the account to mint to\n     * @param authority The mint authority\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount Amount to mint\n     * @param decimals Number of decimals in amount to mint\n     */\n\n  }, {\n    key: \"createMintTo2Instruction\",\n    value: function createMintTo2Instruction(programId, mint, dest, authority, multiSigners, amount, decimals) {\n      var dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 14,\n        // MintTo2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals: decimals\n      }, data);\n      var keys = [{\n        pubkey: mint,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: dest,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: authority,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: authority,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n    /**\n     * Construct a Burn2 instruction\n     *\n     * @param programId SPL Token program account\n     * @param mint Mint for the account\n     * @param account Account to burn tokens from\n     * @param owner Owner of the account\n     * @param multiSigners Signing accounts if `authority` is a multiSig\n     * @param amount amount to burn\n     */\n\n  }, {\n    key: \"createBurn2Instruction\",\n    value: function createBurn2Instruction(programId, mint, account, owner, multiSigners, amount, decimals) {\n      var dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 15,\n        // Burn2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals: decimals\n      }, data);\n      var keys = [{\n        pubkey: account,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: mint,\n        isSigner: false,\n        isWritable: true\n      }];\n\n      if (multiSigners.length === 0) {\n        keys.push({\n          pubkey: owner,\n          isSigner: true,\n          isWritable: false\n        });\n      } else {\n        keys.push({\n          pubkey: owner,\n          isSigner: false,\n          isWritable: false\n        });\n        multiSigners.forEach(function (signer) {\n          return keys.push({\n            pubkey: signer.publicKey,\n            isSigner: true,\n            isWritable: false\n          });\n        });\n      }\n\n      return new TransactionInstruction({\n        keys: keys,\n        programId: programId,\n        data: data\n      });\n    }\n  }]);\n\n  return Token;\n}();\n\nexport { AccountLayout, MintLayout, NATIVE_MINT, Token, u64 };","map":{"version":3,"sources":["../client/layout.js","../client/util/send-and-confirm-transaction.js","../client/token.js"],"names":["publicKey","property","BufferLayout","uint64","realSendAndConfirmTransaction","skipPreflight","commitment","preflightCommitment","a","b","Buffer","assert","zeroPad","buffer","i","AuthorityTypeCodes","MintTokens","FreezeAccount","AccountOwner","CloseAccount","NATIVE_MINT","MintLayout","Layout","AccountLayout","MultisigLayout","constructor","Object","connection","programId","payer","mintAccount","token","balanceNeeded","Token","transaction","fromPubkey","newAccountPubkey","lamports","space","sendAndConfirmTransaction","newAccount","mintPublicKey","toPubkey","amount","multisigAccount","keys","pubkey","isSigner","isWritable","signers","signer","dataLayout","data","instruction","m","info","JSON","mintInfo","u64","accountInfo","multisigInfo","isAccount","ownerPublicKey","owner","currentAuthorityPublicKey","currentAuthority","authority","authorityPublicKey","commandDataLayout","encodeLength","decimals","mintAuthority","option","freezeAuthority","multiSigners","authorityType","newAuthority"],"mappings":"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","sourcesContent":["// @flow\n\nimport * as BufferLayout from 'buffer-layout';\n\n/**\n * Layout for a public key\n */\nexport const publicKey = (property: string = 'publicKey'): Object => {\n  return BufferLayout.blob(32, property);\n};\n\n/**\n * Layout for a 64bit unsigned value\n */\nexport const uint64 = (property: string = 'uint64'): Object => {\n  return BufferLayout.blob(8, property);\n};\n\n/**\n * Layout for a Rust String type\n */\nexport const rustString = (property: string = 'string'): Object => {\n  const rsl = BufferLayout.struct(\n    [\n      BufferLayout.u32('length'),\n      BufferLayout.u32('lengthPadding'),\n      BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), 'chars'),\n    ],\n    property,\n  );\n  const _decode = rsl.decode.bind(rsl);\n  const _encode = rsl.encode.bind(rsl);\n\n  rsl.decode = (buffer, offset) => {\n    const data = _decode(buffer, offset);\n    return data.chars.toString('utf8');\n  };\n\n  rsl.encode = (str, buffer, offset) => {\n    const data = {\n      chars: Buffer.from(str, 'utf8'),\n    };\n    return _encode(data, buffer, offset);\n  };\n\n  return rsl;\n};\n","// @flow\n\nimport {sendAndConfirmTransaction as realSendAndConfirmTransaction} from '@solana/web3.js';\nimport type {\n  Account,\n  Connection,\n  Transaction,\n  TransactionSignature,\n} from '@solana/web3.js';\n\nexport function sendAndConfirmTransaction(\n  title: string,\n  connection: Connection,\n  transaction: Transaction,\n  ...signers: Array<Account>\n): Promise<TransactionSignature> {\n  return realSendAndConfirmTransaction(connection, transaction, signers, {\n    skipPreflight: false,\n    commitment: 'recent',\n    preflightCommitment: 'recent',\n  });\n}\n","/**\n * @flow\n */\n\nimport assert from 'assert';\nimport BN from 'bn.js';\nimport * as BufferLayout from 'buffer-layout';\nimport {\n  Account,\n  PublicKey,\n  SystemProgram,\n  Transaction,\n  TransactionInstruction,\n  SYSVAR_RENT_PUBKEY,\n} from '@solana/web3.js';\nimport type {\n  Connection,\n  Commitment,\n  TransactionSignature,\n} from '@solana/web3.js';\n\nimport * as Layout from './layout';\nimport {sendAndConfirmTransaction} from './util/send-and-confirm-transaction';\n\n/**\n * 64-bit value\n */\nexport class u64 extends BN {\n  /**\n   * Convert to Buffer representation\n   */\n  toBuffer(): typeof Buffer {\n    const a = super.toArray().reverse();\n    const b = Buffer.from(a);\n    if (b.length === 8) {\n      return b;\n    }\n    assert(b.length < 8, 'u64 too large');\n\n    const zeroPad = Buffer.alloc(8);\n    b.copy(zeroPad);\n    return zeroPad;\n  }\n\n  /**\n   * Construct a u64 from Buffer representation\n   */\n  static fromBuffer(buffer: typeof Buffer): u64 {\n    assert(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);\n    return new BN(\n      [...buffer]\n        .reverse()\n        .map(i => `00${i.toString(16)}`.slice(-2))\n        .join(''),\n      16,\n    );\n  }\n}\n\nfunction isAccount(accountOrPublicKey: any): boolean {\n  return 'publicKey' in accountOrPublicKey;\n}\n\ntype AuthorityType =\n  | 'MintTokens'\n  | 'FreezeAccount'\n  | 'AccountOwner'\n  | 'CloseAccount';\n\nconst AuthorityTypeCodes = {\n  MintTokens: 0,\n  FreezeAccount: 1,\n  AccountOwner: 2,\n  CloseAccount: 3,\n};\n\n// The address of the special mint for wrapped native token.\nexport const NATIVE_MINT: PublicKey = new PublicKey(\n  'So11111111111111111111111111111111111111112',\n);\n\n/**\n * Information about the mint\n */\ntype MintInfo = {|\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only be provided during\n   * mint creation. If no mint authority is present then the mint has a fixed supply and no\n   * further tokens may be minted.\n   */\n  mintAuthority: null | PublicKey,\n\n  /**\n   * Total supply of tokens\n   */\n  supply: u64,\n\n  /**\n   * Number of base 10 digits to the right of the decimal place\n   */\n  decimals: number,\n\n  /**\n   * Is this mint initialized\n   */\n  isInitialized: boolean,\n\n  /**\n   * Optional authority to freeze token accounts\n   */\n  freezeAuthority: null | PublicKey,\n|};\n\nexport const MintLayout: typeof BufferLayout.Structure = BufferLayout.struct([\n  BufferLayout.u32('mintAuthorityOption'),\n  Layout.publicKey('mintAuthority'),\n  Layout.uint64('supply'),\n  BufferLayout.u8('decimals'),\n  BufferLayout.u8('isInitialized'),\n  BufferLayout.u32('freezeAuthorityOption'),\n  Layout.publicKey('freezeAuthority'),\n]);\n\n/**\n * Information about an account\n */\ntype AccountInfo = {|\n  /**\n   * The mint associated with this account\n   */\n  mint: PublicKey,\n\n  /**\n   * Owner of this account\n   */\n  owner: PublicKey,\n\n  /**\n   * Amount of tokens this account holds\n   */\n  amount: u64,\n\n  /**\n   * The delegate for this account\n   */\n  delegate: null | PublicKey,\n\n  /**\n   * The amount of tokens the delegate authorized to the delegate\n   */\n  delegatedAmount: u64,\n\n  /**\n   * Is this account initialized\n   */\n  isInitialized: boolean,\n\n  /**\n   * Is this account frozen\n   */\n  isFrozen: boolean,\n\n  /**\n   * Is this a native token account\n   */\n  isNative: boolean,\n\n  /**\n   * If this account is a native token, it must be rent-exempt. This\n   * value logs the rent-exempt reserve which must remain in the balance\n   * until the account is closed.\n   */\n  rentExemptReserve: null | u64,\n\n  /**\n   * Optional authority to close the account\n   */\n  closeAuthority: null | PublicKey,\n|};\n\n/**\n * @private\n */\nexport const AccountLayout: typeof BufferLayout.Structure = BufferLayout.struct(\n  [\n    Layout.publicKey('mint'),\n    Layout.publicKey('owner'),\n    Layout.uint64('amount'),\n    BufferLayout.u32('delegateOption'),\n    Layout.publicKey('delegate'),\n    BufferLayout.u8('state'),\n    BufferLayout.u32('isNativeOption'),\n    Layout.uint64('isNative'),\n    Layout.uint64('delegatedAmount'),\n    BufferLayout.u32('closeAuthorityOption'),\n    Layout.publicKey('closeAuthority'),\n  ],\n);\n\n/**\n * Information about an multisig\n */\ntype MultisigInfo = {|\n  /**\n   * The number of signers required\n   */\n  m: number,\n\n  /**\n   * Number of possible signers, corresponds to the\n   * number of `signers` that are valid.\n   */\n  n: number,\n\n  /**\n   * Is this mint initialized\n   */\n  initialized: boolean,\n\n  /**\n   * The signers\n   */\n  signer1: PublicKey,\n  signer2: PublicKey,\n  signer3: PublicKey,\n  signer4: PublicKey,\n  signer5: PublicKey,\n  signer6: PublicKey,\n  signer7: PublicKey,\n  signer8: PublicKey,\n  signer9: PublicKey,\n  signer10: PublicKey,\n  signer11: PublicKey,\n|};\n\n/**\n * @private\n */\nconst MultisigLayout = BufferLayout.struct([\n  BufferLayout.u8('m'),\n  BufferLayout.u8('n'),\n  BufferLayout.u8('is_initialized'),\n  Layout.publicKey('signer1'),\n  Layout.publicKey('signer2'),\n  Layout.publicKey('signer3'),\n  Layout.publicKey('signer4'),\n  Layout.publicKey('signer5'),\n  Layout.publicKey('signer6'),\n  Layout.publicKey('signer7'),\n  Layout.publicKey('signer8'),\n  Layout.publicKey('signer9'),\n  Layout.publicKey('signer10'),\n  Layout.publicKey('signer11'),\n]);\n\n/**\n * An ERC20-like Token\n */\nexport class Token {\n  /**\n   * @private\n   */\n  connection: Connection;\n\n  /**\n   * The public key identifying this mint\n   */\n  publicKey: PublicKey;\n\n  /**\n   * Program Identifier for the Token program\n   */\n  programId: PublicKey;\n\n  /**\n   * Fee payer\n   */\n  payer: Account;\n\n  /**\n   * Create a Token object attached to the specific mint\n   *\n   * @param connection The connection to use\n   * @param token Public key of the mint\n   * @param programId token programId\n   * @param payer Payer of fees\n   */\n  constructor(\n    connection: Connection,\n    publicKey: PublicKey,\n    programId: PublicKey,\n    payer: Account,\n  ) {\n    Object.assign(this, {connection, publicKey, programId, payer});\n  }\n\n  /**\n   * Get the minimum balance for the mint to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n  static async getMinBalanceRentForExemptMint(\n    connection: Connection,\n  ): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(MintLayout.span);\n  }\n\n  /**\n   * Get the minimum balance for the account to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n  static async getMinBalanceRentForExemptAccount(\n    connection: Connection,\n  ): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(\n      AccountLayout.span,\n    );\n  }\n\n  /**\n   * Get the minimum balance for the multsig to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n  static async getMinBalanceRentForExemptMultisig(\n    connection: Connection,\n  ): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(\n      MultisigLayout.span,\n    );\n  }\n\n  /**\n   * Create and initialize a token.\n   *\n   * @param connection The connection to use\n   * @param payer Fee payer for transaction\n   * @param mintAuthority Account or multisig that will control minting\n   * @param freezeAuthority Optional account or multisig that can freeze token accounts\n   * @param decimals Location of the decimal place\n   * @param programId Optional token programId, uses the system programId by default\n   * @return Token object for the newly minted token\n   */\n  static async createMint(\n    connection: Connection,\n    payer: Account,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey | null,\n    decimals: number,\n    programId: PublicKey,\n  ): Promise<Token> {\n    const mintAccount = new Account();\n    const token = new Token(\n      connection,\n      mintAccount.publicKey,\n      programId,\n      payer,\n    );\n\n    // Allocate memory for the account\n    const balanceNeeded = await Token.getMinBalanceRentForExemptMint(\n      connection,\n    );\n\n    const transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: mintAccount.publicKey,\n        lamports: balanceNeeded,\n        space: MintLayout.span,\n        programId,\n      }),\n    );\n\n    transaction.add(\n      Token.createInitMintInstruction(\n        programId,\n        mintAccount.publicKey,\n        decimals,\n        mintAuthority,\n        freezeAuthority,\n      ),\n    );\n\n    // Send the two instructions\n    await sendAndConfirmTransaction(\n      'createAccount and InitializeMint',\n      connection,\n      transaction,\n      payer,\n      mintAccount,\n    );\n\n    return token;\n  }\n\n  /**\n   * Create and initialize a new account.\n   *\n   * This account may then be used as a `transfer()` or `approve()` destination\n   *\n   * @param owner User account that will own the new account\n   * @return Public key of the new empty account\n   */\n  async createAccount(owner: PublicKey): Promise<PublicKey> {\n    // Allocate memory for the account\n    const balanceNeeded = await Token.getMinBalanceRentForExemptAccount(\n      this.connection,\n    );\n\n    const newAccount = new Account();\n    const transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: this.payer.publicKey,\n        newAccountPubkey: newAccount.publicKey,\n        lamports: balanceNeeded,\n        space: AccountLayout.span,\n        programId: this.programId,\n      }),\n    );\n\n    const mintPublicKey = this.publicKey;\n    transaction.add(\n      Token.createInitAccountInstruction(\n        this.programId,\n        mintPublicKey,\n        newAccount.publicKey,\n        owner,\n      ),\n    );\n\n    // Send the two instructions\n    await sendAndConfirmTransaction(\n      'createAccount and InitializeAccount',\n      this.connection,\n      transaction,\n      this.payer,\n      newAccount,\n    );\n\n    return newAccount.publicKey;\n  }\n\n  /**\n   * Create and initialize a new account on the special native token mint.\n   *\n   * In order to be wrapped, the account must have a balance of native tokens\n   * when it is initialized with the token program.\n   *\n   * This function sends lamports to the new account before initializing it.\n   *\n   * @param connection A solana web3 connection\n   * @param programId The token program ID\n   * @param owner The owner of the new token account\n   * @param payer The source of the lamports to initialize, and payer of the initialization fees.\n   * @param amount The amount of lamports to wrap\n   * @return {Promise<PublicKey>} The new token account\n   */\n  static async createWrappedNativeAccount(\n    connection: Connection,\n    programId: PublicKey,\n    owner: PublicKey,\n    payer: Account,\n    amount: number,\n  ): Promise<PublicKey> {\n    // Allocate memory for the account\n    const balanceNeeded = await Token.getMinBalanceRentForExemptAccount(\n      connection,\n    );\n\n    // Create a new account\n    const newAccount = new Account();\n    const transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: newAccount.publicKey,\n        lamports: balanceNeeded,\n        space: AccountLayout.span,\n        programId,\n      }),\n    );\n\n    // Send lamports to it (these will be wrapped into native tokens by the token program)\n    transaction.add(\n      SystemProgram.transfer({\n        fromPubkey: payer.publicKey,\n        toPubkey: newAccount.publicKey,\n        lamports: amount,\n      }),\n    );\n\n    // Assign the new account to the native token mint.\n    // the account will be initialized with a balance equal to the native token balance.\n    // (i.e. amount)\n    transaction.add(\n      Token.createInitAccountInstruction(\n        programId,\n        NATIVE_MINT,\n        newAccount.publicKey,\n        owner,\n      ),\n    );\n\n    // Send the three instructions\n    await sendAndConfirmTransaction(\n      'createAccount, transfer, and initializeAccount',\n      connection,\n      transaction,\n      payer,\n      newAccount,\n    );\n\n    return newAccount.publicKey;\n  }\n\n  /**\n   * Create and initialize a new multisig.\n   *\n   * This account may then be used for multisignature verification\n   *\n   * @param m Number of required signatures\n   * @param signers Full set of signers\n   * @return Public key of the new multisig account\n   */\n  async createMultisig(\n    m: number,\n    signers: Array<PublicKey>,\n  ): Promise<PublicKey> {\n    const multisigAccount = new Account();\n\n    // Allocate memory for the account\n    const balanceNeeded = await Token.getMinBalanceRentForExemptMultisig(\n      this.connection,\n    );\n    const transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: this.payer.publicKey,\n        newAccountPubkey: multisigAccount.publicKey,\n        lamports: balanceNeeded,\n        space: MultisigLayout.span,\n        programId: this.programId,\n      }),\n    );\n\n    // create the new account\n    let keys = [\n      {pubkey: multisigAccount.publicKey, isSigner: false, isWritable: true},\n      {pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false},\n    ];\n    signers.forEach(signer =>\n      keys.push({pubkey: signer, isSigner: false, isWritable: false}),\n    );\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      BufferLayout.u8('m'),\n    ]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 2, // InitializeMultisig instruction\n        m,\n      },\n      data,\n    );\n    transaction.add({\n      keys,\n      programId: this.programId,\n      data,\n    });\n\n    // Send the two instructions\n    await sendAndConfirmTransaction(\n      'createAccount and InitializeMultisig',\n      this.connection,\n      transaction,\n      this.payer,\n      multisigAccount,\n    );\n\n    return multisigAccount.publicKey;\n  }\n\n  /**\n   * Retrieve mint information\n   */\n  async getMintInfo(): Promise<MintInfo> {\n    const info = await this.connection.getAccountInfo(this.publicKey);\n    if (info === null) {\n      throw new Error('Failed to find mint account');\n    }\n    if (!info.owner.equals(this.programId)) {\n      throw new Error(`Invalid mint owner: ${JSON.stringify(info.owner)}`);\n    }\n    if (info.data.length != MintLayout.span) {\n      throw new Error(`Invalid mint size`);\n    }\n\n    const data = Buffer.from(info.data);\n    const mintInfo = MintLayout.decode(data);\n\n    if (mintInfo.mintAuthorityOption === 0) {\n      mintInfo.mintAuthority = null;\n    } else {\n      mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n    }\n\n    mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n    mintInfo.isInitialized = mintInfo.isInitialized != 0;\n\n    if (mintInfo.freezeAuthorityOption === 0) {\n      mintInfo.freezeAuthority = null;\n    } else {\n      mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n    }\n    return mintInfo;\n  }\n\n  /**\n   * Retrieve account information\n   *\n   * @param account Public key of the account\n   */\n  async getAccountInfo(\n    account: PublicKey,\n    commitment?: Commitment,\n  ): Promise<AccountInfo> {\n    const info = await this.connection.getAccountInfo(account, commitment);\n    if (info === null) {\n      throw new Error('Failed to find account');\n    }\n    if (!info.owner.equals(this.programId)) {\n      throw new Error(`Invalid account owner`);\n    }\n    if (info.data.length != AccountLayout.span) {\n      throw new Error(`Invalid account size`);\n    }\n\n    const data = Buffer.from(info.data);\n    const accountInfo = AccountLayout.decode(data);\n    accountInfo.mint = new PublicKey(accountInfo.mint);\n    accountInfo.owner = new PublicKey(accountInfo.owner);\n    accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n    if (accountInfo.delegateOption === 0) {\n      accountInfo.delegate = null;\n      accountInfo.delegatedAmount = new u64();\n    } else {\n      accountInfo.delegate = new PublicKey(accountInfo.delegate);\n      accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n    }\n\n    accountInfo.isInitialized = accountInfo.state !== 0;\n    accountInfo.isFrozen = accountInfo.state === 2;\n\n    if (accountInfo.isNativeOption === 1) {\n      accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n      accountInfo.isNative = true;\n    } else {\n      accountInfo.rentExemptReserve = null;\n      accountInfo.isNative = false;\n    }\n\n    if (accountInfo.closeAuthorityOption === 0) {\n      accountInfo.closeAuthority = null;\n    } else {\n      accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n    }\n\n    if (!accountInfo.mint.equals(this.publicKey)) {\n      throw new Error(\n        `Invalid account mint: ${JSON.stringify(\n          accountInfo.mint,\n        )} !== ${JSON.stringify(this.publicKey)}`,\n      );\n    }\n    return accountInfo;\n  }\n\n  /**\n   * Retrieve Multisig information\n   *\n   * @param multisig Public key of the account\n   */\n  async getMultisigInfo(multisig: PublicKey): Promise<MultisigInfo> {\n    const info = await this.connection.getAccountInfo(multisig);\n    if (info === null) {\n      throw new Error('Failed to find multisig');\n    }\n    if (!info.owner.equals(this.programId)) {\n      throw new Error(`Invalid multisig owner`);\n    }\n    if (info.data.length != MultisigLayout.span) {\n      throw new Error(`Invalid multisig size`);\n    }\n\n    const data = Buffer.from(info.data);\n    const multisigInfo = MultisigLayout.decode(data);\n    multisigInfo.signer1 = new PublicKey(multisigInfo.signer1);\n    multisigInfo.signer2 = new PublicKey(multisigInfo.signer2);\n    multisigInfo.signer3 = new PublicKey(multisigInfo.signer3);\n    multisigInfo.signer4 = new PublicKey(multisigInfo.signer4);\n    multisigInfo.signer5 = new PublicKey(multisigInfo.signer5);\n    multisigInfo.signer6 = new PublicKey(multisigInfo.signer6);\n    multisigInfo.signer7 = new PublicKey(multisigInfo.signer7);\n    multisigInfo.signer8 = new PublicKey(multisigInfo.signer8);\n    multisigInfo.signer9 = new PublicKey(multisigInfo.signer9);\n    multisigInfo.signer10 = new PublicKey(multisigInfo.signer10);\n    multisigInfo.signer11 = new PublicKey(multisigInfo.signer11);\n\n    return multisigInfo;\n  }\n\n  /**\n   * Transfer tokens to another account\n   *\n   * @param source Source account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Number of tokens to transfer\n   */\n  async transfer(\n    source: PublicKey,\n    destination: PublicKey,\n    owner: any,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n  ): Promise<TransactionSignature> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n    return await sendAndConfirmTransaction(\n      'Transfer',\n      this.connection,\n      new Transaction().add(\n        Token.createTransferInstruction(\n          this.programId,\n          source,\n          destination,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Grant a third-party permission to transfer up the specified number of tokens from an account\n   *\n   * @param account Public key of the account\n   * @param delegate Account authorized to perform a transfer tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   */\n  async approve(\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: any,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n  ): Promise<void> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'Approve',\n      this.connection,\n      new Transaction().add(\n        Token.createApproveInstruction(\n          this.programId,\n          account,\n          delegate,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Remove approval for the transfer of any remaining tokens\n   *\n   * @param account Public key of the account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n  async revoke(\n    account: PublicKey,\n    owner: any,\n    multiSigners: Array<Account>,\n  ): Promise<void> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'Revoke',\n      this.connection,\n      new Transaction().add(\n        Token.createRevokeInstruction(\n          this.programId,\n          account,\n          ownerPublicKey,\n          multiSigners,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Assign a new authority to the account\n   *\n   * @param account Public key of the account\n   * @param newAuthority New authority of the account\n   * @param authorityType Type of authority to set\n   * @param currentAuthority Current authority of the account\n   * @param multiSigners Signing accounts if `currentAuthority` is a multiSig\n   */\n  async setAuthority(\n    account: PublicKey,\n    newAuthority: PublicKey | null,\n    authorityType: AuthorityType,\n    currentAuthority: any,\n    multiSigners: Array<Account>,\n  ): Promise<void> {\n    let currentAuthorityPublicKey: PublicKey;\n    let signers;\n    if (isAccount(currentAuthority)) {\n      currentAuthorityPublicKey = currentAuthority.publicKey;\n      signers = [currentAuthority];\n    } else {\n      currentAuthorityPublicKey = currentAuthority;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'SetAuthority',\n      this.connection,\n      new Transaction().add(\n        Token.createSetAuthorityInstruction(\n          this.programId,\n          account,\n          newAuthority,\n          authorityType,\n          currentAuthorityPublicKey,\n          multiSigners,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Mint new tokens\n   *\n   * @param dest Public key of the account to mint to\n   * @param authority Minting authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   */\n  async mintTo(\n    dest: PublicKey,\n    authority: any,\n    multiSigners: Array<Account>,\n    amount: number,\n  ): Promise<void> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(authority)) {\n      ownerPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      ownerPublicKey = authority;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'MintTo',\n      this.connection,\n      new Transaction().add(\n        Token.createMintToInstruction(\n          this.programId,\n          this.publicKey,\n          dest,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Burn tokens\n   *\n   * @param account Account to burn tokens from\n   * @param owner Account owner\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Amount to burn\n   */\n  async burn(\n    account: PublicKey,\n    owner: any,\n    multiSigners: Array<Account>,\n    amount: number,\n  ): Promise<void> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'Burn',\n      this.connection,\n      new Transaction().add(\n        Token.createBurnInstruction(\n          this.programId,\n          this.publicKey,\n          account,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Close account\n   *\n   * @param account Account to close\n   * @param dest Account to receive the remaining balance of the closed account\n   * @param authority Authority which is allowed to close the account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   */\n  async closeAccount(\n    account: PublicKey,\n    dest: PublicKey,\n    authority: any,\n    multiSigners: Array<Account>,\n  ): Promise<void> {\n    let authorityPublicKey;\n    let signers;\n    if (isAccount(authority)) {\n      authorityPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      authorityPublicKey = authority;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'CloseAccount',\n      this.connection,\n      new Transaction().add(\n        Token.createCloseAccountInstruction(\n          this.programId,\n          account,\n          dest,\n          authorityPublicKey,\n          multiSigners,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Freeze account\n   *\n   * @param account Account to freeze\n   * @param authority The mint freeze authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   */\n  async freezeAccount(\n    account: PublicKey,\n    authority: any,\n    multiSigners: Array<Account>,\n  ): Promise<void> {\n    let authorityPublicKey;\n    let signers;\n    if (isAccount(authority)) {\n      authorityPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      authorityPublicKey = authority;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'FreezeAccount',\n      this.connection,\n      new Transaction().add(\n        Token.createFreezeAccountInstruction(\n          this.programId,\n          account,\n          this.publicKey,\n          authorityPublicKey,\n          multiSigners,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Thaw account\n   *\n   * @param account Account to thaw\n   * @param authority The mint freeze authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   */\n  async thawAccount(\n    account: PublicKey,\n    authority: any,\n    multiSigners: Array<Account>,\n  ): Promise<void> {\n    let authorityPublicKey;\n    let signers;\n    if (isAccount(authority)) {\n      authorityPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      authorityPublicKey = authority;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'ThawAccount',\n      this.connection,\n      new Transaction().add(\n        Token.createThawAccountInstruction(\n          this.programId,\n          account,\n          this.publicKey,\n          authorityPublicKey,\n          multiSigners,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Transfer tokens to another account, asserting the token mint and decimals\n   *\n   * @param source Source account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Number of tokens to transfer\n   * @param decimals Number of decimals in transfer amount\n   */\n  async transfer2(\n    source: PublicKey,\n    destination: PublicKey,\n    owner: any,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n    decimals: number,\n  ): Promise<TransactionSignature> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n    return await sendAndConfirmTransaction(\n      'Transfer2',\n      this.connection,\n      new Transaction().add(\n        Token.createTransfer2Instruction(\n          this.programId,\n          source,\n          this.publicKey,\n          destination,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n          decimals,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Grant a third-party permission to transfer up the specified number of tokens from an account,\n   * asserting the token mint and decimals\n   *\n   * @param account Public key of the account\n   * @param delegate Account authorized to perform a transfer tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   * @param decimals Number of decimals in approve amount\n   */\n  async approve2(\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: any,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n    decimals: number,\n  ): Promise<void> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'Approve2',\n      this.connection,\n      new Transaction().add(\n        Token.createApprove2Instruction(\n          this.programId,\n          account,\n          this.publicKey,\n          delegate,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n          decimals,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Mint new tokens, asserting the token mint and decimals\n   *\n   * @param dest Public key of the account to mint to\n   * @param authority Minting authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   * @param decimals Number of decimals in amount to mint\n   */\n  async mintTo2(\n    dest: PublicKey,\n    authority: any,\n    multiSigners: Array<Account>,\n    amount: number,\n    decimals: number,\n  ): Promise<void> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(authority)) {\n      ownerPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      ownerPublicKey = authority;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'MintTo2',\n      this.connection,\n      new Transaction().add(\n        Token.createMintTo2Instruction(\n          this.programId,\n          this.publicKey,\n          dest,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n          decimals,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Burn tokens, asserting the token mint and decimals\n   *\n   * @param account Account to burn tokens from\n   * @param owner Account owner\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Amount to burn\n   * @param decimals Number of decimals in amount to burn\n   */\n  async burn2(\n    account: PublicKey,\n    owner: any,\n    multiSigners: Array<Account>,\n    amount: number,\n    decimals: number,\n  ): Promise<void> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'Burn2',\n      this.connection,\n      new Transaction().add(\n        Token.createBurn2Instruction(\n          this.programId,\n          this.publicKey,\n          account,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n          decimals,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Construct an InitializeMint instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Token mint account\n   * @param decimals Number of decimals in token account amounts\n   * @param mintAuthority Minting authority\n   * @param freezeAuthority Optional authority that can freeze token accounts\n   */\n  static createInitMintInstruction(\n    programId: PublicKey,\n    mint: PublicKey,\n    decimals: number,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey | null,\n  ): TransactionInstruction {\n    let keys = [\n      {pubkey: mint, isSigner: false, isWritable: true},\n      {pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false},\n    ];\n    const commandDataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      BufferLayout.u8('decimals'),\n      Layout.publicKey('mintAuthority'),\n      BufferLayout.u8('option'),\n      Layout.publicKey('freezeAuthority'),\n    ]);\n    let data = Buffer.alloc(1024);\n    {\n      const encodeLength = commandDataLayout.encode(\n        {\n          instruction: 0, // InitializeMint instruction\n          decimals,\n          mintAuthority: mintAuthority.toBuffer(),\n          option: freezeAuthority === null ? 0 : 1,\n          freezeAuthority: (freezeAuthority || new PublicKey()).toBuffer(),\n        },\n        data,\n      );\n      data = data.slice(0, encodeLength);\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct an InitializeAccount instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Token mint account\n   * @param account New account\n   * @param owner Owner of the new account\n   */\n  static createInitAccountInstruction(\n    programId: PublicKey,\n    mint: PublicKey,\n    account: PublicKey,\n    owner: PublicKey,\n  ): TransactionInstruction {\n    const keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: mint, isSigner: false, isWritable: false},\n      {pubkey: owner, isSigner: false, isWritable: false},\n      {pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false},\n    ];\n    const dataLayout = BufferLayout.struct([BufferLayout.u8('instruction')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 1, // InitializeAccount instruction\n      },\n      data,\n    );\n\n    return new TransactionInstruction({\n      keys,\n      programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Transfer instruction\n   *\n   * @param programId SPL Token program account\n   * @param source Source account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Number of tokens to transfer\n   */\n  static createTransferInstruction(\n    programId: PublicKey,\n    source: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 3, // Transfer instruction\n        amount: new u64(amount).toBuffer(),\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: source, isSigner: false, isWritable: true},\n      {pubkey: destination, isSigner: false, isWritable: true},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false,\n      });\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct an Approve instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param delegate Account authorized to perform a transfer of tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   */\n  static createApproveInstruction(\n    programId: PublicKey,\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 4, // Approve instruction\n        amount: new u64(amount).toBuffer(),\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: delegate, isSigner: false, isWritable: false},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({pubkey: owner, isSigner: true, isWritable: false});\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Revoke instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n  static createRevokeInstruction(\n    programId: PublicKey,\n    account: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([BufferLayout.u8('instruction')]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 5, // Approve instruction\n      },\n      data,\n    );\n\n    let keys = [{pubkey: account, isSigner: false, isWritable: true}];\n    if (multiSigners.length === 0) {\n      keys.push({pubkey: owner, isSigner: true, isWritable: false});\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a SetAuthority instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param newAuthority New authority of the account\n   * @param authorityType Type of authority to set\n   * @param currentAuthority Current authority of the specified type\n   * @param multiSigners Signing accounts if `currentAuthority` is a multiSig\n   */\n  static createSetAuthorityInstruction(\n    programId: PublicKey,\n    account: PublicKey,\n    newAuthority: PublicKey | null,\n    authorityType: AuthorityType,\n    currentAuthority: PublicKey,\n    multiSigners: Array<Account>,\n  ): TransactionInstruction {\n    const commandDataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      BufferLayout.u8('authorityType'),\n      BufferLayout.u8('option'),\n      Layout.publicKey('newAuthority'),\n    ]);\n\n    let data = Buffer.alloc(1024);\n    {\n      const encodeLength = commandDataLayout.encode(\n        {\n          instruction: 6, // SetAuthority instruction\n          authorityType: AuthorityTypeCodes[authorityType],\n          option: newAuthority === null ? 0 : 1,\n          newAuthority: (newAuthority || new PublicKey()).toBuffer(),\n        },\n        data,\n      );\n      data = data.slice(0, encodeLength);\n    }\n\n    let keys = [{pubkey: account, isSigner: false, isWritable: true}];\n    if (multiSigners.length === 0) {\n      keys.push({pubkey: currentAuthority, isSigner: true, isWritable: false});\n    } else {\n      keys.push({pubkey: currentAuthority, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a MintTo instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Public key of the mint\n   * @param dest Public key of the account to mint to\n   * @param authority The mint authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   */\n  static createMintToInstruction(\n    programId: PublicKey,\n    mint: PublicKey,\n    dest: PublicKey,\n    authority: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 7, // MintTo instruction\n        amount: new u64(amount).toBuffer(),\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: mint, isSigner: false, isWritable: true},\n      {pubkey: dest, isSigner: false, isWritable: true},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: authority,\n        isSigner: true,\n        isWritable: false,\n      });\n    } else {\n      keys.push({pubkey: authority, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Burn instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Mint for the account\n   * @param account Account to burn tokens from\n   * @param owner Owner of the account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount amount to burn\n   */\n  static createBurnInstruction(\n    programId: PublicKey,\n    mint: PublicKey,\n    account: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 8, // Burn instruction\n        amount: new u64(amount).toBuffer(),\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: mint, isSigner: false, isWritable: true},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false,\n      });\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Close instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Account to close\n   * @param dest Account to receive the remaining balance of the closed account\n   * @param authority Account Close authority\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n  static createCloseAccountInstruction(\n    programId: PublicKey,\n    account: PublicKey,\n    dest: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([BufferLayout.u8('instruction')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 9, // CloseAccount instruction\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: dest, isSigner: false, isWritable: true},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({pubkey: owner, isSigner: true, isWritable: false});\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Freeze instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Account to freeze\n   * @param mint Mint account\n   * @param authority Mint freeze authority\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n  static createFreezeAccountInstruction(\n    programId: PublicKey,\n    account: PublicKey,\n    mint: PublicKey,\n    authority: PublicKey,\n    multiSigners: Array<Account>,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([BufferLayout.u8('instruction')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 10, // FreezeAccount instruction\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: mint, isSigner: false, isWritable: false},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({pubkey: authority, isSigner: true, isWritable: false});\n    } else {\n      keys.push({pubkey: authority, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Thaw instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Account to thaw\n   * @param mint Mint account\n   * @param authority Mint freeze authority\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n  static createThawAccountInstruction(\n    programId: PublicKey,\n    account: PublicKey,\n    mint: PublicKey,\n    authority: PublicKey,\n    multiSigners: Array<Account>,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([BufferLayout.u8('instruction')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 11, // ThawAccount instruction\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: mint, isSigner: false, isWritable: false},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({pubkey: authority, isSigner: true, isWritable: false});\n    } else {\n      keys.push({pubkey: authority, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Transfer2 instruction\n   *\n   * @param programId SPL Token program account\n   * @param source Source account\n   * @param mint Mint account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Number of tokens to transfer\n   * @param decimals Number of decimals in transfer amount\n   */\n  static createTransfer2Instruction(\n    programId: PublicKey,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n    decimals: number,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n      BufferLayout.u8('decimals'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 12, // Transfer2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals,\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: source, isSigner: false, isWritable: true},\n      {pubkey: mint, isSigner: false, isWritable: false},\n      {pubkey: destination, isSigner: false, isWritable: true},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false,\n      });\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct an Approve2 instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param mint Mint account\n   * @param delegate Account authorized to perform a transfer of tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   * @param decimals Number of decimals in approve amount\n   */\n  static createApprove2Instruction(\n    programId: PublicKey,\n    account: PublicKey,\n    mint: PublicKey,\n    delegate: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n    decimals: number,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n      BufferLayout.u8('decimals'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 13, // Approve2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals,\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: mint, isSigner: false, isWritable: false},\n      {pubkey: delegate, isSigner: false, isWritable: false},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({pubkey: owner, isSigner: true, isWritable: false});\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a MintTo2 instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Public key of the mint\n   * @param dest Public key of the account to mint to\n   * @param authority The mint authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   * @param decimals Number of decimals in amount to mint\n   */\n  static createMintTo2Instruction(\n    programId: PublicKey,\n    mint: PublicKey,\n    dest: PublicKey,\n    authority: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number,\n    decimals: number,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n      BufferLayout.u8('decimals'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 14, // MintTo2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals,\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: mint, isSigner: false, isWritable: true},\n      {pubkey: dest, isSigner: false, isWritable: true},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: authority,\n        isSigner: true,\n        isWritable: false,\n      });\n    } else {\n      keys.push({pubkey: authority, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Burn2 instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Mint for the account\n   * @param account Account to burn tokens from\n   * @param owner Owner of the account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount amount to burn\n   */\n  static createBurn2Instruction(\n    programId: PublicKey,\n    mint: PublicKey,\n    account: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number,\n    decimals: number,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n      BufferLayout.u8('decimals'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 15, // Burn2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals,\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: mint, isSigner: false, isWritable: true},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false,\n      });\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}