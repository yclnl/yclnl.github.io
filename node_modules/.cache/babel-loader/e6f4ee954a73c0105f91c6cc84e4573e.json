{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport assert from 'assert';\nimport BN from 'bn.js';\nimport { blob, struct, u8, nu64 } from 'buffer-layout';\nimport { sendAndConfirmTransaction as sendAndConfirmTransaction$1, TransactionInstruction, Transaction, SystemProgram, PublicKey } from '@solana/web3.js';\n/**\n * Layout for a public key\n */\n\nconst publicKey = (property = 'publicKey') => {\n  return blob(32, property);\n};\n/**\n * Layout for a 64bit unsigned value\n */\n\n\nconst uint64 = (property = 'uint64') => {\n  return blob(8, property);\n};\n\nfunction sendAndConfirmTransaction(title, connection, transaction, ...signers) {\n  return sendAndConfirmTransaction$1(connection, transaction, signers, {\n    skipPreflight: false,\n    commitment: 'recent',\n    preflightCommitment: 'recent'\n  });\n}\n/**\n * Some amount of tokens\n */\n\n\nclass Numberu64 extends BN {\n  /**\n   * Convert to Buffer representation\n   */\n  toBuffer() {\n    const a = super.toArray().reverse();\n    const b = Buffer.from(a);\n\n    if (b.length === 8) {\n      return b;\n    }\n\n    assert(b.length < 8, 'Numberu64 too large');\n    const zeroPad = Buffer.alloc(8);\n    b.copy(zeroPad);\n    return zeroPad;\n  }\n  /**\n   * Construct a Numberu64 from Buffer representation\n   */\n\n\n  static fromBuffer(buffer) {\n    assert(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);\n    return new BN([...buffer].reverse().map(i => `00${i.toString(16)}`.slice(-2)).join(''), 16);\n  }\n\n}\n/**\n * Information about a token swap\n */\n\n/**\n * @private\n */\n\n\nconst TokenSwapLayout = struct([u8('isInitialized'), u8('nonce'), publicKey('tokenAccountA'), publicKey('tokenAccountB'), publicKey('tokenPool'), uint64('feesNumerator'), uint64('feesDenominator')]);\n/**\n * An ERC20-like Token\n */\n\nclass TokenSwap {\n  /**\n   * @private\n   */\n\n  /**\n   * The public key identifying this token\n   */\n\n  /**\n   * Program Identifier for the Token Swap program\n   */\n\n  /**\n   * Fee payer\n   */\n\n  /**\n   * Create a Token object attached to the specific token\n   *\n   * @param connection The connection to use\n   * @param token Public key of the token\n   * @param programId Optional token programId, uses the system programId by default\n   * @param payer Payer of fees\n   */\n  constructor(connection, tokenSwap, programId, payer) {\n    _defineProperty(this, \"connection\", void 0);\n\n    _defineProperty(this, \"tokenSwap\", void 0);\n\n    _defineProperty(this, \"programId\", void 0);\n\n    _defineProperty(this, \"payer\", void 0);\n\n    Object.assign(this, {\n      connection,\n      tokenSwap,\n      programId,\n      payer\n    });\n  }\n  /**\n   * Get the minimum balance for the token swap account to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n\n\n  static async getMinBalanceRentForExemptTokenSwap(connection) {\n    return await connection.getMinimumBalanceForRentExemption(TokenSwapLayout.span);\n  }\n\n  static createInitSwapInstruction(tokenSwapAccount, authority, nonce, tokenAccountA, tokenAccountB, tokenPool, tokenAccountPool, tokenProgramId, swapProgramId, feeNumerator, feeDenominator) {\n    const keys = [{\n      pubkey: tokenSwapAccount.publicKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: authority,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: tokenAccountA,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: tokenAccountB,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: tokenPool,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: tokenAccountPool,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: tokenProgramId,\n      isSigner: false,\n      isWritable: false\n    }];\n    const commandDataLayout = struct([u8('instruction'), nu64('feeNumerator'), nu64('feeDenominator'), u8('nonce')]);\n    let data = Buffer.alloc(1024);\n    {\n      const encodeLength = commandDataLayout.encode({\n        instruction: 0,\n        // InitializeSwap instruction\n        feeNumerator,\n        feeDenominator,\n        nonce\n      }, data);\n      data = data.slice(0, encodeLength);\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: swapProgramId,\n      data\n    });\n  }\n  /**\n   * Create a new Token Swap\n   *\n   * @param connection The connection to use\n   * @param payer Pays for the transaction\n   * @param tokenSwapAccount The token swap account\n   * @param authority The authority over the swap and accounts\n   * @param tokenAccountA: The Swap's Token A account\n   * @param tokenAccountB: The Swap's Token B account\n   * @param tokenPool The pool token\n   * @param tokenAccountPool The pool token account\n   * @param tokenProgramId The program id of the token program\n   * @param feeNumerator Numerator of the fee ratio\n   * @param feeDenominator Denominator of the fee ratio\n   * @param swapProgramId Program ID of the token-swap program\n   * @return Token object for the newly minted token, Public key of the account holding the total supply of new tokens\n   */\n\n\n  static async createTokenSwap(connection, payer, tokenSwapAccount, authority, tokenAccountA, tokenAccountB, tokenPool, tokenAccountPool, tokenProgramId, nonce, feeNumerator, feeDenominator, swapProgramId) {\n    let transaction;\n    const tokenSwap = new TokenSwap(connection, tokenSwapAccount.publicKey, swapProgramId, payer); // Allocate memory for the account\n\n    const balanceNeeded = await TokenSwap.getMinBalanceRentForExemptTokenSwap(connection);\n    transaction = new Transaction();\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: payer.publicKey,\n      newAccountPubkey: tokenSwapAccount.publicKey,\n      lamports: balanceNeeded,\n      space: TokenSwapLayout.span,\n      programId: swapProgramId\n    }));\n    const instruction = TokenSwap.createInitSwapInstruction(tokenSwapAccount, authority, nonce, tokenAccountA, tokenAccountB, tokenPool, tokenAccountPool, tokenProgramId, swapProgramId, feeNumerator, feeDenominator);\n    transaction.add(instruction);\n    await sendAndConfirmTransaction('createAccount and InitializeSwap', connection, transaction, payer, tokenSwapAccount);\n    return tokenSwap;\n  }\n  /**\n   * Retrieve tokenSwap information\n   */\n\n\n  async getInfo() {\n    const accountInfo = await this.connection.getAccountInfo(this.tokenSwap);\n\n    if (accountInfo === null) {\n      throw new Error('Failed to find token swap account');\n    }\n\n    if (!accountInfo.owner.equals(this.programId)) {\n      throw new Error(`Invalid token swap owner: ${JSON.stringify(accountInfo.owner)}`);\n    }\n\n    const data = Buffer.from(accountInfo.data);\n    const tokenSwapInfo = TokenSwapLayout.decode(data);\n\n    if (!tokenSwapInfo.isInitialized) {\n      throw new Error(`Invalid token swap state`);\n    } // already properly filled in\n    // tokenSwapInfo.nonce = tokenSwapInfo.nonce;\n\n\n    tokenSwapInfo.tokenAccountA = new PublicKey(tokenSwapInfo.tokenAccountA);\n    tokenSwapInfo.tokenAccountB = new PublicKey(tokenSwapInfo.tokenAccountB);\n    tokenSwapInfo.tokenPool = new PublicKey(tokenSwapInfo.tokenPool);\n    tokenSwapInfo.feesNumerator = Numberu64.fromBuffer(tokenSwapInfo.feesNumerator);\n    tokenSwapInfo.feesDenominator = Numberu64.fromBuffer(tokenSwapInfo.feesDenominator);\n    tokenSwapInfo.feeRatio = tokenSwapInfo.feesNumerator.toNumber() / tokenSwapInfo.feesDenominator.toNumber();\n    return tokenSwapInfo;\n  }\n  /**\n   * Swap the tokens in the pool\n   *\n   * @param authority Authority\n   * @param source Source account\n   * @param swapSource Base account to swap into, must be a source token\n   * @param swapDestination Base account to swap from, must be a destination token\n   * @param destination Destination token account\n   * @param tokenProgramId Token program id\n   * @param amount Amount to transfer from source account\n   */\n\n\n  async swap(authority, source, swapSource, swapDestination, destination, tokenProgramId, amountIn, minimumAmountOut) {\n    return await sendAndConfirmTransaction('swap', this.connection, new Transaction().add(TokenSwap.swapInstruction(this.tokenSwap, authority, source, swapSource, swapDestination, destination, this.programId, tokenProgramId, amountIn, minimumAmountOut)), this.payer);\n  }\n\n  static swapInstruction(tokenSwap, authority, source, swapSource, swapDestination, destination, swapProgramId, tokenProgramId, amountIn, minimumAmountOut) {\n    const dataLayout = struct([u8('instruction'), uint64('amountIn'), uint64('minimumAmountOut')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 1,\n      // Swap instruction\n      amountIn: new Numberu64(amountIn).toBuffer(),\n      minimumAmountOut: new Numberu64(minimumAmountOut).toBuffer()\n    }, data);\n    const keys = [{\n      pubkey: tokenSwap,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: authority,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: source,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: swapSource,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: swapDestination,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: destination,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: tokenProgramId,\n      isSigner: false,\n      isWritable: false\n    }];\n    return new TransactionInstruction({\n      keys,\n      programId: swapProgramId,\n      data\n    });\n  }\n  /**\n   * Deposit some tokens into the pool\n   *\n   * @param authority Authority\n   * @param sourceA Source account A\n   * @param sourceB Source account B\n   * @param intoA Base account A to deposit into\n   * @param intoB Base account B to deposit into\n   * @param poolToken Pool token\n   * @param poolAccount Pool account to deposit the generated tokens\n   * @param tokenProgramId Token program id\n   * @param amount Amount of pool token to deposit, token A and B amount are set by the exchange rate relative to the total pool token supply\n   */\n\n\n  async deposit(authority, sourceA, sourceB, intoA, intoB, poolToken, poolAccount, tokenProgramId, poolTokenAmount, maximumTokenA, maximumTokenB) {\n    return await sendAndConfirmTransaction('deposit', this.connection, new Transaction().add(TokenSwap.depositInstruction(this.tokenSwap, authority, sourceA, sourceB, intoA, intoB, poolToken, poolAccount, this.programId, tokenProgramId, poolTokenAmount, maximumTokenA, maximumTokenB)), this.payer);\n  }\n\n  static depositInstruction(tokenSwap, authority, sourceA, sourceB, intoA, intoB, poolToken, poolAccount, swapProgramId, tokenProgramId, poolTokenAmount, maximumTokenA, maximumTokenB) {\n    const dataLayout = struct([u8('instruction'), uint64('poolTokenAmount'), uint64('maximumTokenA'), uint64('maximumTokenB')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 2,\n      // Deposit instruction\n      poolTokenAmount: new Numberu64(poolTokenAmount).toBuffer(),\n      maximumTokenA: new Numberu64(maximumTokenA).toBuffer(),\n      maximumTokenB: new Numberu64(maximumTokenB).toBuffer()\n    }, data);\n    const keys = [{\n      pubkey: tokenSwap,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: authority,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: sourceA,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: sourceB,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: intoA,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: intoB,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: poolToken,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: poolAccount,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: tokenProgramId,\n      isSigner: false,\n      isWritable: false\n    }];\n    return new TransactionInstruction({\n      keys,\n      programId: swapProgramId,\n      data\n    });\n  }\n  /**\n   * Withdraw the token from the pool at the current ratio\n   *\n   * @param authority Authority\n   * @param sourcePoolAccount Source pool account\n   * @param poolToken Pool token\n   * @param fromA Base account A to withdraw from\n   * @param fromB Base account B to withdraw from\n   * @param userAccountA Token A user account\n   * @param userAccountB token B user account\n   * @param tokenProgramId Token program id\n   * @param amount Amount of pool token to withdraw, token A and B amount are set by the exchange rate relative to the total pool token supply\n   */\n\n\n  async withdraw(authority, poolMint, sourcePoolAccount, fromA, fromB, userAccountA, userAccountB, tokenProgramId, poolTokenAmount, minimumTokenA, minimumTokenB) {\n    return await sendAndConfirmTransaction('withdraw', this.connection, new Transaction().add(TokenSwap.withdrawInstruction(this.tokenSwap, authority, poolMint, sourcePoolAccount, fromA, fromB, userAccountA, userAccountB, this.programId, tokenProgramId, poolTokenAmount, minimumTokenA, minimumTokenB)), this.payer);\n  }\n\n  static withdrawInstruction(tokenSwap, authority, poolMint, sourcePoolAccount, fromA, fromB, userAccountA, userAccountB, swapProgramId, tokenProgramId, poolTokenAmount, minimumTokenA, minimumTokenB) {\n    const dataLayout = struct([u8('instruction'), uint64('poolTokenAmount'), uint64('minimumTokenA'), uint64('minimumTokenB')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 3,\n      // Withdraw instruction\n      poolTokenAmount: new Numberu64(poolTokenAmount).toBuffer(),\n      minimumTokenA: new Numberu64(minimumTokenA).toBuffer(),\n      minimumTokenB: new Numberu64(minimumTokenB).toBuffer()\n    }, data);\n    const keys = [{\n      pubkey: tokenSwap,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: authority,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: poolMint,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: sourcePoolAccount,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: fromA,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: fromB,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: userAccountA,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: userAccountB,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: tokenProgramId,\n      isSigner: false,\n      isWritable: false\n    }];\n    return new TransactionInstruction({\n      keys,\n      programId: swapProgramId,\n      data\n    });\n  }\n\n}\n\nexport { Numberu64, TokenSwap, TokenSwapLayout };","map":{"version":3,"sources":["../client/layout.js","../client/util/send-and-confirm-transaction.js","../client/token-swap.js"],"names":["publicKey","property","BufferLayout","uint64","realSendAndConfirmTransaction","skipPreflight","commitment","preflightCommitment","toBuffer","a","b","Buffer","assert","zeroPad","buffer","length","i","TokenSwapLayout","Layout","constructor","Object","payer","connection","keys","pubkey","tokenSwapAccount","isSigner","isWritable","commandDataLayout","data","encodeLength","instruction","nonce","programId","tokenSwap","balanceNeeded","TokenSwap","transaction","fromPubkey","newAccountPubkey","lamports","space","swapProgramId","sendAndConfirmTransaction","accountInfo","JSON","tokenSwapInfo","Numberu64","dataLayout","amountIn","minimumAmountOut","poolTokenAmount","maximumTokenA","maximumTokenB","minimumTokenA","minimumTokenB"],"mappings":"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","sourcesContent":["// @flow\n\nimport * as BufferLayout from 'buffer-layout';\n\n/**\n * Layout for a public key\n */\nexport const publicKey = (property: string = 'publicKey'): Object => {\n  return BufferLayout.blob(32, property);\n};\n\n/**\n * Layout for a 64bit unsigned value\n */\nexport const uint64 = (property: string = 'uint64'): Object => {\n  return BufferLayout.blob(8, property);\n};\n\n/**\n * Layout for a Rust String type\n */\nexport const rustString = (property: string = 'string'): Object => {\n  const rsl = BufferLayout.struct(\n    [\n      BufferLayout.u32('length'),\n      BufferLayout.u32('lengthPadding'),\n      BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), 'chars'),\n    ],\n    property,\n  );\n  const _decode = rsl.decode.bind(rsl);\n  const _encode = rsl.encode.bind(rsl);\n\n  rsl.decode = (buffer, offset) => {\n    const data = _decode(buffer, offset);\n    return data.chars.toString('utf8');\n  };\n\n  rsl.encode = (str, buffer, offset) => {\n    const data = {\n      chars: Buffer.from(str, 'utf8'),\n    };\n    return _encode(data, buffer, offset);\n  };\n\n  return rsl;\n};\n","// @flow\n\nimport {sendAndConfirmTransaction as realSendAndConfirmTransaction} from '@solana/web3.js';\nimport type {\n  Account,\n  Connection,\n  Transaction,\n  TransactionSignature,\n} from '@solana/web3.js';\n\nexport function sendAndConfirmTransaction(\n  title: string,\n  connection: Connection,\n  transaction: Transaction,\n  ...signers: Array<Account>\n): Promise<TransactionSignature> {\n  return realSendAndConfirmTransaction(connection, transaction, signers, {\n    skipPreflight: false,\n    commitment: 'recent',\n    preflightCommitment: 'recent',\n  });\n}\n","/**\n * @flow\n */\n\nimport assert from 'assert';\nimport BN from 'bn.js';\nimport * as BufferLayout from 'buffer-layout';\nimport type {Connection, TransactionSignature} from '@solana/web3.js';\nimport {\n  Account,\n  PublicKey,\n  SystemProgram,\n  Transaction,\n  TransactionInstruction,\n} from '@solana/web3.js';\n\nimport * as Layout from './layout';\nimport {sendAndConfirmTransaction} from './util/send-and-confirm-transaction';\n\n/**\n * Some amount of tokens\n */\nexport class Numberu64 extends BN {\n  /**\n   * Convert to Buffer representation\n   */\n  toBuffer(): typeof Buffer {\n    const a = super.toArray().reverse();\n    const b = Buffer.from(a);\n    if (b.length === 8) {\n      return b;\n    }\n    assert(b.length < 8, 'Numberu64 too large');\n\n    const zeroPad = Buffer.alloc(8);\n    b.copy(zeroPad);\n    return zeroPad;\n  }\n\n  /**\n   * Construct a Numberu64 from Buffer representation\n   */\n  static fromBuffer(buffer: typeof Buffer): Numberu64 {\n    assert(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);\n    return new BN(\n      [...buffer]\n        .reverse()\n        .map(i => `00${i.toString(16)}`.slice(-2))\n        .join(''),\n      16,\n    );\n  }\n}\n\n/**\n * Information about a token swap\n */\ntype TokenSwapInfo = {|\n  /**\n   * Nonce. Used to generate the valid program address in the program\n   */\n  nonce: number,\n\n  /**\n   * Token A. The Liquidity token is issued against this value.\n   */\n  tokenAccountA: PublicKey,\n\n  /**\n   * Token B\n   */\n  tokenAccountB: PublicKey,\n  /**\n   * Pool tokens are issued when A or B tokens are deposited\n   * Pool tokens can be withdrawn back to the original A or B token\n   */\n  tokenPool: PublicKey,\n\n  /**\n   * Fee numerator\n   */\n  feesNumerator: Numberu64,\n\n  /**\n   * Fee denominator\n   */\n  feesDenominator: Numberu64,\n\n  /**\n   * Fee ratio applied to the input token amount prior to output calculation\n   */\n  feeRatio: number,\n|};\n\n/**\n * @private\n */\nexport const TokenSwapLayout: typeof BufferLayout.Structure = BufferLayout.struct(\n  [\n    BufferLayout.u8('isInitialized'),\n    BufferLayout.u8('nonce'),\n    Layout.publicKey('tokenAccountA'),\n    Layout.publicKey('tokenAccountB'),\n    Layout.publicKey('tokenPool'),\n    Layout.uint64('feesNumerator'),\n    Layout.uint64('feesDenominator'),\n  ],\n);\n\n/**\n * An ERC20-like Token\n */\nexport class TokenSwap {\n  /**\n   * @private\n   */\n  connection: Connection;\n\n  /**\n   * The public key identifying this token\n   */\n  tokenSwap: PublicKey;\n\n  /**\n   * Program Identifier for the Token Swap program\n   */\n  programId: PublicKey;\n\n  /**\n   * Fee payer\n   */\n  payer: Account;\n\n  /**\n   * Create a Token object attached to the specific token\n   *\n   * @param connection The connection to use\n   * @param token Public key of the token\n   * @param programId Optional token programId, uses the system programId by default\n   * @param payer Payer of fees\n   */\n  constructor(\n    connection: Connection,\n    tokenSwap: PublicKey,\n    programId: PublicKey,\n    payer: Account,\n  ) {\n    Object.assign(this, {connection, tokenSwap, programId, payer});\n  }\n\n  /**\n   * Get the minimum balance for the token swap account to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n  static async getMinBalanceRentForExemptTokenSwap(\n    connection: Connection,\n  ): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(\n      TokenSwapLayout.span,\n    );\n  }\n\n  static createInitSwapInstruction(\n    tokenSwapAccount: Account,\n    authority: PublicKey,\n    nonce: number,\n    tokenAccountA: PublicKey,\n    tokenAccountB: PublicKey,\n    tokenPool: PublicKey,\n    tokenAccountPool: PublicKey,\n    tokenProgramId: PublicKey,\n    swapProgramId: PublicKey,\n    feeNumerator: number,\n    feeDenominator: number,\n  ): TransactionInstruction {\n    const keys = [\n      {pubkey: tokenSwapAccount.publicKey, isSigner: false, isWritable: true},\n      {pubkey: authority, isSigner: false, isWritable: false},\n      {pubkey: tokenAccountA, isSigner: false, isWritable: false},\n      {pubkey: tokenAccountB, isSigner: false, isWritable: false},\n      {pubkey: tokenPool, isSigner: false, isWritable: true},\n      {pubkey: tokenAccountPool, isSigner: false, isWritable: true},\n      {pubkey: tokenProgramId, isSigner: false, isWritable: false},\n    ];\n    const commandDataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      BufferLayout.nu64('feeNumerator'),\n      BufferLayout.nu64('feeDenominator'),\n      BufferLayout.u8('nonce'),\n    ]);\n    let data = Buffer.alloc(1024);\n    {\n      const encodeLength = commandDataLayout.encode(\n        {\n          instruction: 0, // InitializeSwap instruction\n          feeNumerator,\n          feeDenominator,\n          nonce,\n        },\n        data,\n      );\n      data = data.slice(0, encodeLength);\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: swapProgramId,\n      data,\n    });\n  }\n\n  /**\n   * Create a new Token Swap\n   *\n   * @param connection The connection to use\n   * @param payer Pays for the transaction\n   * @param tokenSwapAccount The token swap account\n   * @param authority The authority over the swap and accounts\n   * @param tokenAccountA: The Swap's Token A account\n   * @param tokenAccountB: The Swap's Token B account\n   * @param tokenPool The pool token\n   * @param tokenAccountPool The pool token account\n   * @param tokenProgramId The program id of the token program\n   * @param feeNumerator Numerator of the fee ratio\n   * @param feeDenominator Denominator of the fee ratio\n   * @param swapProgramId Program ID of the token-swap program\n   * @return Token object for the newly minted token, Public key of the account holding the total supply of new tokens\n   */\n  static async createTokenSwap(\n    connection: Connection,\n    payer: Account,\n    tokenSwapAccount: Account,\n    authority: PublicKey,\n    tokenAccountA: PublicKey,\n    tokenAccountB: PublicKey,\n    tokenPool: PublicKey,\n    tokenAccountPool: PublicKey,\n    tokenProgramId: PublicKey,\n    nonce: number,\n    feeNumerator: number,\n    feeDenominator: number,\n    swapProgramId: PublicKey,\n  ): Promise<TokenSwap> {\n    let transaction;\n    const tokenSwap = new TokenSwap(\n      connection,\n      tokenSwapAccount.publicKey,\n      swapProgramId,\n      payer,\n    );\n\n    // Allocate memory for the account\n    const balanceNeeded = await TokenSwap.getMinBalanceRentForExemptTokenSwap(\n      connection,\n    );\n    transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: tokenSwapAccount.publicKey,\n        lamports: balanceNeeded,\n        space: TokenSwapLayout.span,\n        programId: swapProgramId,\n      }),\n    );\n\n    const instruction = TokenSwap.createInitSwapInstruction(\n      tokenSwapAccount,\n      authority,\n      nonce,\n      tokenAccountA,\n      tokenAccountB,\n      tokenPool,\n      tokenAccountPool,\n      tokenProgramId,\n      swapProgramId,\n      feeNumerator,\n      feeDenominator,\n    );\n\n    transaction.add(instruction);\n    await sendAndConfirmTransaction(\n      'createAccount and InitializeSwap',\n      connection,\n      transaction,\n      payer,\n      tokenSwapAccount,\n    );\n\n    return tokenSwap;\n  }\n\n  /**\n   * Retrieve tokenSwap information\n   */\n  async getInfo(): Promise<TokenSwapInfo> {\n    const accountInfo = await this.connection.getAccountInfo(this.tokenSwap);\n    if (accountInfo === null) {\n      throw new Error('Failed to find token swap account');\n    }\n    if (!accountInfo.owner.equals(this.programId)) {\n      throw new Error(\n        `Invalid token swap owner: ${JSON.stringify(accountInfo.owner)}`,\n      );\n    }\n\n    const data = Buffer.from(accountInfo.data);\n    const tokenSwapInfo = TokenSwapLayout.decode(data);\n    if (!tokenSwapInfo.isInitialized) {\n      throw new Error(`Invalid token swap state`);\n    }\n    // already properly filled in\n    // tokenSwapInfo.nonce = tokenSwapInfo.nonce;\n    tokenSwapInfo.tokenAccountA = new PublicKey(tokenSwapInfo.tokenAccountA);\n    tokenSwapInfo.tokenAccountB = new PublicKey(tokenSwapInfo.tokenAccountB);\n    tokenSwapInfo.tokenPool = new PublicKey(tokenSwapInfo.tokenPool);\n    tokenSwapInfo.feesNumerator = Numberu64.fromBuffer(\n      tokenSwapInfo.feesNumerator,\n    );\n    tokenSwapInfo.feesDenominator = Numberu64.fromBuffer(\n      tokenSwapInfo.feesDenominator,\n    );\n    tokenSwapInfo.feeRatio =\n      tokenSwapInfo.feesNumerator.toNumber() /\n      tokenSwapInfo.feesDenominator.toNumber();\n\n    return tokenSwapInfo;\n  }\n\n  /**\n   * Swap the tokens in the pool\n   *\n   * @param authority Authority\n   * @param source Source account\n   * @param swapSource Base account to swap into, must be a source token\n   * @param swapDestination Base account to swap from, must be a destination token\n   * @param destination Destination token account\n   * @param tokenProgramId Token program id\n   * @param amount Amount to transfer from source account\n   */\n  async swap(\n    authority: PublicKey,\n    source: PublicKey,\n    swapSource: PublicKey,\n    swapDestination: PublicKey,\n    destination: PublicKey,\n    tokenProgramId: PublicKey,\n    amountIn: number | Numberu64,\n    minimumAmountOut: number | Numberu64,\n  ): Promise<TransactionSignature> {\n    return await sendAndConfirmTransaction(\n      'swap',\n      this.connection,\n      new Transaction().add(\n        TokenSwap.swapInstruction(\n          this.tokenSwap,\n          authority,\n          source,\n          swapSource,\n          swapDestination,\n          destination,\n          this.programId,\n          tokenProgramId,\n          amountIn,\n          minimumAmountOut,\n        ),\n      ),\n      this.payer,\n    );\n  }\n\n  static swapInstruction(\n    tokenSwap: PublicKey,\n    authority: PublicKey,\n    source: PublicKey,\n    swapSource: PublicKey,\n    swapDestination: PublicKey,\n    destination: PublicKey,\n    swapProgramId: PublicKey,\n    tokenProgramId: PublicKey,\n    amountIn: number | Numberu64,\n    minimumAmountOut: number | Numberu64,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amountIn'),\n      Layout.uint64('minimumAmountOut'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 1, // Swap instruction\n        amountIn: new Numberu64(amountIn).toBuffer(),\n        minimumAmountOut: new Numberu64(minimumAmountOut).toBuffer(),\n      },\n      data,\n    );\n\n    const keys = [\n      {pubkey: tokenSwap, isSigner: false, isWritable: false},\n      {pubkey: authority, isSigner: false, isWritable: false},\n      {pubkey: source, isSigner: false, isWritable: true},\n      {pubkey: swapSource, isSigner: false, isWritable: true},\n      {pubkey: swapDestination, isSigner: false, isWritable: true},\n      {pubkey: destination, isSigner: false, isWritable: true},\n      {pubkey: tokenProgramId, isSigner: false, isWritable: false},\n    ];\n    return new TransactionInstruction({\n      keys,\n      programId: swapProgramId,\n      data,\n    });\n  }\n\n  /**\n   * Deposit some tokens into the pool\n   *\n   * @param authority Authority\n   * @param sourceA Source account A\n   * @param sourceB Source account B\n   * @param intoA Base account A to deposit into\n   * @param intoB Base account B to deposit into\n   * @param poolToken Pool token\n   * @param poolAccount Pool account to deposit the generated tokens\n   * @param tokenProgramId Token program id\n   * @param amount Amount of pool token to deposit, token A and B amount are set by the exchange rate relative to the total pool token supply\n   */\n  async deposit(\n    authority: PublicKey,\n    sourceA: PublicKey,\n    sourceB: PublicKey,\n    intoA: PublicKey,\n    intoB: PublicKey,\n    poolToken: PublicKey,\n    poolAccount: PublicKey,\n    tokenProgramId: PublicKey,\n    poolTokenAmount: number | Numberu64,\n    maximumTokenA: number | Numberu64,\n    maximumTokenB: number | Numberu64,\n  ): Promise<TransactionSignature> {\n    return await sendAndConfirmTransaction(\n      'deposit',\n      this.connection,\n      new Transaction().add(\n        TokenSwap.depositInstruction(\n          this.tokenSwap,\n          authority,\n          sourceA,\n          sourceB,\n          intoA,\n          intoB,\n          poolToken,\n          poolAccount,\n          this.programId,\n          tokenProgramId,\n          poolTokenAmount,\n          maximumTokenA,\n          maximumTokenB,\n        ),\n      ),\n      this.payer,\n    );\n  }\n\n  static depositInstruction(\n    tokenSwap: PublicKey,\n    authority: PublicKey,\n    sourceA: PublicKey,\n    sourceB: PublicKey,\n    intoA: PublicKey,\n    intoB: PublicKey,\n    poolToken: PublicKey,\n    poolAccount: PublicKey,\n    swapProgramId: PublicKey,\n    tokenProgramId: PublicKey,\n    poolTokenAmount: number | Numberu64,\n    maximumTokenA: number | Numberu64,\n    maximumTokenB: number | Numberu64,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('poolTokenAmount'),\n      Layout.uint64('maximumTokenA'),\n      Layout.uint64('maximumTokenB'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 2, // Deposit instruction\n        poolTokenAmount: new Numberu64(poolTokenAmount).toBuffer(),\n        maximumTokenA: new Numberu64(maximumTokenA).toBuffer(),\n        maximumTokenB: new Numberu64(maximumTokenB).toBuffer(),\n      },\n      data,\n    );\n\n    const keys = [\n      {pubkey: tokenSwap, isSigner: false, isWritable: false},\n      {pubkey: authority, isSigner: false, isWritable: false},\n      {pubkey: sourceA, isSigner: false, isWritable: true},\n      {pubkey: sourceB, isSigner: false, isWritable: true},\n      {pubkey: intoA, isSigner: false, isWritable: true},\n      {pubkey: intoB, isSigner: false, isWritable: true},\n      {pubkey: poolToken, isSigner: false, isWritable: true},\n      {pubkey: poolAccount, isSigner: false, isWritable: true},\n      {pubkey: tokenProgramId, isSigner: false, isWritable: false},\n    ];\n    return new TransactionInstruction({\n      keys,\n      programId: swapProgramId,\n      data,\n    });\n  }\n\n  /**\n   * Withdraw the token from the pool at the current ratio\n   *\n   * @param authority Authority\n   * @param sourcePoolAccount Source pool account\n   * @param poolToken Pool token\n   * @param fromA Base account A to withdraw from\n   * @param fromB Base account B to withdraw from\n   * @param userAccountA Token A user account\n   * @param userAccountB token B user account\n   * @param tokenProgramId Token program id\n   * @param amount Amount of pool token to withdraw, token A and B amount are set by the exchange rate relative to the total pool token supply\n   */\n  async withdraw(\n    authority: PublicKey,\n    poolMint: PublicKey,\n    sourcePoolAccount: PublicKey,\n    fromA: PublicKey,\n    fromB: PublicKey,\n    userAccountA: PublicKey,\n    userAccountB: PublicKey,\n    tokenProgramId: PublicKey,\n    poolTokenAmount: number | Numberu64,\n    minimumTokenA: number | Numberu64,\n    minimumTokenB: number | Numberu64,\n  ): Promise<TransactionSignature> {\n    return await sendAndConfirmTransaction(\n      'withdraw',\n      this.connection,\n      new Transaction().add(\n        TokenSwap.withdrawInstruction(\n          this.tokenSwap,\n          authority,\n          poolMint,\n          sourcePoolAccount,\n          fromA,\n          fromB,\n          userAccountA,\n          userAccountB,\n          this.programId,\n          tokenProgramId,\n          poolTokenAmount,\n          minimumTokenA,\n          minimumTokenB,\n        ),\n      ),\n      this.payer,\n    );\n  }\n\n  static withdrawInstruction(\n    tokenSwap: PublicKey,\n    authority: PublicKey,\n    poolMint: PublicKey,\n    sourcePoolAccount: PublicKey,\n    fromA: PublicKey,\n    fromB: PublicKey,\n    userAccountA: PublicKey,\n    userAccountB: PublicKey,\n    swapProgramId: PublicKey,\n    tokenProgramId: PublicKey,\n    poolTokenAmount: number | Numberu64,\n    minimumTokenA: number | Numberu64,\n    minimumTokenB: number | Numberu64,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('poolTokenAmount'),\n      Layout.uint64('minimumTokenA'),\n      Layout.uint64('minimumTokenB'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 3, // Withdraw instruction\n        poolTokenAmount: new Numberu64(poolTokenAmount).toBuffer(),\n        minimumTokenA: new Numberu64(minimumTokenA).toBuffer(),\n        minimumTokenB: new Numberu64(minimumTokenB).toBuffer(),\n      },\n      data,\n    );\n\n    const keys = [\n      {pubkey: tokenSwap, isSigner: false, isWritable: false},\n      {pubkey: authority, isSigner: false, isWritable: false},\n      {pubkey: poolMint, isSigner: false, isWritable: true},\n      {pubkey: sourcePoolAccount, isSigner: false, isWritable: true},\n      {pubkey: fromA, isSigner: false, isWritable: true},\n      {pubkey: fromB, isSigner: false, isWritable: true},\n      {pubkey: userAccountA, isSigner: false, isWritable: true},\n      {pubkey: userAccountB, isSigner: false, isWritable: true},\n      {pubkey: tokenProgramId, isSigner: false, isWritable: false},\n    ];\n    return new TransactionInstruction({\n      keys,\n      programId: swapProgramId,\n      data,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}