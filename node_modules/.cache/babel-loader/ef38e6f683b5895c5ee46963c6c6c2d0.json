{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport assert from 'assert';\nimport BN from 'bn.js';\nimport { blob, struct, u32, u8 } from 'buffer-layout';\nimport { sendAndConfirmTransaction as sendAndConfirmTransaction$1, PublicKey, Account, Transaction, SystemProgram, TransactionInstruction, SYSVAR_RENT_PUBKEY } from '@solana/web3.js';\n/**\n * Layout for a public key\n */\n\nconst publicKey = (property = 'publicKey') => {\n  return blob(32, property);\n};\n/**\n * Layout for a 64bit unsigned value\n */\n\n\nconst uint64 = (property = 'uint64') => {\n  return blob(8, property);\n};\n\nfunction sendAndConfirmTransaction(title, connection, transaction, ...signers) {\n  return sendAndConfirmTransaction$1(connection, transaction, signers, {\n    skipPreflight: false,\n    commitment: 'recent',\n    preflightCommitment: 'recent'\n  });\n}\n/**\n * 64-bit value\n */\n\n\nclass u64 extends BN {\n  /**\n   * Convert to Buffer representation\n   */\n  toBuffer() {\n    const a = super.toArray().reverse();\n    const b = Buffer.from(a);\n\n    if (b.length === 8) {\n      return b;\n    }\n\n    assert(b.length < 8, 'u64 too large');\n    const zeroPad = Buffer.alloc(8);\n    b.copy(zeroPad);\n    return zeroPad;\n  }\n  /**\n   * Construct a u64 from Buffer representation\n   */\n\n\n  static fromBuffer(buffer) {\n    assert(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);\n    return new BN([...buffer].reverse().map(i => `00${i.toString(16)}`.slice(-2)).join(''), 16);\n  }\n\n}\n\nfunction isAccount(accountOrPublicKey) {\n  return 'publicKey' in accountOrPublicKey;\n}\n\nconst AuthorityTypeCodes = {\n  MintTokens: 0,\n  FreezeAccount: 1,\n  AccountOwner: 2,\n  CloseAccount: 3\n}; // The address of the special mint for wrapped native token.\n\nconst NATIVE_MINT = new PublicKey('So11111111111111111111111111111111111111112');\n/**\n * Information about the mint\n */\n\nconst MintLayout = struct([u32('mintAuthorityOption'), publicKey('mintAuthority'), uint64('supply'), u8('decimals'), u8('isInitialized'), u32('freezeAuthorityOption'), publicKey('freezeAuthority')]);\n/**\n * Information about an account\n */\n\n/**\n * @private\n */\n\nconst AccountLayout = struct([publicKey('mint'), publicKey('owner'), uint64('amount'), u32('delegateOption'), publicKey('delegate'), u8('state'), u32('isNativeOption'), uint64('isNative'), uint64('delegatedAmount'), u32('closeAuthorityOption'), publicKey('closeAuthority')]);\n/**\n * Information about an multisig\n */\n\n/**\n * @private\n */\n\nconst MultisigLayout = struct([u8('m'), u8('n'), u8('is_initialized'), publicKey('signer1'), publicKey('signer2'), publicKey('signer3'), publicKey('signer4'), publicKey('signer5'), publicKey('signer6'), publicKey('signer7'), publicKey('signer8'), publicKey('signer9'), publicKey('signer10'), publicKey('signer11')]);\n/**\n * An ERC20-like Token\n */\n\nclass Token {\n  /**\n   * @private\n   */\n\n  /**\n   * The public key identifying this mint\n   */\n\n  /**\n   * Program Identifier for the Token program\n   */\n\n  /**\n   * Fee payer\n   */\n\n  /**\n   * Create a Token object attached to the specific mint\n   *\n   * @param connection The connection to use\n   * @param token Public key of the mint\n   * @param programId token programId\n   * @param payer Payer of fees\n   */\n  constructor(connection, publicKey, programId, payer) {\n    _defineProperty(this, \"connection\", void 0);\n\n    _defineProperty(this, \"publicKey\", void 0);\n\n    _defineProperty(this, \"programId\", void 0);\n\n    _defineProperty(this, \"payer\", void 0);\n\n    Object.assign(this, {\n      connection,\n      publicKey,\n      programId,\n      payer\n    });\n  }\n  /**\n   * Get the minimum balance for the mint to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n\n\n  static async getMinBalanceRentForExemptMint(connection) {\n    return await connection.getMinimumBalanceForRentExemption(MintLayout.span);\n  }\n  /**\n   * Get the minimum balance for the account to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n\n\n  static async getMinBalanceRentForExemptAccount(connection) {\n    return await connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n  }\n  /**\n   * Get the minimum balance for the multsig to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n\n\n  static async getMinBalanceRentForExemptMultisig(connection) {\n    return await connection.getMinimumBalanceForRentExemption(MultisigLayout.span);\n  }\n  /**\n   * Create and initialize a token.\n   *\n   * @param connection The connection to use\n   * @param payer Fee payer for transaction\n   * @param mintAuthority Account or multisig that will control minting\n   * @param freezeAuthority Optional account or multisig that can freeze token accounts\n   * @param decimals Location of the decimal place\n   * @param programId Optional token programId, uses the system programId by default\n   * @return Token object for the newly minted token\n   */\n\n\n  static async createMint(connection, payer, mintAuthority, freezeAuthority, decimals, programId) {\n    const mintAccount = new Account();\n    const token = new Token(connection, mintAccount.publicKey, programId, payer); // Allocate memory for the account\n\n    const balanceNeeded = await Token.getMinBalanceRentForExemptMint(connection);\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: payer.publicKey,\n      newAccountPubkey: mintAccount.publicKey,\n      lamports: balanceNeeded,\n      space: MintLayout.span,\n      programId\n    }));\n    transaction.add(Token.createInitMintInstruction(programId, mintAccount.publicKey, decimals, mintAuthority, freezeAuthority)); // Send the two instructions\n\n    await sendAndConfirmTransaction('createAccount and InitializeMint', connection, transaction, payer, mintAccount);\n    return token;\n  }\n  /**\n   * Create and initialize a new account.\n   *\n   * This account may then be used as a `transfer()` or `approve()` destination\n   *\n   * @param owner User account that will own the new account\n   * @return Public key of the new empty account\n   */\n\n\n  async createAccount(owner) {\n    // Allocate memory for the account\n    const balanceNeeded = await Token.getMinBalanceRentForExemptAccount(this.connection);\n    const newAccount = new Account();\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: this.payer.publicKey,\n      newAccountPubkey: newAccount.publicKey,\n      lamports: balanceNeeded,\n      space: AccountLayout.span,\n      programId: this.programId\n    }));\n    const mintPublicKey = this.publicKey;\n    transaction.add(Token.createInitAccountInstruction(this.programId, mintPublicKey, newAccount.publicKey, owner)); // Send the two instructions\n\n    await sendAndConfirmTransaction('createAccount and InitializeAccount', this.connection, transaction, this.payer, newAccount);\n    return newAccount.publicKey;\n  }\n  /**\n   * Create and initialize a new account on the special native token mint.\n   *\n   * In order to be wrapped, the account must have a balance of native tokens\n   * when it is initialized with the token program.\n   *\n   * This function sends lamports to the new account before initializing it.\n   *\n   * @param connection A solana web3 connection\n   * @param programId The token program ID\n   * @param owner The owner of the new token account\n   * @param payer The source of the lamports to initialize, and payer of the initialization fees.\n   * @param amount The amount of lamports to wrap\n   * @return {Promise<PublicKey>} The new token account\n   */\n\n\n  static async createWrappedNativeAccount(connection, programId, owner, payer, amount) {\n    // Allocate memory for the account\n    const balanceNeeded = await Token.getMinBalanceRentForExemptAccount(connection); // Create a new account\n\n    const newAccount = new Account();\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: payer.publicKey,\n      newAccountPubkey: newAccount.publicKey,\n      lamports: balanceNeeded,\n      space: AccountLayout.span,\n      programId\n    })); // Send lamports to it (these will be wrapped into native tokens by the token program)\n\n    transaction.add(SystemProgram.transfer({\n      fromPubkey: payer.publicKey,\n      toPubkey: newAccount.publicKey,\n      lamports: amount\n    })); // Assign the new account to the native token mint.\n    // the account will be initialized with a balance equal to the native token balance.\n    // (i.e. amount)\n\n    transaction.add(Token.createInitAccountInstruction(programId, NATIVE_MINT, newAccount.publicKey, owner)); // Send the three instructions\n\n    await sendAndConfirmTransaction('createAccount, transfer, and initializeAccount', connection, transaction, payer, newAccount);\n    return newAccount.publicKey;\n  }\n  /**\n   * Create and initialize a new multisig.\n   *\n   * This account may then be used for multisignature verification\n   *\n   * @param m Number of required signatures\n   * @param signers Full set of signers\n   * @return Public key of the new multisig account\n   */\n\n\n  async createMultisig(m, signers) {\n    const multisigAccount = new Account(); // Allocate memory for the account\n\n    const balanceNeeded = await Token.getMinBalanceRentForExemptMultisig(this.connection);\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: this.payer.publicKey,\n      newAccountPubkey: multisigAccount.publicKey,\n      lamports: balanceNeeded,\n      space: MultisigLayout.span,\n      programId: this.programId\n    })); // create the new account\n\n    let keys = [{\n      pubkey: multisigAccount.publicKey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }];\n    signers.forEach(signer => keys.push({\n      pubkey: signer,\n      isSigner: false,\n      isWritable: false\n    }));\n    const dataLayout = struct([u8('instruction'), u8('m')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 2,\n      // InitializeMultisig instruction\n      m\n    }, data);\n    transaction.add({\n      keys,\n      programId: this.programId,\n      data\n    }); // Send the two instructions\n\n    await sendAndConfirmTransaction('createAccount and InitializeMultisig', this.connection, transaction, this.payer, multisigAccount);\n    return multisigAccount.publicKey;\n  }\n  /**\n   * Retrieve mint information\n   */\n\n\n  async getMintInfo() {\n    const info = await this.connection.getAccountInfo(this.publicKey);\n\n    if (info === null) {\n      throw new Error('Failed to find mint account');\n    }\n\n    if (!info.owner.equals(this.programId)) {\n      throw new Error(`Invalid mint owner: ${JSON.stringify(info.owner)}`);\n    }\n\n    if (info.data.length != MintLayout.span) {\n      throw new Error(`Invalid mint size`);\n    }\n\n    const data = Buffer.from(info.data);\n    const mintInfo = MintLayout.decode(data);\n\n    if (mintInfo.mintAuthorityOption === 0) {\n      mintInfo.mintAuthority = null;\n    } else {\n      mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n    }\n\n    mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n    mintInfo.isInitialized = mintInfo.isInitialized != 0;\n\n    if (mintInfo.freezeAuthorityOption === 0) {\n      mintInfo.freezeAuthority = null;\n    } else {\n      mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n    }\n\n    return mintInfo;\n  }\n  /**\n   * Retrieve account information\n   *\n   * @param account Public key of the account\n   */\n\n\n  async getAccountInfo(account, commitment) {\n    const info = await this.connection.getAccountInfo(account, commitment);\n\n    if (info === null) {\n      throw new Error('Failed to find account');\n    }\n\n    if (!info.owner.equals(this.programId)) {\n      throw new Error(`Invalid account owner`);\n    }\n\n    if (info.data.length != AccountLayout.span) {\n      throw new Error(`Invalid account size`);\n    }\n\n    const data = Buffer.from(info.data);\n    const accountInfo = AccountLayout.decode(data);\n    accountInfo.mint = new PublicKey(accountInfo.mint);\n    accountInfo.owner = new PublicKey(accountInfo.owner);\n    accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n    if (accountInfo.delegateOption === 0) {\n      accountInfo.delegate = null;\n      accountInfo.delegatedAmount = new u64();\n    } else {\n      accountInfo.delegate = new PublicKey(accountInfo.delegate);\n      accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n    }\n\n    accountInfo.isInitialized = accountInfo.state !== 0;\n    accountInfo.isFrozen = accountInfo.state === 2;\n\n    if (accountInfo.isNativeOption === 1) {\n      accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n      accountInfo.isNative = true;\n    } else {\n      accountInfo.rentExemptReserve = null;\n      accountInfo.isNative = false;\n    }\n\n    if (accountInfo.closeAuthorityOption === 0) {\n      accountInfo.closeAuthority = null;\n    } else {\n      accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n    }\n\n    if (!accountInfo.mint.equals(this.publicKey)) {\n      throw new Error(`Invalid account mint: ${JSON.stringify(accountInfo.mint)} !== ${JSON.stringify(this.publicKey)}`);\n    }\n\n    return accountInfo;\n  }\n  /**\n   * Retrieve Multisig information\n   *\n   * @param multisig Public key of the account\n   */\n\n\n  async getMultisigInfo(multisig) {\n    const info = await this.connection.getAccountInfo(multisig);\n\n    if (info === null) {\n      throw new Error('Failed to find multisig');\n    }\n\n    if (!info.owner.equals(this.programId)) {\n      throw new Error(`Invalid multisig owner`);\n    }\n\n    if (info.data.length != MultisigLayout.span) {\n      throw new Error(`Invalid multisig size`);\n    }\n\n    const data = Buffer.from(info.data);\n    const multisigInfo = MultisigLayout.decode(data);\n    multisigInfo.signer1 = new PublicKey(multisigInfo.signer1);\n    multisigInfo.signer2 = new PublicKey(multisigInfo.signer2);\n    multisigInfo.signer3 = new PublicKey(multisigInfo.signer3);\n    multisigInfo.signer4 = new PublicKey(multisigInfo.signer4);\n    multisigInfo.signer5 = new PublicKey(multisigInfo.signer5);\n    multisigInfo.signer6 = new PublicKey(multisigInfo.signer6);\n    multisigInfo.signer7 = new PublicKey(multisigInfo.signer7);\n    multisigInfo.signer8 = new PublicKey(multisigInfo.signer8);\n    multisigInfo.signer9 = new PublicKey(multisigInfo.signer9);\n    multisigInfo.signer10 = new PublicKey(multisigInfo.signer10);\n    multisigInfo.signer11 = new PublicKey(multisigInfo.signer11);\n    return multisigInfo;\n  }\n  /**\n   * Transfer tokens to another account\n   *\n   * @param source Source account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Number of tokens to transfer\n   */\n\n\n  async transfer(source, destination, owner, multiSigners, amount) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n\n    return await sendAndConfirmTransaction('Transfer', this.connection, new Transaction().add(Token.createTransferInstruction(this.programId, source, destination, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);\n  }\n  /**\n   * Grant a third-party permission to transfer up the specified number of tokens from an account\n   *\n   * @param account Public key of the account\n   * @param delegate Account authorized to perform a transfer tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   */\n\n\n  async approve(account, delegate, owner, multiSigners, amount) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('Approve', this.connection, new Transaction().add(Token.createApproveInstruction(this.programId, account, delegate, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);\n  }\n  /**\n   * Remove approval for the transfer of any remaining tokens\n   *\n   * @param account Public key of the account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n\n\n  async revoke(account, owner, multiSigners) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('Revoke', this.connection, new Transaction().add(Token.createRevokeInstruction(this.programId, account, ownerPublicKey, multiSigners)), this.payer, ...signers);\n  }\n  /**\n   * Assign a new authority to the account\n   *\n   * @param account Public key of the account\n   * @param newAuthority New authority of the account\n   * @param authorityType Type of authority to set\n   * @param currentAuthority Current authority of the account\n   * @param multiSigners Signing accounts if `currentAuthority` is a multiSig\n   */\n\n\n  async setAuthority(account, newAuthority, authorityType, currentAuthority, multiSigners) {\n    let currentAuthorityPublicKey;\n    let signers;\n\n    if (isAccount(currentAuthority)) {\n      currentAuthorityPublicKey = currentAuthority.publicKey;\n      signers = [currentAuthority];\n    } else {\n      currentAuthorityPublicKey = currentAuthority;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('SetAuthority', this.connection, new Transaction().add(Token.createSetAuthorityInstruction(this.programId, account, newAuthority, authorityType, currentAuthorityPublicKey, multiSigners)), this.payer, ...signers);\n  }\n  /**\n   * Mint new tokens\n   *\n   * @param dest Public key of the account to mint to\n   * @param authority Minting authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   */\n\n\n  async mintTo(dest, authority, multiSigners, amount) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(authority)) {\n      ownerPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      ownerPublicKey = authority;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('MintTo', this.connection, new Transaction().add(Token.createMintToInstruction(this.programId, this.publicKey, dest, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);\n  }\n  /**\n   * Burn tokens\n   *\n   * @param account Account to burn tokens from\n   * @param owner Account owner\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Amount to burn\n   */\n\n\n  async burn(account, owner, multiSigners, amount) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('Burn', this.connection, new Transaction().add(Token.createBurnInstruction(this.programId, this.publicKey, account, ownerPublicKey, multiSigners, amount)), this.payer, ...signers);\n  }\n  /**\n   * Close account\n   *\n   * @param account Account to close\n   * @param dest Account to receive the remaining balance of the closed account\n   * @param authority Authority which is allowed to close the account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   */\n\n\n  async closeAccount(account, dest, authority, multiSigners) {\n    let authorityPublicKey;\n    let signers;\n\n    if (isAccount(authority)) {\n      authorityPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      authorityPublicKey = authority;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('CloseAccount', this.connection, new Transaction().add(Token.createCloseAccountInstruction(this.programId, account, dest, authorityPublicKey, multiSigners)), this.payer, ...signers);\n  }\n  /**\n   * Freeze account\n   *\n   * @param account Account to freeze\n   * @param authority The mint freeze authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   */\n\n\n  async freezeAccount(account, authority, multiSigners) {\n    let authorityPublicKey;\n    let signers;\n\n    if (isAccount(authority)) {\n      authorityPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      authorityPublicKey = authority;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('FreezeAccount', this.connection, new Transaction().add(Token.createFreezeAccountInstruction(this.programId, account, this.publicKey, authorityPublicKey, multiSigners)), this.payer, ...signers);\n  }\n  /**\n   * Thaw account\n   *\n   * @param account Account to thaw\n   * @param authority The mint freeze authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   */\n\n\n  async thawAccount(account, authority, multiSigners) {\n    let authorityPublicKey;\n    let signers;\n\n    if (isAccount(authority)) {\n      authorityPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      authorityPublicKey = authority;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('ThawAccount', this.connection, new Transaction().add(Token.createThawAccountInstruction(this.programId, account, this.publicKey, authorityPublicKey, multiSigners)), this.payer, ...signers);\n  }\n  /**\n   * Transfer tokens to another account, asserting the token mint and decimals\n   *\n   * @param source Source account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Number of tokens to transfer\n   * @param decimals Number of decimals in transfer amount\n   */\n\n\n  async transfer2(source, destination, owner, multiSigners, amount, decimals) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n\n    return await sendAndConfirmTransaction('Transfer2', this.connection, new Transaction().add(Token.createTransfer2Instruction(this.programId, source, this.publicKey, destination, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);\n  }\n  /**\n   * Grant a third-party permission to transfer up the specified number of tokens from an account,\n   * asserting the token mint and decimals\n   *\n   * @param account Public key of the account\n   * @param delegate Account authorized to perform a transfer tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   * @param decimals Number of decimals in approve amount\n   */\n\n\n  async approve2(account, delegate, owner, multiSigners, amount, decimals) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('Approve2', this.connection, new Transaction().add(Token.createApprove2Instruction(this.programId, account, this.publicKey, delegate, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);\n  }\n  /**\n   * Mint new tokens, asserting the token mint and decimals\n   *\n   * @param dest Public key of the account to mint to\n   * @param authority Minting authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   * @param decimals Number of decimals in amount to mint\n   */\n\n\n  async mintTo2(dest, authority, multiSigners, amount, decimals) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(authority)) {\n      ownerPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      ownerPublicKey = authority;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('MintTo2', this.connection, new Transaction().add(Token.createMintTo2Instruction(this.programId, this.publicKey, dest, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);\n  }\n  /**\n   * Burn tokens, asserting the token mint and decimals\n   *\n   * @param account Account to burn tokens from\n   * @param owner Account owner\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Amount to burn\n   * @param decimals Number of decimals in amount to burn\n   */\n\n\n  async burn2(account, owner, multiSigners, amount, decimals) {\n    let ownerPublicKey;\n    let signers;\n\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n\n    await sendAndConfirmTransaction('Burn2', this.connection, new Transaction().add(Token.createBurn2Instruction(this.programId, this.publicKey, account, ownerPublicKey, multiSigners, amount, decimals)), this.payer, ...signers);\n  }\n  /**\n   * Construct an InitializeMint instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Token mint account\n   * @param decimals Number of decimals in token account amounts\n   * @param mintAuthority Minting authority\n   * @param freezeAuthority Optional authority that can freeze token accounts\n   */\n\n\n  static createInitMintInstruction(programId, mint, decimals, mintAuthority, freezeAuthority) {\n    let keys = [{\n      pubkey: mint,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }];\n    const commandDataLayout = struct([u8('instruction'), u8('decimals'), publicKey('mintAuthority'), u8('option'), publicKey('freezeAuthority')]);\n    let data = Buffer.alloc(1024);\n    {\n      const encodeLength = commandDataLayout.encode({\n        instruction: 0,\n        // InitializeMint instruction\n        decimals,\n        mintAuthority: mintAuthority.toBuffer(),\n        option: freezeAuthority === null ? 0 : 1,\n        freezeAuthority: (freezeAuthority || new PublicKey()).toBuffer()\n      }, data);\n      data = data.slice(0, encodeLength);\n    }\n    return new TransactionInstruction({\n      keys,\n      programId,\n      data\n    });\n  }\n  /**\n   * Construct an InitializeAccount instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Token mint account\n   * @param account New account\n   * @param owner Owner of the new account\n   */\n\n\n  static createInitAccountInstruction(programId, mint, account, owner) {\n    const keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: mint,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: owner,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }];\n    const dataLayout = struct([u8('instruction')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 1 // InitializeAccount instruction\n\n    }, data);\n    return new TransactionInstruction({\n      keys,\n      programId,\n      data\n    });\n  }\n  /**\n   * Construct a Transfer instruction\n   *\n   * @param programId SPL Token program account\n   * @param source Source account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Number of tokens to transfer\n   */\n\n\n  static createTransferInstruction(programId, source, destination, owner, multiSigners, amount) {\n    const dataLayout = struct([u8('instruction'), uint64('amount')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 3,\n      // Transfer instruction\n      amount: new u64(amount).toBuffer()\n    }, data);\n    let keys = [{\n      pubkey: source,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: destination,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct an Approve instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param delegate Account authorized to perform a transfer of tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   */\n\n\n  static createApproveInstruction(programId, account, delegate, owner, multiSigners, amount) {\n    const dataLayout = struct([u8('instruction'), uint64('amount')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 4,\n      // Approve instruction\n      amount: new u64(amount).toBuffer()\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: delegate,\n      isSigner: false,\n      isWritable: false\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a Revoke instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n\n\n  static createRevokeInstruction(programId, account, owner, multiSigners) {\n    const dataLayout = struct([u8('instruction')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 5 // Approve instruction\n\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a SetAuthority instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param newAuthority New authority of the account\n   * @param authorityType Type of authority to set\n   * @param currentAuthority Current authority of the specified type\n   * @param multiSigners Signing accounts if `currentAuthority` is a multiSig\n   */\n\n\n  static createSetAuthorityInstruction(programId, account, newAuthority, authorityType, currentAuthority, multiSigners) {\n    const commandDataLayout = struct([u8('instruction'), u8('authorityType'), u8('option'), publicKey('newAuthority')]);\n    let data = Buffer.alloc(1024);\n    {\n      const encodeLength = commandDataLayout.encode({\n        instruction: 6,\n        // SetAuthority instruction\n        authorityType: AuthorityTypeCodes[authorityType],\n        option: newAuthority === null ? 0 : 1,\n        newAuthority: (newAuthority || new PublicKey()).toBuffer()\n      }, data);\n      data = data.slice(0, encodeLength);\n    }\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: currentAuthority,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: currentAuthority,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a MintTo instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Public key of the mint\n   * @param dest Public key of the account to mint to\n   * @param authority The mint authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   */\n\n\n  static createMintToInstruction(programId, mint, dest, authority, multiSigners, amount) {\n    const dataLayout = struct([u8('instruction'), uint64('amount')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 7,\n      // MintTo instruction\n      amount: new u64(amount).toBuffer()\n    }, data);\n    let keys = [{\n      pubkey: mint,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: dest,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: authority,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a Burn instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Mint for the account\n   * @param account Account to burn tokens from\n   * @param owner Owner of the account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount amount to burn\n   */\n\n\n  static createBurnInstruction(programId, mint, account, owner, multiSigners, amount) {\n    const dataLayout = struct([u8('instruction'), uint64('amount')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 8,\n      // Burn instruction\n      amount: new u64(amount).toBuffer()\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: mint,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a Close instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Account to close\n   * @param dest Account to receive the remaining balance of the closed account\n   * @param authority Account Close authority\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n\n\n  static createCloseAccountInstruction(programId, account, dest, owner, multiSigners) {\n    const dataLayout = struct([u8('instruction')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 9 // CloseAccount instruction\n\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: dest,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a Freeze instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Account to freeze\n   * @param mint Mint account\n   * @param authority Mint freeze authority\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n\n\n  static createFreezeAccountInstruction(programId, account, mint, authority, multiSigners) {\n    const dataLayout = struct([u8('instruction')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 10 // FreezeAccount instruction\n\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: mint,\n      isSigner: false,\n      isWritable: false\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: authority,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a Thaw instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Account to thaw\n   * @param mint Mint account\n   * @param authority Mint freeze authority\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n\n\n  static createThawAccountInstruction(programId, account, mint, authority, multiSigners) {\n    const dataLayout = struct([u8('instruction')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 11 // ThawAccount instruction\n\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: mint,\n      isSigner: false,\n      isWritable: false\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: authority,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a Transfer2 instruction\n   *\n   * @param programId SPL Token program account\n   * @param source Source account\n   * @param mint Mint account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Number of tokens to transfer\n   * @param decimals Number of decimals in transfer amount\n   */\n\n\n  static createTransfer2Instruction(programId, source, mint, destination, owner, multiSigners, amount, decimals) {\n    const dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 12,\n      // Transfer2 instruction\n      amount: new u64(amount).toBuffer(),\n      decimals\n    }, data);\n    let keys = [{\n      pubkey: source,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: mint,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: destination,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct an Approve2 instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param mint Mint account\n   * @param delegate Account authorized to perform a transfer of tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   * @param decimals Number of decimals in approve amount\n   */\n\n\n  static createApprove2Instruction(programId, account, mint, delegate, owner, multiSigners, amount, decimals) {\n    const dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 13,\n      // Approve2 instruction\n      amount: new u64(amount).toBuffer(),\n      decimals\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: mint,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: delegate,\n      isSigner: false,\n      isWritable: false\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a MintTo2 instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Public key of the mint\n   * @param dest Public key of the account to mint to\n   * @param authority The mint authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   * @param decimals Number of decimals in amount to mint\n   */\n\n\n  static createMintTo2Instruction(programId, mint, dest, authority, multiSigners, amount, decimals) {\n    const dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 14,\n      // MintTo2 instruction\n      amount: new u64(amount).toBuffer(),\n      decimals\n    }, data);\n    let keys = [{\n      pubkey: mint,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: dest,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: authority,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n  /**\n   * Construct a Burn2 instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Mint for the account\n   * @param account Account to burn tokens from\n   * @param owner Owner of the account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount amount to burn\n   */\n\n\n  static createBurn2Instruction(programId, mint, account, owner, multiSigners, amount, decimals) {\n    const dataLayout = struct([u8('instruction'), uint64('amount'), u8('decimals')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode({\n      instruction: 15,\n      // Burn2 instruction\n      amount: new u64(amount).toBuffer(),\n      decimals\n    }, data);\n    let keys = [{\n      pubkey: account,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: mint,\n      isSigner: false,\n      isWritable: true\n    }];\n\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false\n      });\n    } else {\n      keys.push({\n        pubkey: owner,\n        isSigner: false,\n        isWritable: false\n      });\n      multiSigners.forEach(signer => keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      }));\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data\n    });\n  }\n\n}\n\nexport { AccountLayout, MintLayout, NATIVE_MINT, Token, u64 };","map":{"version":3,"sources":["../client/layout.js","../client/util/send-and-confirm-transaction.js","../client/token.js"],"names":["publicKey","property","BufferLayout","uint64","realSendAndConfirmTransaction","skipPreflight","commitment","preflightCommitment","toBuffer","a","b","Buffer","assert","zeroPad","buffer","length","i","AuthorityTypeCodes","MintTokens","FreezeAccount","AccountOwner","CloseAccount","NATIVE_MINT","MintLayout","Layout","AccountLayout","MultisigLayout","constructor","Object","payer","connection","mintAccount","token","balanceNeeded","Token","transaction","fromPubkey","newAccountPubkey","lamports","space","programId","sendAndConfirmTransaction","newAccount","mintPublicKey","toPubkey","amount","multisigAccount","keys","pubkey","isSigner","isWritable","signers","signer","dataLayout","data","instruction","m","info","JSON","mintInfo","u64","accountInfo","multisigInfo","isAccount","ownerPublicKey","owner","currentAuthorityPublicKey","currentAuthority","authority","authorityPublicKey","commandDataLayout","encodeLength","mintAuthority","option","freezeAuthority","multiSigners","authorityType","newAuthority","decimals"],"mappings":"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","sourcesContent":["// @flow\n\nimport * as BufferLayout from 'buffer-layout';\n\n/**\n * Layout for a public key\n */\nexport const publicKey = (property: string = 'publicKey'): Object => {\n  return BufferLayout.blob(32, property);\n};\n\n/**\n * Layout for a 64bit unsigned value\n */\nexport const uint64 = (property: string = 'uint64'): Object => {\n  return BufferLayout.blob(8, property);\n};\n\n/**\n * Layout for a Rust String type\n */\nexport const rustString = (property: string = 'string'): Object => {\n  const rsl = BufferLayout.struct(\n    [\n      BufferLayout.u32('length'),\n      BufferLayout.u32('lengthPadding'),\n      BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), 'chars'),\n    ],\n    property,\n  );\n  const _decode = rsl.decode.bind(rsl);\n  const _encode = rsl.encode.bind(rsl);\n\n  rsl.decode = (buffer, offset) => {\n    const data = _decode(buffer, offset);\n    return data.chars.toString('utf8');\n  };\n\n  rsl.encode = (str, buffer, offset) => {\n    const data = {\n      chars: Buffer.from(str, 'utf8'),\n    };\n    return _encode(data, buffer, offset);\n  };\n\n  return rsl;\n};\n","// @flow\n\nimport {sendAndConfirmTransaction as realSendAndConfirmTransaction} from '@solana/web3.js';\nimport type {\n  Account,\n  Connection,\n  Transaction,\n  TransactionSignature,\n} from '@solana/web3.js';\n\nexport function sendAndConfirmTransaction(\n  title: string,\n  connection: Connection,\n  transaction: Transaction,\n  ...signers: Array<Account>\n): Promise<TransactionSignature> {\n  return realSendAndConfirmTransaction(connection, transaction, signers, {\n    skipPreflight: false,\n    commitment: 'recent',\n    preflightCommitment: 'recent',\n  });\n}\n","/**\n * @flow\n */\n\nimport assert from 'assert';\nimport BN from 'bn.js';\nimport * as BufferLayout from 'buffer-layout';\nimport {\n  Account,\n  PublicKey,\n  SystemProgram,\n  Transaction,\n  TransactionInstruction,\n  SYSVAR_RENT_PUBKEY,\n} from '@solana/web3.js';\nimport type {\n  Connection,\n  Commitment,\n  TransactionSignature,\n} from '@solana/web3.js';\n\nimport * as Layout from './layout';\nimport {sendAndConfirmTransaction} from './util/send-and-confirm-transaction';\n\n/**\n * 64-bit value\n */\nexport class u64 extends BN {\n  /**\n   * Convert to Buffer representation\n   */\n  toBuffer(): typeof Buffer {\n    const a = super.toArray().reverse();\n    const b = Buffer.from(a);\n    if (b.length === 8) {\n      return b;\n    }\n    assert(b.length < 8, 'u64 too large');\n\n    const zeroPad = Buffer.alloc(8);\n    b.copy(zeroPad);\n    return zeroPad;\n  }\n\n  /**\n   * Construct a u64 from Buffer representation\n   */\n  static fromBuffer(buffer: typeof Buffer): u64 {\n    assert(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);\n    return new BN(\n      [...buffer]\n        .reverse()\n        .map(i => `00${i.toString(16)}`.slice(-2))\n        .join(''),\n      16,\n    );\n  }\n}\n\nfunction isAccount(accountOrPublicKey: any): boolean {\n  return 'publicKey' in accountOrPublicKey;\n}\n\ntype AuthorityType =\n  | 'MintTokens'\n  | 'FreezeAccount'\n  | 'AccountOwner'\n  | 'CloseAccount';\n\nconst AuthorityTypeCodes = {\n  MintTokens: 0,\n  FreezeAccount: 1,\n  AccountOwner: 2,\n  CloseAccount: 3,\n};\n\n// The address of the special mint for wrapped native token.\nexport const NATIVE_MINT: PublicKey = new PublicKey(\n  'So11111111111111111111111111111111111111112',\n);\n\n/**\n * Information about the mint\n */\ntype MintInfo = {|\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only be provided during\n   * mint creation. If no mint authority is present then the mint has a fixed supply and no\n   * further tokens may be minted.\n   */\n  mintAuthority: null | PublicKey,\n\n  /**\n   * Total supply of tokens\n   */\n  supply: u64,\n\n  /**\n   * Number of base 10 digits to the right of the decimal place\n   */\n  decimals: number,\n\n  /**\n   * Is this mint initialized\n   */\n  isInitialized: boolean,\n\n  /**\n   * Optional authority to freeze token accounts\n   */\n  freezeAuthority: null | PublicKey,\n|};\n\nexport const MintLayout: typeof BufferLayout.Structure = BufferLayout.struct([\n  BufferLayout.u32('mintAuthorityOption'),\n  Layout.publicKey('mintAuthority'),\n  Layout.uint64('supply'),\n  BufferLayout.u8('decimals'),\n  BufferLayout.u8('isInitialized'),\n  BufferLayout.u32('freezeAuthorityOption'),\n  Layout.publicKey('freezeAuthority'),\n]);\n\n/**\n * Information about an account\n */\ntype AccountInfo = {|\n  /**\n   * The mint associated with this account\n   */\n  mint: PublicKey,\n\n  /**\n   * Owner of this account\n   */\n  owner: PublicKey,\n\n  /**\n   * Amount of tokens this account holds\n   */\n  amount: u64,\n\n  /**\n   * The delegate for this account\n   */\n  delegate: null | PublicKey,\n\n  /**\n   * The amount of tokens the delegate authorized to the delegate\n   */\n  delegatedAmount: u64,\n\n  /**\n   * Is this account initialized\n   */\n  isInitialized: boolean,\n\n  /**\n   * Is this account frozen\n   */\n  isFrozen: boolean,\n\n  /**\n   * Is this a native token account\n   */\n  isNative: boolean,\n\n  /**\n   * If this account is a native token, it must be rent-exempt. This\n   * value logs the rent-exempt reserve which must remain in the balance\n   * until the account is closed.\n   */\n  rentExemptReserve: null | u64,\n\n  /**\n   * Optional authority to close the account\n   */\n  closeAuthority: null | PublicKey,\n|};\n\n/**\n * @private\n */\nexport const AccountLayout: typeof BufferLayout.Structure = BufferLayout.struct(\n  [\n    Layout.publicKey('mint'),\n    Layout.publicKey('owner'),\n    Layout.uint64('amount'),\n    BufferLayout.u32('delegateOption'),\n    Layout.publicKey('delegate'),\n    BufferLayout.u8('state'),\n    BufferLayout.u32('isNativeOption'),\n    Layout.uint64('isNative'),\n    Layout.uint64('delegatedAmount'),\n    BufferLayout.u32('closeAuthorityOption'),\n    Layout.publicKey('closeAuthority'),\n  ],\n);\n\n/**\n * Information about an multisig\n */\ntype MultisigInfo = {|\n  /**\n   * The number of signers required\n   */\n  m: number,\n\n  /**\n   * Number of possible signers, corresponds to the\n   * number of `signers` that are valid.\n   */\n  n: number,\n\n  /**\n   * Is this mint initialized\n   */\n  initialized: boolean,\n\n  /**\n   * The signers\n   */\n  signer1: PublicKey,\n  signer2: PublicKey,\n  signer3: PublicKey,\n  signer4: PublicKey,\n  signer5: PublicKey,\n  signer6: PublicKey,\n  signer7: PublicKey,\n  signer8: PublicKey,\n  signer9: PublicKey,\n  signer10: PublicKey,\n  signer11: PublicKey,\n|};\n\n/**\n * @private\n */\nconst MultisigLayout = BufferLayout.struct([\n  BufferLayout.u8('m'),\n  BufferLayout.u8('n'),\n  BufferLayout.u8('is_initialized'),\n  Layout.publicKey('signer1'),\n  Layout.publicKey('signer2'),\n  Layout.publicKey('signer3'),\n  Layout.publicKey('signer4'),\n  Layout.publicKey('signer5'),\n  Layout.publicKey('signer6'),\n  Layout.publicKey('signer7'),\n  Layout.publicKey('signer8'),\n  Layout.publicKey('signer9'),\n  Layout.publicKey('signer10'),\n  Layout.publicKey('signer11'),\n]);\n\n/**\n * An ERC20-like Token\n */\nexport class Token {\n  /**\n   * @private\n   */\n  connection: Connection;\n\n  /**\n   * The public key identifying this mint\n   */\n  publicKey: PublicKey;\n\n  /**\n   * Program Identifier for the Token program\n   */\n  programId: PublicKey;\n\n  /**\n   * Fee payer\n   */\n  payer: Account;\n\n  /**\n   * Create a Token object attached to the specific mint\n   *\n   * @param connection The connection to use\n   * @param token Public key of the mint\n   * @param programId token programId\n   * @param payer Payer of fees\n   */\n  constructor(\n    connection: Connection,\n    publicKey: PublicKey,\n    programId: PublicKey,\n    payer: Account,\n  ) {\n    Object.assign(this, {connection, publicKey, programId, payer});\n  }\n\n  /**\n   * Get the minimum balance for the mint to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n  static async getMinBalanceRentForExemptMint(\n    connection: Connection,\n  ): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(MintLayout.span);\n  }\n\n  /**\n   * Get the minimum balance for the account to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n  static async getMinBalanceRentForExemptAccount(\n    connection: Connection,\n  ): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(\n      AccountLayout.span,\n    );\n  }\n\n  /**\n   * Get the minimum balance for the multsig to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n  static async getMinBalanceRentForExemptMultisig(\n    connection: Connection,\n  ): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(\n      MultisigLayout.span,\n    );\n  }\n\n  /**\n   * Create and initialize a token.\n   *\n   * @param connection The connection to use\n   * @param payer Fee payer for transaction\n   * @param mintAuthority Account or multisig that will control minting\n   * @param freezeAuthority Optional account or multisig that can freeze token accounts\n   * @param decimals Location of the decimal place\n   * @param programId Optional token programId, uses the system programId by default\n   * @return Token object for the newly minted token\n   */\n  static async createMint(\n    connection: Connection,\n    payer: Account,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey | null,\n    decimals: number,\n    programId: PublicKey,\n  ): Promise<Token> {\n    const mintAccount = new Account();\n    const token = new Token(\n      connection,\n      mintAccount.publicKey,\n      programId,\n      payer,\n    );\n\n    // Allocate memory for the account\n    const balanceNeeded = await Token.getMinBalanceRentForExemptMint(\n      connection,\n    );\n\n    const transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: mintAccount.publicKey,\n        lamports: balanceNeeded,\n        space: MintLayout.span,\n        programId,\n      }),\n    );\n\n    transaction.add(\n      Token.createInitMintInstruction(\n        programId,\n        mintAccount.publicKey,\n        decimals,\n        mintAuthority,\n        freezeAuthority,\n      ),\n    );\n\n    // Send the two instructions\n    await sendAndConfirmTransaction(\n      'createAccount and InitializeMint',\n      connection,\n      transaction,\n      payer,\n      mintAccount,\n    );\n\n    return token;\n  }\n\n  /**\n   * Create and initialize a new account.\n   *\n   * This account may then be used as a `transfer()` or `approve()` destination\n   *\n   * @param owner User account that will own the new account\n   * @return Public key of the new empty account\n   */\n  async createAccount(owner: PublicKey): Promise<PublicKey> {\n    // Allocate memory for the account\n    const balanceNeeded = await Token.getMinBalanceRentForExemptAccount(\n      this.connection,\n    );\n\n    const newAccount = new Account();\n    const transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: this.payer.publicKey,\n        newAccountPubkey: newAccount.publicKey,\n        lamports: balanceNeeded,\n        space: AccountLayout.span,\n        programId: this.programId,\n      }),\n    );\n\n    const mintPublicKey = this.publicKey;\n    transaction.add(\n      Token.createInitAccountInstruction(\n        this.programId,\n        mintPublicKey,\n        newAccount.publicKey,\n        owner,\n      ),\n    );\n\n    // Send the two instructions\n    await sendAndConfirmTransaction(\n      'createAccount and InitializeAccount',\n      this.connection,\n      transaction,\n      this.payer,\n      newAccount,\n    );\n\n    return newAccount.publicKey;\n  }\n\n  /**\n   * Create and initialize a new account on the special native token mint.\n   *\n   * In order to be wrapped, the account must have a balance of native tokens\n   * when it is initialized with the token program.\n   *\n   * This function sends lamports to the new account before initializing it.\n   *\n   * @param connection A solana web3 connection\n   * @param programId The token program ID\n   * @param owner The owner of the new token account\n   * @param payer The source of the lamports to initialize, and payer of the initialization fees.\n   * @param amount The amount of lamports to wrap\n   * @return {Promise<PublicKey>} The new token account\n   */\n  static async createWrappedNativeAccount(\n    connection: Connection,\n    programId: PublicKey,\n    owner: PublicKey,\n    payer: Account,\n    amount: number,\n  ): Promise<PublicKey> {\n    // Allocate memory for the account\n    const balanceNeeded = await Token.getMinBalanceRentForExemptAccount(\n      connection,\n    );\n\n    // Create a new account\n    const newAccount = new Account();\n    const transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: newAccount.publicKey,\n        lamports: balanceNeeded,\n        space: AccountLayout.span,\n        programId,\n      }),\n    );\n\n    // Send lamports to it (these will be wrapped into native tokens by the token program)\n    transaction.add(\n      SystemProgram.transfer({\n        fromPubkey: payer.publicKey,\n        toPubkey: newAccount.publicKey,\n        lamports: amount,\n      }),\n    );\n\n    // Assign the new account to the native token mint.\n    // the account will be initialized with a balance equal to the native token balance.\n    // (i.e. amount)\n    transaction.add(\n      Token.createInitAccountInstruction(\n        programId,\n        NATIVE_MINT,\n        newAccount.publicKey,\n        owner,\n      ),\n    );\n\n    // Send the three instructions\n    await sendAndConfirmTransaction(\n      'createAccount, transfer, and initializeAccount',\n      connection,\n      transaction,\n      payer,\n      newAccount,\n    );\n\n    return newAccount.publicKey;\n  }\n\n  /**\n   * Create and initialize a new multisig.\n   *\n   * This account may then be used for multisignature verification\n   *\n   * @param m Number of required signatures\n   * @param signers Full set of signers\n   * @return Public key of the new multisig account\n   */\n  async createMultisig(\n    m: number,\n    signers: Array<PublicKey>,\n  ): Promise<PublicKey> {\n    const multisigAccount = new Account();\n\n    // Allocate memory for the account\n    const balanceNeeded = await Token.getMinBalanceRentForExemptMultisig(\n      this.connection,\n    );\n    const transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: this.payer.publicKey,\n        newAccountPubkey: multisigAccount.publicKey,\n        lamports: balanceNeeded,\n        space: MultisigLayout.span,\n        programId: this.programId,\n      }),\n    );\n\n    // create the new account\n    let keys = [\n      {pubkey: multisigAccount.publicKey, isSigner: false, isWritable: true},\n      {pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false},\n    ];\n    signers.forEach(signer =>\n      keys.push({pubkey: signer, isSigner: false, isWritable: false}),\n    );\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      BufferLayout.u8('m'),\n    ]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 2, // InitializeMultisig instruction\n        m,\n      },\n      data,\n    );\n    transaction.add({\n      keys,\n      programId: this.programId,\n      data,\n    });\n\n    // Send the two instructions\n    await sendAndConfirmTransaction(\n      'createAccount and InitializeMultisig',\n      this.connection,\n      transaction,\n      this.payer,\n      multisigAccount,\n    );\n\n    return multisigAccount.publicKey;\n  }\n\n  /**\n   * Retrieve mint information\n   */\n  async getMintInfo(): Promise<MintInfo> {\n    const info = await this.connection.getAccountInfo(this.publicKey);\n    if (info === null) {\n      throw new Error('Failed to find mint account');\n    }\n    if (!info.owner.equals(this.programId)) {\n      throw new Error(`Invalid mint owner: ${JSON.stringify(info.owner)}`);\n    }\n    if (info.data.length != MintLayout.span) {\n      throw new Error(`Invalid mint size`);\n    }\n\n    const data = Buffer.from(info.data);\n    const mintInfo = MintLayout.decode(data);\n\n    if (mintInfo.mintAuthorityOption === 0) {\n      mintInfo.mintAuthority = null;\n    } else {\n      mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n    }\n\n    mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n    mintInfo.isInitialized = mintInfo.isInitialized != 0;\n\n    if (mintInfo.freezeAuthorityOption === 0) {\n      mintInfo.freezeAuthority = null;\n    } else {\n      mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n    }\n    return mintInfo;\n  }\n\n  /**\n   * Retrieve account information\n   *\n   * @param account Public key of the account\n   */\n  async getAccountInfo(\n    account: PublicKey,\n    commitment?: Commitment,\n  ): Promise<AccountInfo> {\n    const info = await this.connection.getAccountInfo(account, commitment);\n    if (info === null) {\n      throw new Error('Failed to find account');\n    }\n    if (!info.owner.equals(this.programId)) {\n      throw new Error(`Invalid account owner`);\n    }\n    if (info.data.length != AccountLayout.span) {\n      throw new Error(`Invalid account size`);\n    }\n\n    const data = Buffer.from(info.data);\n    const accountInfo = AccountLayout.decode(data);\n    accountInfo.mint = new PublicKey(accountInfo.mint);\n    accountInfo.owner = new PublicKey(accountInfo.owner);\n    accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n    if (accountInfo.delegateOption === 0) {\n      accountInfo.delegate = null;\n      accountInfo.delegatedAmount = new u64();\n    } else {\n      accountInfo.delegate = new PublicKey(accountInfo.delegate);\n      accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n    }\n\n    accountInfo.isInitialized = accountInfo.state !== 0;\n    accountInfo.isFrozen = accountInfo.state === 2;\n\n    if (accountInfo.isNativeOption === 1) {\n      accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n      accountInfo.isNative = true;\n    } else {\n      accountInfo.rentExemptReserve = null;\n      accountInfo.isNative = false;\n    }\n\n    if (accountInfo.closeAuthorityOption === 0) {\n      accountInfo.closeAuthority = null;\n    } else {\n      accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n    }\n\n    if (!accountInfo.mint.equals(this.publicKey)) {\n      throw new Error(\n        `Invalid account mint: ${JSON.stringify(\n          accountInfo.mint,\n        )} !== ${JSON.stringify(this.publicKey)}`,\n      );\n    }\n    return accountInfo;\n  }\n\n  /**\n   * Retrieve Multisig information\n   *\n   * @param multisig Public key of the account\n   */\n  async getMultisigInfo(multisig: PublicKey): Promise<MultisigInfo> {\n    const info = await this.connection.getAccountInfo(multisig);\n    if (info === null) {\n      throw new Error('Failed to find multisig');\n    }\n    if (!info.owner.equals(this.programId)) {\n      throw new Error(`Invalid multisig owner`);\n    }\n    if (info.data.length != MultisigLayout.span) {\n      throw new Error(`Invalid multisig size`);\n    }\n\n    const data = Buffer.from(info.data);\n    const multisigInfo = MultisigLayout.decode(data);\n    multisigInfo.signer1 = new PublicKey(multisigInfo.signer1);\n    multisigInfo.signer2 = new PublicKey(multisigInfo.signer2);\n    multisigInfo.signer3 = new PublicKey(multisigInfo.signer3);\n    multisigInfo.signer4 = new PublicKey(multisigInfo.signer4);\n    multisigInfo.signer5 = new PublicKey(multisigInfo.signer5);\n    multisigInfo.signer6 = new PublicKey(multisigInfo.signer6);\n    multisigInfo.signer7 = new PublicKey(multisigInfo.signer7);\n    multisigInfo.signer8 = new PublicKey(multisigInfo.signer8);\n    multisigInfo.signer9 = new PublicKey(multisigInfo.signer9);\n    multisigInfo.signer10 = new PublicKey(multisigInfo.signer10);\n    multisigInfo.signer11 = new PublicKey(multisigInfo.signer11);\n\n    return multisigInfo;\n  }\n\n  /**\n   * Transfer tokens to another account\n   *\n   * @param source Source account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Number of tokens to transfer\n   */\n  async transfer(\n    source: PublicKey,\n    destination: PublicKey,\n    owner: any,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n  ): Promise<TransactionSignature> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n    return await sendAndConfirmTransaction(\n      'Transfer',\n      this.connection,\n      new Transaction().add(\n        Token.createTransferInstruction(\n          this.programId,\n          source,\n          destination,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Grant a third-party permission to transfer up the specified number of tokens from an account\n   *\n   * @param account Public key of the account\n   * @param delegate Account authorized to perform a transfer tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   */\n  async approve(\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: any,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n  ): Promise<void> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'Approve',\n      this.connection,\n      new Transaction().add(\n        Token.createApproveInstruction(\n          this.programId,\n          account,\n          delegate,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Remove approval for the transfer of any remaining tokens\n   *\n   * @param account Public key of the account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n  async revoke(\n    account: PublicKey,\n    owner: any,\n    multiSigners: Array<Account>,\n  ): Promise<void> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'Revoke',\n      this.connection,\n      new Transaction().add(\n        Token.createRevokeInstruction(\n          this.programId,\n          account,\n          ownerPublicKey,\n          multiSigners,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Assign a new authority to the account\n   *\n   * @param account Public key of the account\n   * @param newAuthority New authority of the account\n   * @param authorityType Type of authority to set\n   * @param currentAuthority Current authority of the account\n   * @param multiSigners Signing accounts if `currentAuthority` is a multiSig\n   */\n  async setAuthority(\n    account: PublicKey,\n    newAuthority: PublicKey | null,\n    authorityType: AuthorityType,\n    currentAuthority: any,\n    multiSigners: Array<Account>,\n  ): Promise<void> {\n    let currentAuthorityPublicKey: PublicKey;\n    let signers;\n    if (isAccount(currentAuthority)) {\n      currentAuthorityPublicKey = currentAuthority.publicKey;\n      signers = [currentAuthority];\n    } else {\n      currentAuthorityPublicKey = currentAuthority;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'SetAuthority',\n      this.connection,\n      new Transaction().add(\n        Token.createSetAuthorityInstruction(\n          this.programId,\n          account,\n          newAuthority,\n          authorityType,\n          currentAuthorityPublicKey,\n          multiSigners,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Mint new tokens\n   *\n   * @param dest Public key of the account to mint to\n   * @param authority Minting authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   */\n  async mintTo(\n    dest: PublicKey,\n    authority: any,\n    multiSigners: Array<Account>,\n    amount: number,\n  ): Promise<void> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(authority)) {\n      ownerPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      ownerPublicKey = authority;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'MintTo',\n      this.connection,\n      new Transaction().add(\n        Token.createMintToInstruction(\n          this.programId,\n          this.publicKey,\n          dest,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Burn tokens\n   *\n   * @param account Account to burn tokens from\n   * @param owner Account owner\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Amount to burn\n   */\n  async burn(\n    account: PublicKey,\n    owner: any,\n    multiSigners: Array<Account>,\n    amount: number,\n  ): Promise<void> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'Burn',\n      this.connection,\n      new Transaction().add(\n        Token.createBurnInstruction(\n          this.programId,\n          this.publicKey,\n          account,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Close account\n   *\n   * @param account Account to close\n   * @param dest Account to receive the remaining balance of the closed account\n   * @param authority Authority which is allowed to close the account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   */\n  async closeAccount(\n    account: PublicKey,\n    dest: PublicKey,\n    authority: any,\n    multiSigners: Array<Account>,\n  ): Promise<void> {\n    let authorityPublicKey;\n    let signers;\n    if (isAccount(authority)) {\n      authorityPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      authorityPublicKey = authority;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'CloseAccount',\n      this.connection,\n      new Transaction().add(\n        Token.createCloseAccountInstruction(\n          this.programId,\n          account,\n          dest,\n          authorityPublicKey,\n          multiSigners,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Freeze account\n   *\n   * @param account Account to freeze\n   * @param authority The mint freeze authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   */\n  async freezeAccount(\n    account: PublicKey,\n    authority: any,\n    multiSigners: Array<Account>,\n  ): Promise<void> {\n    let authorityPublicKey;\n    let signers;\n    if (isAccount(authority)) {\n      authorityPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      authorityPublicKey = authority;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'FreezeAccount',\n      this.connection,\n      new Transaction().add(\n        Token.createFreezeAccountInstruction(\n          this.programId,\n          account,\n          this.publicKey,\n          authorityPublicKey,\n          multiSigners,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Thaw account\n   *\n   * @param account Account to thaw\n   * @param authority The mint freeze authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   */\n  async thawAccount(\n    account: PublicKey,\n    authority: any,\n    multiSigners: Array<Account>,\n  ): Promise<void> {\n    let authorityPublicKey;\n    let signers;\n    if (isAccount(authority)) {\n      authorityPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      authorityPublicKey = authority;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'ThawAccount',\n      this.connection,\n      new Transaction().add(\n        Token.createThawAccountInstruction(\n          this.programId,\n          account,\n          this.publicKey,\n          authorityPublicKey,\n          multiSigners,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Transfer tokens to another account, asserting the token mint and decimals\n   *\n   * @param source Source account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Number of tokens to transfer\n   * @param decimals Number of decimals in transfer amount\n   */\n  async transfer2(\n    source: PublicKey,\n    destination: PublicKey,\n    owner: any,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n    decimals: number,\n  ): Promise<TransactionSignature> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n    return await sendAndConfirmTransaction(\n      'Transfer2',\n      this.connection,\n      new Transaction().add(\n        Token.createTransfer2Instruction(\n          this.programId,\n          source,\n          this.publicKey,\n          destination,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n          decimals,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Grant a third-party permission to transfer up the specified number of tokens from an account,\n   * asserting the token mint and decimals\n   *\n   * @param account Public key of the account\n   * @param delegate Account authorized to perform a transfer tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   * @param decimals Number of decimals in approve amount\n   */\n  async approve2(\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: any,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n    decimals: number,\n  ): Promise<void> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'Approve2',\n      this.connection,\n      new Transaction().add(\n        Token.createApprove2Instruction(\n          this.programId,\n          account,\n          this.publicKey,\n          delegate,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n          decimals,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Mint new tokens, asserting the token mint and decimals\n   *\n   * @param dest Public key of the account to mint to\n   * @param authority Minting authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   * @param decimals Number of decimals in amount to mint\n   */\n  async mintTo2(\n    dest: PublicKey,\n    authority: any,\n    multiSigners: Array<Account>,\n    amount: number,\n    decimals: number,\n  ): Promise<void> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(authority)) {\n      ownerPublicKey = authority.publicKey;\n      signers = [authority];\n    } else {\n      ownerPublicKey = authority;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'MintTo2',\n      this.connection,\n      new Transaction().add(\n        Token.createMintTo2Instruction(\n          this.programId,\n          this.publicKey,\n          dest,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n          decimals,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Burn tokens, asserting the token mint and decimals\n   *\n   * @param account Account to burn tokens from\n   * @param owner Account owner\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Amount to burn\n   * @param decimals Number of decimals in amount to burn\n   */\n  async burn2(\n    account: PublicKey,\n    owner: any,\n    multiSigners: Array<Account>,\n    amount: number,\n    decimals: number,\n  ): Promise<void> {\n    let ownerPublicKey;\n    let signers;\n    if (isAccount(owner)) {\n      ownerPublicKey = owner.publicKey;\n      signers = [owner];\n    } else {\n      ownerPublicKey = owner;\n      signers = multiSigners;\n    }\n    await sendAndConfirmTransaction(\n      'Burn2',\n      this.connection,\n      new Transaction().add(\n        Token.createBurn2Instruction(\n          this.programId,\n          this.publicKey,\n          account,\n          ownerPublicKey,\n          multiSigners,\n          amount,\n          decimals,\n        ),\n      ),\n      this.payer,\n      ...signers,\n    );\n  }\n\n  /**\n   * Construct an InitializeMint instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Token mint account\n   * @param decimals Number of decimals in token account amounts\n   * @param mintAuthority Minting authority\n   * @param freezeAuthority Optional authority that can freeze token accounts\n   */\n  static createInitMintInstruction(\n    programId: PublicKey,\n    mint: PublicKey,\n    decimals: number,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey | null,\n  ): TransactionInstruction {\n    let keys = [\n      {pubkey: mint, isSigner: false, isWritable: true},\n      {pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false},\n    ];\n    const commandDataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      BufferLayout.u8('decimals'),\n      Layout.publicKey('mintAuthority'),\n      BufferLayout.u8('option'),\n      Layout.publicKey('freezeAuthority'),\n    ]);\n    let data = Buffer.alloc(1024);\n    {\n      const encodeLength = commandDataLayout.encode(\n        {\n          instruction: 0, // InitializeMint instruction\n          decimals,\n          mintAuthority: mintAuthority.toBuffer(),\n          option: freezeAuthority === null ? 0 : 1,\n          freezeAuthority: (freezeAuthority || new PublicKey()).toBuffer(),\n        },\n        data,\n      );\n      data = data.slice(0, encodeLength);\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct an InitializeAccount instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Token mint account\n   * @param account New account\n   * @param owner Owner of the new account\n   */\n  static createInitAccountInstruction(\n    programId: PublicKey,\n    mint: PublicKey,\n    account: PublicKey,\n    owner: PublicKey,\n  ): TransactionInstruction {\n    const keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: mint, isSigner: false, isWritable: false},\n      {pubkey: owner, isSigner: false, isWritable: false},\n      {pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false},\n    ];\n    const dataLayout = BufferLayout.struct([BufferLayout.u8('instruction')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 1, // InitializeAccount instruction\n      },\n      data,\n    );\n\n    return new TransactionInstruction({\n      keys,\n      programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Transfer instruction\n   *\n   * @param programId SPL Token program account\n   * @param source Source account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Number of tokens to transfer\n   */\n  static createTransferInstruction(\n    programId: PublicKey,\n    source: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 3, // Transfer instruction\n        amount: new u64(amount).toBuffer(),\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: source, isSigner: false, isWritable: true},\n      {pubkey: destination, isSigner: false, isWritable: true},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false,\n      });\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct an Approve instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param delegate Account authorized to perform a transfer of tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   */\n  static createApproveInstruction(\n    programId: PublicKey,\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 4, // Approve instruction\n        amount: new u64(amount).toBuffer(),\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: delegate, isSigner: false, isWritable: false},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({pubkey: owner, isSigner: true, isWritable: false});\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Revoke instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n  static createRevokeInstruction(\n    programId: PublicKey,\n    account: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([BufferLayout.u8('instruction')]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 5, // Approve instruction\n      },\n      data,\n    );\n\n    let keys = [{pubkey: account, isSigner: false, isWritable: true}];\n    if (multiSigners.length === 0) {\n      keys.push({pubkey: owner, isSigner: true, isWritable: false});\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a SetAuthority instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param newAuthority New authority of the account\n   * @param authorityType Type of authority to set\n   * @param currentAuthority Current authority of the specified type\n   * @param multiSigners Signing accounts if `currentAuthority` is a multiSig\n   */\n  static createSetAuthorityInstruction(\n    programId: PublicKey,\n    account: PublicKey,\n    newAuthority: PublicKey | null,\n    authorityType: AuthorityType,\n    currentAuthority: PublicKey,\n    multiSigners: Array<Account>,\n  ): TransactionInstruction {\n    const commandDataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      BufferLayout.u8('authorityType'),\n      BufferLayout.u8('option'),\n      Layout.publicKey('newAuthority'),\n    ]);\n\n    let data = Buffer.alloc(1024);\n    {\n      const encodeLength = commandDataLayout.encode(\n        {\n          instruction: 6, // SetAuthority instruction\n          authorityType: AuthorityTypeCodes[authorityType],\n          option: newAuthority === null ? 0 : 1,\n          newAuthority: (newAuthority || new PublicKey()).toBuffer(),\n        },\n        data,\n      );\n      data = data.slice(0, encodeLength);\n    }\n\n    let keys = [{pubkey: account, isSigner: false, isWritable: true}];\n    if (multiSigners.length === 0) {\n      keys.push({pubkey: currentAuthority, isSigner: true, isWritable: false});\n    } else {\n      keys.push({pubkey: currentAuthority, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a MintTo instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Public key of the mint\n   * @param dest Public key of the account to mint to\n   * @param authority The mint authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   */\n  static createMintToInstruction(\n    programId: PublicKey,\n    mint: PublicKey,\n    dest: PublicKey,\n    authority: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 7, // MintTo instruction\n        amount: new u64(amount).toBuffer(),\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: mint, isSigner: false, isWritable: true},\n      {pubkey: dest, isSigner: false, isWritable: true},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: authority,\n        isSigner: true,\n        isWritable: false,\n      });\n    } else {\n      keys.push({pubkey: authority, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Burn instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Mint for the account\n   * @param account Account to burn tokens from\n   * @param owner Owner of the account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount amount to burn\n   */\n  static createBurnInstruction(\n    programId: PublicKey,\n    mint: PublicKey,\n    account: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 8, // Burn instruction\n        amount: new u64(amount).toBuffer(),\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: mint, isSigner: false, isWritable: true},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false,\n      });\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Close instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Account to close\n   * @param dest Account to receive the remaining balance of the closed account\n   * @param authority Account Close authority\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n  static createCloseAccountInstruction(\n    programId: PublicKey,\n    account: PublicKey,\n    dest: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([BufferLayout.u8('instruction')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 9, // CloseAccount instruction\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: dest, isSigner: false, isWritable: true},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({pubkey: owner, isSigner: true, isWritable: false});\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Freeze instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Account to freeze\n   * @param mint Mint account\n   * @param authority Mint freeze authority\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n  static createFreezeAccountInstruction(\n    programId: PublicKey,\n    account: PublicKey,\n    mint: PublicKey,\n    authority: PublicKey,\n    multiSigners: Array<Account>,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([BufferLayout.u8('instruction')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 10, // FreezeAccount instruction\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: mint, isSigner: false, isWritable: false},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({pubkey: authority, isSigner: true, isWritable: false});\n    } else {\n      keys.push({pubkey: authority, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Thaw instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Account to thaw\n   * @param mint Mint account\n   * @param authority Mint freeze authority\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   */\n  static createThawAccountInstruction(\n    programId: PublicKey,\n    account: PublicKey,\n    mint: PublicKey,\n    authority: PublicKey,\n    multiSigners: Array<Account>,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([BufferLayout.u8('instruction')]);\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 11, // ThawAccount instruction\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: mint, isSigner: false, isWritable: false},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({pubkey: authority, isSigner: true, isWritable: false});\n    } else {\n      keys.push({pubkey: authority, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Transfer2 instruction\n   *\n   * @param programId SPL Token program account\n   * @param source Source account\n   * @param mint Mint account\n   * @param destination Destination account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Number of tokens to transfer\n   * @param decimals Number of decimals in transfer amount\n   */\n  static createTransfer2Instruction(\n    programId: PublicKey,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n    decimals: number,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n      BufferLayout.u8('decimals'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 12, // Transfer2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals,\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: source, isSigner: false, isWritable: true},\n      {pubkey: mint, isSigner: false, isWritable: false},\n      {pubkey: destination, isSigner: false, isWritable: true},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false,\n      });\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct an Approve2 instruction\n   *\n   * @param programId SPL Token program account\n   * @param account Public key of the account\n   * @param mint Mint account\n   * @param delegate Account authorized to perform a transfer of tokens from the source account\n   * @param owner Owner of the source account\n   * @param multiSigners Signing accounts if `owner` is a multiSig\n   * @param amount Maximum number of tokens the delegate may transfer\n   * @param decimals Number of decimals in approve amount\n   */\n  static createApprove2Instruction(\n    programId: PublicKey,\n    account: PublicKey,\n    mint: PublicKey,\n    delegate: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number | u64,\n    decimals: number,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n      BufferLayout.u8('decimals'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 13, // Approve2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals,\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: mint, isSigner: false, isWritable: false},\n      {pubkey: delegate, isSigner: false, isWritable: false},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({pubkey: owner, isSigner: true, isWritable: false});\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a MintTo2 instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Public key of the mint\n   * @param dest Public key of the account to mint to\n   * @param authority The mint authority\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount Amount to mint\n   * @param decimals Number of decimals in amount to mint\n   */\n  static createMintTo2Instruction(\n    programId: PublicKey,\n    mint: PublicKey,\n    dest: PublicKey,\n    authority: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number,\n    decimals: number,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n      BufferLayout.u8('decimals'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 14, // MintTo2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals,\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: mint, isSigner: false, isWritable: true},\n      {pubkey: dest, isSigner: false, isWritable: true},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: authority,\n        isSigner: true,\n        isWritable: false,\n      });\n    } else {\n      keys.push({pubkey: authority, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n\n  /**\n   * Construct a Burn2 instruction\n   *\n   * @param programId SPL Token program account\n   * @param mint Mint for the account\n   * @param account Account to burn tokens from\n   * @param owner Owner of the account\n   * @param multiSigners Signing accounts if `authority` is a multiSig\n   * @param amount amount to burn\n   */\n  static createBurn2Instruction(\n    programId: PublicKey,\n    mint: PublicKey,\n    account: PublicKey,\n    owner: PublicKey,\n    multiSigners: Array<Account>,\n    amount: number,\n    decimals: number,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amount'),\n      BufferLayout.u8('decimals'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 15, // Burn2 instruction\n        amount: new u64(amount).toBuffer(),\n        decimals,\n      },\n      data,\n    );\n\n    let keys = [\n      {pubkey: account, isSigner: false, isWritable: true},\n      {pubkey: mint, isSigner: false, isWritable: true},\n    ];\n    if (multiSigners.length === 0) {\n      keys.push({\n        pubkey: owner,\n        isSigner: true,\n        isWritable: false,\n      });\n    } else {\n      keys.push({pubkey: owner, isSigner: false, isWritable: false});\n      multiSigners.forEach(signer =>\n        keys.push({\n          pubkey: signer.publicKey,\n          isSigner: true,\n          isWritable: false,\n        }),\n      );\n    }\n\n    return new TransactionInstruction({\n      keys,\n      programId: programId,\n      data,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}