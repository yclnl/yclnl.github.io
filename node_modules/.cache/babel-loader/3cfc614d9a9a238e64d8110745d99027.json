{"ast":null,"code":"import { Account, PublicKey, SystemProgram } from \"@solana/web3.js\";\nimport { sendTransaction, useConnection } from \"./connection\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { Token, MintLayout, AccountLayout } from \"@solana/spl-token\";\nimport { notify } from \"./notifications\";\nimport { cache, getCachedAccount, useUserAccounts, useCachedPool, getMultipleAccounts } from \"./accounts\";\nimport { programIds, SWAP_HOST_FEE_ADDRESS, SWAP_PROGRAM_OWNER_FEE_ADDRESS, WRAPPED_SOL_MINT } from \"./ids\";\nimport { createInitSwapInstruction, TokenSwapLayout, depositInstruction, withdrawInstruction, TokenSwapLayoutLegacyV0, swapInstruction } from \"./../models\";\nconst LIQUIDITY_TOKEN_PRECISION = 8;\nexport const removeLiquidity = async (connection, wallet, liquidityAmount, account, pool) => {\n  if (!pool) {\n    return;\n  }\n\n  notify({\n    message: \"Removing Liquidity...\",\n    description: \"Please review transactions to approve.\",\n    type: \"warn\"\n  }); // TODO get min amounts based on total supply and liquidity\n\n  const minAmount0 = 0;\n  const minAmount1 = 0;\n  const poolMint = await cache.queryMint(connection, pool.pubkeys.mint);\n  const accountA = await cache.queryAccount(connection, pool.pubkeys.holdingAccounts[0]);\n  const accountB = await cache.queryAccount(connection, pool.pubkeys.holdingAccounts[1]);\n\n  if (!poolMint.mintAuthority) {\n    throw new Error(\"Mint doesnt have authority\");\n  }\n\n  const authority = poolMint.mintAuthority;\n  const signers = [];\n  const instructions = [];\n  const cleanupInstructions = [];\n  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(AccountLayout.span); // TODO: check if one of to accounts needs to be native sol ... if yes unwrap it ...\n\n  const toAccounts = [await findOrCreateAccountByMint(wallet.publicKey, wallet.publicKey, instructions, cleanupInstructions, accountRentExempt, accountA.info.mint, signers), await findOrCreateAccountByMint(wallet.publicKey, wallet.publicKey, instructions, cleanupInstructions, accountRentExempt, accountB.info.mint, signers)];\n  instructions.push(Token.createApproveInstruction(programIds().token, account.pubkey, authority, wallet.publicKey, [], liquidityAmount)); // withdraw\n\n  instructions.push(withdrawInstruction(pool.pubkeys.account, authority, pool.pubkeys.mint, pool.pubkeys.feeAccount, account.pubkey, pool.pubkeys.holdingAccounts[0], pool.pubkeys.holdingAccounts[1], toAccounts[0], toAccounts[1], pool.pubkeys.program, programIds().token, liquidityAmount, minAmount0, minAmount1));\n  let tx = await sendTransaction(connection, wallet, instructions.concat(cleanupInstructions), signers);\n  notify({\n    message: \"Liquidity Returned. Thank you for your support.\",\n    type: \"success\",\n    description: `Transaction - ${tx}`\n  });\n};\nexport const swap = async (connection, wallet, components, SLIPPAGE, pool) => {\n  var _pool$pubkeys$holding;\n\n  if (!pool || !components[0].account) {\n    notify({\n      type: \"error\",\n      message: `Pool doesn't exsist.`,\n      description: `Swap trade cancelled`\n    });\n    return;\n  } // Uniswap whitepaper: https://uniswap.org/whitepaper.pdf\n  // see: https://uniswap.org/docs/v2/advanced-topics/pricing/\n  // as well as native uniswap v2 oracle: https://uniswap.org/docs/v2/core-concepts/oracles/\n\n\n  const amountIn = components[0].amount; // these two should include slippage\n\n  const minAmountOut = components[1].amount * (1 - SLIPPAGE);\n  const holdingA = ((_pool$pubkeys$holding = pool.pubkeys.holdingMints[0]) === null || _pool$pubkeys$holding === void 0 ? void 0 : _pool$pubkeys$holding.toBase58()) === components[0].account.info.mint.toBase58() ? pool.pubkeys.holdingAccounts[0] : pool.pubkeys.holdingAccounts[1];\n  const holdingB = holdingA === pool.pubkeys.holdingAccounts[0] ? pool.pubkeys.holdingAccounts[1] : pool.pubkeys.holdingAccounts[0];\n  const poolMint = await cache.queryMint(connection, pool.pubkeys.mint);\n\n  if (!poolMint.mintAuthority || !pool.pubkeys.feeAccount) {\n    throw new Error(\"Mint doesnt have authority\");\n  }\n\n  const authority = poolMint.mintAuthority;\n  const instructions = [];\n  const cleanupInstructions = [];\n  const signers = [];\n  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n  const fromAccount = getWrappedAccount(instructions, cleanupInstructions, components[0].account, wallet.publicKey, amountIn + accountRentExempt, signers);\n  let toAccount = findOrCreateAccountByMint(wallet.publicKey, wallet.publicKey, instructions, cleanupInstructions, accountRentExempt, new PublicKey(components[1].mintAddress), signers); // create approval for transfer transactions\n\n  instructions.push(Token.createApproveInstruction(programIds().token, fromAccount, authority, wallet.publicKey, [], amountIn));\n  let hostFeeAccount = SWAP_HOST_FEE_ADDRESS ? findOrCreateAccountByMint(wallet.publicKey, SWAP_HOST_FEE_ADDRESS, instructions, cleanupInstructions, accountRentExempt, pool.pubkeys.mint, signers) : undefined; // swap\n\n  instructions.push(swapInstruction(pool.pubkeys.account, authority, fromAccount, holdingA, holdingB, toAccount, pool.pubkeys.mint, pool.pubkeys.feeAccount, pool.pubkeys.program, programIds().token, amountIn, minAmountOut, hostFeeAccount));\n  let tx = await sendTransaction(connection, wallet, instructions.concat(cleanupInstructions), signers);\n  notify({\n    message: \"Trade executed.\",\n    type: \"success\",\n    description: `Transaction - ${tx}`\n  });\n};\nexport const addLiquidity = async (connection, wallet, components, slippage, pool, options) => {\n  if (!pool) {\n    if (!options) {\n      throw new Error(\"Options are required to create new pool.\");\n    }\n\n    await _addLiquidityNewPool(wallet, connection, components, options);\n  } else {\n    await _addLiquidityExistingPool(pool, components, connection, wallet);\n  }\n};\n\nconst getHoldings = (connection, accounts) => {\n  return accounts.map(acc => cache.queryAccount(connection, new PublicKey(acc)));\n};\n\nconst toPoolInfo = (item, program) => {\n  const mint = new PublicKey(item.data.tokenPool);\n  return {\n    pubkeys: {\n      account: item.pubkey,\n      program: program,\n      mint,\n      holdingMints: [],\n      holdingAccounts: [item.data.tokenAccountA, item.data.tokenAccountB].map(a => new PublicKey(a))\n    },\n    legacy: false,\n    raw: item\n  };\n};\n\nexport const usePools = () => {\n  const connection = useConnection();\n  const [pools, setPools] = useState([]); // initial query\n\n  useEffect(() => {\n    setPools([]);\n\n    const queryPools = async (swapId, isLegacy = false) => {\n      let poolsArray = [];\n      (await connection.getProgramAccounts(swapId)).filter(item => item.account.data.length === TokenSwapLayout.span || item.account.data.length === TokenSwapLayoutLegacyV0.span).map(item => {\n        let result = {\n          data: undefined,\n          account: item.account,\n          pubkey: item.pubkey,\n          init: async () => {}\n        }; // handling of legacy layout can be removed soon...\n\n        if (item.account.data.length === TokenSwapLayoutLegacyV0.span) {\n          result.data = TokenSwapLayoutLegacyV0.decode(item.account.data);\n          let pool = toPoolInfo(result, swapId);\n          pool.legacy = isLegacy;\n          poolsArray.push(pool);\n\n          result.init = async () => {\n            try {\n              // TODO: this is not great\n              // Ideally SwapLayout stores hash of all the mints to make finding of pool for a pair easier\n              const holdings = await Promise.all(getHoldings(connection, [result.data.tokenAccountA, result.data.tokenAccountB]));\n              pool.pubkeys.holdingMints = [holdings[0].info.mint, holdings[1].info.mint];\n            } catch (err) {\n              console.log(err);\n            }\n          };\n        } else {\n          result.data = TokenSwapLayout.decode(item.account.data);\n          let pool = toPoolInfo(result, swapId);\n          pool.legacy = isLegacy;\n          pool.pubkeys.feeAccount = new PublicKey(result.data.feeAccount);\n          pool.pubkeys.holdingMints = [new PublicKey(result.data.mintA), new PublicKey(result.data.mintB)];\n          poolsArray.push(pool);\n        }\n\n        return result;\n      });\n      const toQuery = poolsArray.map(p => {\n        var _p$pubkeys$feeAccount;\n\n        return [...p.pubkeys.holdingAccounts.map(h => h.toBase58()), ...p.pubkeys.holdingMints.map(h => h.toBase58()), (_p$pubkeys$feeAccount = p.pubkeys.feeAccount) === null || _p$pubkeys$feeAccount === void 0 ? void 0 : _p$pubkeys$feeAccount.toBase58(), // used to calculate volume aproximation\n        p.pubkeys.mint.toBase58()].filter(p => p);\n      }).flat(); // This will pre-cache all accounts used by pools\n      // All those accounts are updated whenever there is a change\n\n      await getMultipleAccounts(connection, toQuery, \"single\").then(({\n        keys,\n        array\n      }) => {\n        return array.map((obj, index) => {\n          const pubKey = new PublicKey(keys[index]);\n\n          if (obj.data.length === AccountLayout.span) {\n            return cache.addAccount(pubKey, obj);\n          } else if (obj.data.length === MintLayout.span) {\n            return cache.addMint(pubKey, obj);\n          }\n\n          return obj;\n        });\n      });\n      return poolsArray;\n    };\n\n    Promise.all([queryPools(programIds().swap), ...programIds().swap_legacy.map(leg => queryPools(leg, true))]).then(all => {\n      setPools(all.flat());\n    });\n  }, [connection]);\n  useEffect(() => {\n    const subID = connection.onProgramAccountChange(programIds().swap, async info => {\n      const id = info.accountId;\n\n      if (info.accountInfo.data.length === TokenSwapLayout.span) {\n        const account = info.accountInfo;\n        const updated = {\n          data: TokenSwapLayout.decode(account.data),\n          account: account,\n          pubkey: new PublicKey(id)\n        };\n        const index = pools && pools.findIndex(p => p.pubkeys.account.toBase58() === id);\n\n        if (index && index >= 0 && pools) {\n          // TODO: check if account is empty?\n          const filtered = pools.filter((p, i) => i !== index);\n          setPools([...filtered, toPoolInfo(updated, programIds().swap)]);\n        } else {\n          let pool = toPoolInfo(updated, programIds().swap);\n          pool.pubkeys.feeAccount = new PublicKey(updated.data.feeAccount);\n          pool.pubkeys.holdingMints = [new PublicKey(updated.data.mintA), new PublicKey(updated.data.mintB)];\n          setPools([...pools, pool]);\n        }\n      }\n    }, \"singleGossip\");\n    return () => {\n      connection.removeProgramAccountChangeListener(subID);\n    };\n  }, [connection, pools]);\n  return {\n    pools\n  };\n};\nexport const usePoolForBasket = mints => {\n  const connection = useConnection();\n  const {\n    pools\n  } = useCachedPool();\n  const [pool, setPool] = useState();\n  const sortedMints = useMemo(() => [...mints].sort(), [...mints]);\n  useEffect(() => {\n    (async () => {\n      // reset pool during query\n      setPool(undefined);\n      let matchingPool = pools.filter(p => !p.legacy).filter(p => p.pubkeys.holdingMints.map(a => a.toBase58()).sort().every((address, i) => address === sortedMints[i]));\n\n      for (let i = 0; i < matchingPool.length; i++) {\n        const p = matchingPool[i];\n        const account = await cache.queryAccount(connection, p.pubkeys.holdingAccounts[0]);\n\n        if (!account.info.amount.eqn(0)) {\n          setPool(p);\n          return;\n        }\n      }\n    })();\n  }, [connection, sortedMints, pools]);\n  return pool;\n};\nexport const useOwnedPools = () => {\n  const {\n    pools\n  } = useCachedPool();\n  const {\n    userAccounts\n  } = useUserAccounts();\n  const ownedPools = useMemo(() => {\n    const map = userAccounts.reduce((acc, item) => {\n      const key = item.info.mint.toBase58();\n      acc.set(key, [...(acc.get(key) || []), item]);\n      return acc;\n    }, new Map());\n    return pools.filter(p => map.has(p.pubkeys.mint.toBase58())).map(item => {\n      var _item$pubkeys$feeAcco, _map$get;\n\n      let feeAccount = (_item$pubkeys$feeAcco = item.pubkeys.feeAccount) === null || _item$pubkeys$feeAcco === void 0 ? void 0 : _item$pubkeys$feeAcco.toBase58();\n      return (_map$get = map.get(item.pubkeys.mint.toBase58())) === null || _map$get === void 0 ? void 0 : _map$get.map(a => {\n        return {\n          account: a,\n          isFeeAccount: feeAccount === a.pubkey.toBase58(),\n          pool: item\n        };\n      });\n    }).flat();\n  }, [pools, userAccounts]);\n  return ownedPools;\n}; // Allow for this much price movement in the pool before adding liquidity to the pool aborts\n\nconst SLIPPAGE = 0.005;\n\nasync function _addLiquidityExistingPool(pool, components, connection, wallet) {\n  notify({\n    message: \"Adding Liquidity...\",\n    description: \"Please review transactions to approve.\",\n    type: \"warn\"\n  });\n  const poolMint = await cache.queryMint(connection, pool.pubkeys.mint);\n\n  if (!poolMint.mintAuthority) {\n    throw new Error(\"Mint doesnt have authority\");\n  }\n\n  if (!pool.pubkeys.feeAccount) {\n    throw new Error(\"Invald fee account\");\n  }\n\n  const accountA = await cache.queryAccount(connection, pool.pubkeys.holdingAccounts[0]);\n  const accountB = await cache.queryAccount(connection, pool.pubkeys.holdingAccounts[1]);\n  const reserve0 = accountA.info.amount.toNumber();\n  const reserve1 = accountB.info.amount.toNumber();\n  const fromA = accountA.info.mint.toBase58() === components[0].mintAddress ? components[0] : components[1];\n  const fromB = fromA === components[0] ? components[1] : components[0];\n\n  if (!fromA.account || !fromB.account) {\n    throw new Error(\"Missing account info.\");\n  }\n\n  const supply = poolMint.supply.toNumber();\n  const authority = poolMint.mintAuthority; // Uniswap whitepaper: https://uniswap.org/whitepaper.pdf\n  // see: https://uniswap.org/docs/v2/advanced-topics/pricing/\n  // as well as native uniswap v2 oracle: https://uniswap.org/docs/v2/core-concepts/oracles/\n\n  const amount0 = fromA.amount;\n  const amount1 = fromB.amount;\n  const liquidity = Math.min(amount0 * (1 - SLIPPAGE) * supply / reserve0, amount1 * (1 - SLIPPAGE) * supply / reserve1);\n  const instructions = [];\n  const cleanupInstructions = [];\n  const signers = [];\n  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n  const fromKeyA = getWrappedAccount(instructions, cleanupInstructions, fromA.account, wallet.publicKey, amount0 + accountRentExempt, signers);\n  const fromKeyB = getWrappedAccount(instructions, cleanupInstructions, fromB.account, wallet.publicKey, amount1 + accountRentExempt, signers);\n  let toAccount = findOrCreateAccountByMint(wallet.publicKey, wallet.publicKey, instructions, [], accountRentExempt, pool.pubkeys.mint, signers, new Set([pool.pubkeys.feeAccount.toBase58()])); // create approval for transfer transactions\n\n  instructions.push(Token.createApproveInstruction(programIds().token, fromKeyA, authority, wallet.publicKey, [], amount0));\n  instructions.push(Token.createApproveInstruction(programIds().token, fromKeyB, authority, wallet.publicKey, [], amount1)); // depoist\n\n  instructions.push(depositInstruction(pool.pubkeys.account, authority, fromKeyA, fromKeyB, pool.pubkeys.holdingAccounts[0], pool.pubkeys.holdingAccounts[1], pool.pubkeys.mint, toAccount, pool.pubkeys.program, programIds().token, liquidity, amount0, amount1));\n  let tx = await sendTransaction(connection, wallet, instructions.concat(cleanupInstructions), signers);\n  notify({\n    message: \"Pool Funded. Happy trading.\",\n    type: \"success\",\n    description: `Transaction - ${tx}`\n  });\n}\n\nfunction findOrCreateAccountByMint(payer, owner, instructions, cleanupInstructions, accountRentExempt, mint, // use to identify same type\nsigners, excluded) {\n  const accountToFind = mint.toBase58();\n  const account = getCachedAccount(acc => acc.info.mint.toBase58() === accountToFind && acc.info.owner.toBase58() === owner.toBase58() && (excluded === undefined || !excluded.has(acc.pubkey.toBase58())));\n  const isWrappedSol = accountToFind === WRAPPED_SOL_MINT.toBase58();\n  let toAccount;\n\n  if (account && !isWrappedSol) {\n    toAccount = account.pubkey;\n  } else {\n    // creating depositor pool account\n    const newToAccount = createSplAccount(instructions, payer, accountRentExempt, mint, owner, AccountLayout.span);\n    toAccount = newToAccount.publicKey;\n    signers.push(newToAccount);\n\n    if (isWrappedSol) {\n      cleanupInstructions.push(Token.createCloseAccountInstruction(programIds().token, toAccount, payer, payer, []));\n    }\n  }\n\n  return toAccount;\n}\n\nfunction estimateProceedsFromInput(inputQuantityInPool, proceedsQuantityInPool, inputAmount) {\n  return proceedsQuantityInPool * inputAmount / (inputQuantityInPool + inputAmount);\n}\n\nfunction estimateInputFromProceeds(inputQuantityInPool, proceedsQuantityInPool, proceedsAmount) {\n  if (proceedsAmount >= proceedsQuantityInPool) {\n    return \"Not possible\";\n  }\n\n  return inputQuantityInPool * proceedsAmount / (proceedsQuantityInPool - proceedsAmount);\n}\n\nexport let PoolOperation;\n\n(function (PoolOperation) {\n  PoolOperation[PoolOperation[\"Add\"] = 0] = \"Add\";\n  PoolOperation[PoolOperation[\"SwapGivenInput\"] = 1] = \"SwapGivenInput\";\n  PoolOperation[PoolOperation[\"SwapGivenProceeds\"] = 2] = \"SwapGivenProceeds\";\n})(PoolOperation || (PoolOperation = {}));\n\nexport async function calculateDependentAmount(connection, independent, amount, pool, op) {\n  const poolMint = await cache.queryMint(connection, pool.pubkeys.mint);\n  const accountA = await cache.queryAccount(connection, pool.pubkeys.holdingAccounts[0]);\n  const accountB = await cache.queryAccount(connection, pool.pubkeys.holdingAccounts[1]);\n\n  if (!poolMint.mintAuthority) {\n    throw new Error(\"Mint doesnt have authority\");\n  }\n\n  if (poolMint.supply.eqn(0)) {\n    return;\n  }\n\n  const mintA = await cache.queryMint(connection, accountA.info.mint);\n  const mintB = await cache.queryMint(connection, accountB.info.mint);\n\n  if (!mintA || !mintB) {\n    return;\n  }\n\n  const isFirstIndependent = accountA.info.mint.toBase58() === independent;\n  const depPrecision = Math.pow(10, isFirstIndependent ? mintB.decimals : mintA.decimals);\n  const indPrecision = Math.pow(10, isFirstIndependent ? mintA.decimals : mintB.decimals);\n  const indAdjustedAmount = amount * indPrecision;\n  let indBasketQuantity = (isFirstIndependent ? accountA : accountB).info.amount.toNumber();\n  let depBasketQuantity = (isFirstIndependent ? accountB : accountA).info.amount.toNumber();\n  var depAdjustedAmount;\n\n  switch (+op) {\n    case PoolOperation.Add:\n      {\n        depAdjustedAmount = depBasketQuantity / indBasketQuantity * indAdjustedAmount;\n      }\n      break;\n\n    case PoolOperation.SwapGivenProceeds:\n      {\n        depAdjustedAmount = estimateInputFromProceeds(depBasketQuantity, indBasketQuantity, indAdjustedAmount);\n      }\n      break;\n\n    case PoolOperation.SwapGivenInput:\n      {\n        depAdjustedAmount = estimateProceedsFromInput(indBasketQuantity, depBasketQuantity, indAdjustedAmount);\n      }\n      break;\n  }\n\n  if (typeof depAdjustedAmount === \"string\") {\n    return depAdjustedAmount;\n  }\n\n  if (depAdjustedAmount === undefined) {\n    return undefined;\n  }\n\n  return depAdjustedAmount / depPrecision;\n} // TODO: add ui to customize curve type\n\nasync function _addLiquidityNewPool(wallet, connection, components, options) {\n  notify({\n    message: \"Creating new pool...\",\n    description: \"Please review transactions to approve.\",\n    type: \"warn\"\n  });\n\n  if (components.some(c => !c.account)) {\n    notify({\n      message: \"You need to have balance for all legs in the basket...\",\n      description: \"Please review inputs.\",\n      type: \"error\"\n    });\n    return;\n  }\n\n  let instructions = [];\n  let cleanupInstructions = [];\n  const liquidityTokenAccount = new Account(); // Create account for pool liquidity token\n\n  instructions.push(SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: liquidityTokenAccount.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(MintLayout.span),\n    space: MintLayout.span,\n    programId: programIds().token\n  }));\n  const tokenSwapAccount = new Account();\n  const [authority, nonce] = await PublicKey.findProgramAddress([tokenSwapAccount.publicKey.toBuffer()], programIds().swap); // create mint for pool liquidity token\n\n  instructions.push(Token.createInitMintInstruction(programIds().token, liquidityTokenAccount.publicKey, LIQUIDITY_TOKEN_PRECISION, // pass control of liquidity mint to swap program\n  authority, // swap program can freeze liquidity token mint\n  null)); // Create holding accounts for\n\n  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n  const holdingAccounts = [];\n  let signers = [];\n  components.forEach(leg => {\n    if (!leg.account) {\n      return;\n    }\n\n    const mintPublicKey = leg.account.info.mint; // component account to store tokens I of N in liquidity poll\n\n    holdingAccounts.push(createSplAccount(instructions, wallet.publicKey, accountRentExempt, mintPublicKey, authority, AccountLayout.span));\n  }); // creating depositor pool account\n\n  const depositorAccount = createSplAccount(instructions, wallet.publicKey, accountRentExempt, liquidityTokenAccount.publicKey, wallet.publicKey, AccountLayout.span); // creating fee pool account its set from env variable or to creater of the pool\n  // creater of the pool is not allowed in some versions of token-swap program\n\n  const feeAccount = createSplAccount(instructions, wallet.publicKey, accountRentExempt, liquidityTokenAccount.publicKey, SWAP_PROGRAM_OWNER_FEE_ADDRESS || wallet.publicKey, AccountLayout.span); // create all accounts in one transaction\n\n  let tx = await sendTransaction(connection, wallet, instructions, [liquidityTokenAccount, depositorAccount, feeAccount, ...holdingAccounts, ...signers]);\n  notify({\n    message: \"Accounts created\",\n    description: `Transaction ${tx}`,\n    type: \"success\"\n  });\n  notify({\n    message: \"Adding Liquidity...\",\n    description: \"Please review transactions to approve.\",\n    type: \"warn\"\n  });\n  signers = [];\n  instructions = [];\n  cleanupInstructions = [];\n  instructions.push(SystemProgram.createAccount({\n    fromPubkey: wallet.publicKey,\n    newAccountPubkey: tokenSwapAccount.publicKey,\n    lamports: await connection.getMinimumBalanceForRentExemption(TokenSwapLayout.span),\n    space: TokenSwapLayout.span,\n    programId: programIds().swap\n  }));\n  components.forEach((leg, i) => {\n    if (!leg.account) {\n      return;\n    } // create temporary account for wrapped sol to perform transfer\n\n\n    const from = getWrappedAccount(instructions, cleanupInstructions, leg.account, wallet.publicKey, leg.amount + accountRentExempt, signers);\n    instructions.push(Token.createTransferInstruction(programIds().token, from, holdingAccounts[i].publicKey, wallet.publicKey, [], leg.amount));\n  });\n  instructions.push(createInitSwapInstruction(tokenSwapAccount, authority, holdingAccounts[0].publicKey, holdingAccounts[1].publicKey, liquidityTokenAccount.publicKey, feeAccount.publicKey, depositorAccount.publicKey, programIds().token, programIds().swap, nonce, options.curveType, options.tradeFeeNumerator, options.tradeFeeDenominator, options.ownerTradeFeeNumerator, options.ownerTradeFeeDenominator, options.ownerWithdrawFeeNumerator, options.ownerWithdrawFeeDenominator)); // All instructions didn't fit in single transaction\n  // initialize and provide inital liquidity to swap in 2nd (this prevents loss of funds)\n\n  tx = await sendTransaction(connection, wallet, instructions.concat(cleanupInstructions), [tokenSwapAccount, ...signers]);\n  notify({\n    message: \"Pool Funded. Happy trading.\",\n    type: \"success\",\n    description: `Transaction - ${tx}`\n  });\n}\n\nfunction getWrappedAccount(instructions, cleanupInstructions, toCheck, payer, amount, signers) {\n  if (!toCheck.info.isNative) {\n    return toCheck.pubkey;\n  }\n\n  const account = new Account();\n  instructions.push(SystemProgram.createAccount({\n    fromPubkey: payer,\n    newAccountPubkey: account.publicKey,\n    lamports: amount,\n    space: AccountLayout.span,\n    programId: programIds().token\n  }));\n  instructions.push(Token.createInitAccountInstruction(programIds().token, WRAPPED_SOL_MINT, account.publicKey, payer));\n  cleanupInstructions.push(Token.createCloseAccountInstruction(programIds().token, account.publicKey, payer, payer, []));\n  signers.push(account);\n  return account.publicKey;\n}\n\nfunction createSplAccount(instructions, payer, accountRentExempt, mint, owner, space) {\n  const account = new Account();\n  instructions.push(SystemProgram.createAccount({\n    fromPubkey: payer,\n    newAccountPubkey: account.publicKey,\n    lamports: accountRentExempt,\n    space,\n    programId: programIds().token\n  }));\n  instructions.push(Token.createInitAccountInstruction(programIds().token, mint, account.publicKey, owner));\n  return account;\n}","map":{"version":3,"sources":["/home/yclnl/yclnl.github.io/src/utils/pools.tsx"],"names":["Account","PublicKey","SystemProgram","sendTransaction","useConnection","useEffect","useMemo","useState","Token","MintLayout","AccountLayout","notify","cache","getCachedAccount","useUserAccounts","useCachedPool","getMultipleAccounts","programIds","SWAP_HOST_FEE_ADDRESS","SWAP_PROGRAM_OWNER_FEE_ADDRESS","WRAPPED_SOL_MINT","createInitSwapInstruction","TokenSwapLayout","depositInstruction","withdrawInstruction","TokenSwapLayoutLegacyV0","swapInstruction","LIQUIDITY_TOKEN_PRECISION","removeLiquidity","connection","wallet","liquidityAmount","account","pool","message","description","type","minAmount0","minAmount1","poolMint","queryMint","pubkeys","mint","accountA","queryAccount","holdingAccounts","accountB","mintAuthority","Error","authority","signers","instructions","cleanupInstructions","accountRentExempt","getMinimumBalanceForRentExemption","span","toAccounts","findOrCreateAccountByMint","publicKey","info","push","createApproveInstruction","token","pubkey","feeAccount","program","tx","concat","swap","components","SLIPPAGE","amountIn","amount","minAmountOut","holdingA","holdingMints","toBase58","holdingB","fromAccount","getWrappedAccount","toAccount","mintAddress","hostFeeAccount","undefined","addLiquidity","slippage","options","_addLiquidityNewPool","_addLiquidityExistingPool","getHoldings","accounts","map","acc","toPoolInfo","item","data","tokenPool","tokenAccountA","tokenAccountB","a","legacy","raw","usePools","pools","setPools","queryPools","swapId","isLegacy","poolsArray","getProgramAccounts","filter","length","result","init","decode","holdings","Promise","all","err","console","log","mintA","mintB","toQuery","p","h","flat","then","keys","array","obj","index","pubKey","addAccount","addMint","swap_legacy","leg","subID","onProgramAccountChange","id","accountId","accountInfo","updated","findIndex","filtered","i","removeProgramAccountChangeListener","usePoolForBasket","mints","setPool","sortedMints","sort","matchingPool","every","address","eqn","useOwnedPools","userAccounts","ownedPools","reduce","key","set","get","Map","has","isFeeAccount","reserve0","toNumber","reserve1","fromA","fromB","supply","amount0","amount1","liquidity","Math","min","fromKeyA","fromKeyB","Set","payer","owner","excluded","accountToFind","isWrappedSol","newToAccount","createSplAccount","createCloseAccountInstruction","estimateProceedsFromInput","inputQuantityInPool","proceedsQuantityInPool","inputAmount","estimateInputFromProceeds","proceedsAmount","PoolOperation","calculateDependentAmount","independent","op","isFirstIndependent","depPrecision","pow","decimals","indPrecision","indAdjustedAmount","indBasketQuantity","depBasketQuantity","depAdjustedAmount","Add","SwapGivenProceeds","SwapGivenInput","some","c","liquidityTokenAccount","createAccount","fromPubkey","newAccountPubkey","lamports","space","programId","tokenSwapAccount","nonce","findProgramAddress","toBuffer","createInitMintInstruction","forEach","mintPublicKey","depositorAccount","from","createTransferInstruction","curveType","tradeFeeNumerator","tradeFeeDenominator","ownerTradeFeeNumerator","ownerTradeFeeDenominator","ownerWithdrawFeeNumerator","ownerWithdrawFeeDenominator","toCheck","isNative","createInitAccountInstruction"],"mappings":"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","sourcesContent":["import {\n  Account,\n  Connection,\n  PublicKey,\n  SystemProgram,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { sendTransaction, useConnection } from \"./connection\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { Token, MintLayout, AccountLayout } from \"@solana/spl-token\";\nimport { notify } from \"./notifications\";\nimport {\n  cache,\n  getCachedAccount,\n  useUserAccounts,\n  useCachedPool,\n  getMultipleAccounts,\n} from \"./accounts\";\nimport {\n  programIds,\n  SWAP_HOST_FEE_ADDRESS,\n  SWAP_PROGRAM_OWNER_FEE_ADDRESS,\n  WRAPPED_SOL_MINT,\n} from \"./ids\";\nimport {\n  LiquidityComponent,\n  PoolInfo,\n  TokenAccount,\n  createInitSwapInstruction,\n  TokenSwapLayout,\n  depositInstruction,\n  withdrawInstruction,\n  TokenSwapLayoutLegacyV0,\n  swapInstruction,\n  PoolConfig,\n} from \"./../models\";\n\nconst LIQUIDITY_TOKEN_PRECISION = 8;\n\nexport const removeLiquidity = async (\n  connection: Connection,\n  wallet: any,\n  liquidityAmount: number,\n  account: TokenAccount,\n  pool?: PoolInfo\n) => {\n  if (!pool) {\n    return;\n  }\n\n  notify({\n    message: \"Removing Liquidity...\",\n    description: \"Please review transactions to approve.\",\n    type: \"warn\",\n  });\n\n  // TODO get min amounts based on total supply and liquidity\n  const minAmount0 = 0;\n  const minAmount1 = 0;\n\n  const poolMint = await cache.queryMint(connection, pool.pubkeys.mint);\n  const accountA = await cache.queryAccount(\n    connection,\n    pool.pubkeys.holdingAccounts[0]\n  );\n  const accountB = await cache.queryAccount(\n    connection,\n    pool.pubkeys.holdingAccounts[1]\n  );\n  if (!poolMint.mintAuthority) {\n    throw new Error(\"Mint doesnt have authority\");\n  }\n  const authority = poolMint.mintAuthority;\n\n  const signers: Account[] = [];\n  const instructions: TransactionInstruction[] = [];\n  const cleanupInstructions: TransactionInstruction[] = [];\n\n  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(\n    AccountLayout.span\n  );\n\n  // TODO: check if one of to accounts needs to be native sol ... if yes unwrap it ...\n  const toAccounts: PublicKey[] = [\n    await findOrCreateAccountByMint(\n      wallet.publicKey,\n      wallet.publicKey,\n      instructions,\n      cleanupInstructions,\n      accountRentExempt,\n      accountA.info.mint,\n      signers\n    ),\n    await findOrCreateAccountByMint(\n      wallet.publicKey,\n      wallet.publicKey,\n      instructions,\n      cleanupInstructions,\n      accountRentExempt,\n      accountB.info.mint,\n      signers\n    ),\n  ];\n\n  instructions.push(\n    Token.createApproveInstruction(\n      programIds().token,\n      account.pubkey,\n      authority,\n      wallet.publicKey,\n      [],\n      liquidityAmount\n    )\n  );\n\n  // withdraw\n  instructions.push(\n    withdrawInstruction(\n      pool.pubkeys.account,\n      authority,\n      pool.pubkeys.mint,\n      pool.pubkeys.feeAccount,\n      account.pubkey,\n      pool.pubkeys.holdingAccounts[0],\n      pool.pubkeys.holdingAccounts[1],\n      toAccounts[0],\n      toAccounts[1],\n      pool.pubkeys.program,\n      programIds().token,\n      liquidityAmount,\n      minAmount0,\n      minAmount1\n    )\n  );\n\n  let tx = await sendTransaction(\n    connection,\n    wallet,\n    instructions.concat(cleanupInstructions),\n    signers\n  );\n\n  notify({\n    message: \"Liquidity Returned. Thank you for your support.\",\n    type: \"success\",\n    description: `Transaction - ${tx}`,\n  });\n};\n\nexport const swap = async (\n  connection: Connection,\n  wallet: any,\n  components: LiquidityComponent[],\n  SLIPPAGE: number,\n  pool?: PoolInfo\n) => {\n  if (!pool || !components[0].account) {\n    notify({\n      type: \"error\",\n      message: `Pool doesn't exsist.`,\n      description: `Swap trade cancelled`,\n    });\n    return;\n  }\n\n  // Uniswap whitepaper: https://uniswap.org/whitepaper.pdf\n  // see: https://uniswap.org/docs/v2/advanced-topics/pricing/\n  // as well as native uniswap v2 oracle: https://uniswap.org/docs/v2/core-concepts/oracles/\n  const amountIn = components[0].amount; // these two should include slippage\n  const minAmountOut = components[1].amount * (1 - SLIPPAGE);\n  const holdingA =\n    pool.pubkeys.holdingMints[0]?.toBase58() ===\n    components[0].account.info.mint.toBase58()\n      ? pool.pubkeys.holdingAccounts[0]\n      : pool.pubkeys.holdingAccounts[1];\n  const holdingB =\n    holdingA === pool.pubkeys.holdingAccounts[0]\n      ? pool.pubkeys.holdingAccounts[1]\n      : pool.pubkeys.holdingAccounts[0];\n\n  const poolMint = await cache.queryMint(connection, pool.pubkeys.mint);\n  if (!poolMint.mintAuthority || !pool.pubkeys.feeAccount) {\n    throw new Error(\"Mint doesnt have authority\");\n  }\n  const authority = poolMint.mintAuthority;\n\n  const instructions: TransactionInstruction[] = [];\n  const cleanupInstructions: TransactionInstruction[] = [];\n  const signers: Account[] = [];\n\n  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(\n    AccountLayout.span\n  );\n\n  const fromAccount = getWrappedAccount(\n    instructions,\n    cleanupInstructions,\n    components[0].account,\n    wallet.publicKey,\n    amountIn + accountRentExempt,\n    signers\n  );\n\n  let toAccount = findOrCreateAccountByMint(\n    wallet.publicKey,\n    wallet.publicKey,\n    instructions,\n    cleanupInstructions,\n    accountRentExempt,\n    new PublicKey(components[1].mintAddress),\n    signers\n  );\n\n  // create approval for transfer transactions\n  instructions.push(\n    Token.createApproveInstruction(\n      programIds().token,\n      fromAccount,\n      authority,\n      wallet.publicKey,\n      [],\n      amountIn\n    )\n  );\n\n  let hostFeeAccount = SWAP_HOST_FEE_ADDRESS\n    ? findOrCreateAccountByMint(\n        wallet.publicKey,\n        SWAP_HOST_FEE_ADDRESS,\n        instructions,\n        cleanupInstructions,\n        accountRentExempt,\n        pool.pubkeys.mint,\n        signers\n      )\n    : undefined;\n\n  // swap\n  instructions.push(\n    swapInstruction(\n      pool.pubkeys.account,\n      authority,\n      fromAccount,\n      holdingA,\n      holdingB,\n      toAccount,\n      pool.pubkeys.mint,\n      pool.pubkeys.feeAccount,\n      pool.pubkeys.program,\n      programIds().token,\n      amountIn,\n      minAmountOut,\n      hostFeeAccount\n    )\n  );\n\n  let tx = await sendTransaction(\n    connection,\n    wallet,\n    instructions.concat(cleanupInstructions),\n    signers\n  );\n\n  notify({\n    message: \"Trade executed.\",\n    type: \"success\",\n    description: `Transaction - ${tx}`,\n  });\n};\n\nexport const addLiquidity = async (\n  connection: Connection,\n  wallet: any,\n  components: LiquidityComponent[],\n  slippage: number,\n  pool?: PoolInfo,\n  options?: PoolConfig\n) => {\n  if (!pool) {\n    if (!options) {\n      throw new Error(\"Options are required to create new pool.\");\n    }\n\n    await _addLiquidityNewPool(wallet, connection, components, options);\n  } else {\n    await _addLiquidityExistingPool(pool, components, connection, wallet);\n  }\n};\n\nconst getHoldings = (connection: Connection, accounts: string[]) => {\n  return accounts.map((acc) =>\n    cache.queryAccount(connection, new PublicKey(acc))\n  );\n};\n\nconst toPoolInfo = (item: any, program: PublicKey) => {\n  const mint = new PublicKey(item.data.tokenPool);\n  return {\n    pubkeys: {\n      account: item.pubkey,\n      program: program,\n      mint,\n      holdingMints: [] as PublicKey[],\n      holdingAccounts: [item.data.tokenAccountA, item.data.tokenAccountB].map(\n        (a) => new PublicKey(a)\n      ),\n    },\n    legacy: false,\n    raw: item,\n  } as PoolInfo;\n};\n\nexport const usePools = () => {\n  const connection = useConnection();\n  const [pools, setPools] = useState<PoolInfo[]>([]);\n\n  // initial query\n  useEffect(() => {\n    setPools([]);\n\n    const queryPools = async (swapId: PublicKey, isLegacy = false) => {\n      let poolsArray: PoolInfo[] = [];\n      (await connection.getProgramAccounts(swapId))\n        .filter(\n          (item) =>\n            item.account.data.length === TokenSwapLayout.span ||\n            item.account.data.length === TokenSwapLayoutLegacyV0.span\n        )\n        .map((item) => {\n          let result = {\n            data: undefined as any,\n            account: item.account,\n            pubkey: item.pubkey,\n            init: async () => {},\n          };\n\n          // handling of legacy layout can be removed soon...\n          if (item.account.data.length === TokenSwapLayoutLegacyV0.span) {\n            result.data = TokenSwapLayoutLegacyV0.decode(item.account.data);\n            let pool = toPoolInfo(result, swapId);\n            pool.legacy = isLegacy;\n            poolsArray.push(pool as PoolInfo);\n\n            result.init = async () => {\n              try {\n                // TODO: this is not great\n                // Ideally SwapLayout stores hash of all the mints to make finding of pool for a pair easier\n                const holdings = await Promise.all(\n                  getHoldings(connection, [\n                    result.data.tokenAccountA,\n                    result.data.tokenAccountB,\n                  ])\n                );\n\n                pool.pubkeys.holdingMints = [\n                  holdings[0].info.mint,\n                  holdings[1].info.mint,\n                ] as PublicKey[];\n              } catch (err) {\n                console.log(err);\n              }\n            };\n          } else {\n            result.data = TokenSwapLayout.decode(item.account.data);\n            let pool = toPoolInfo(result, swapId);\n            pool.legacy = isLegacy;\n            pool.pubkeys.feeAccount = new PublicKey(result.data.feeAccount);\n            pool.pubkeys.holdingMints = [\n              new PublicKey(result.data.mintA),\n              new PublicKey(result.data.mintB),\n            ] as PublicKey[];\n\n            poolsArray.push(pool as PoolInfo);\n          }\n\n          return result;\n        });\n\n      const toQuery = poolsArray\n        .map(\n          (p) =>\n            [\n              ...p.pubkeys.holdingAccounts.map((h) => h.toBase58()),\n              ...p.pubkeys.holdingMints.map((h) => h.toBase58()),\n              p.pubkeys.feeAccount?.toBase58(), // used to calculate volume aproximation\n              p.pubkeys.mint.toBase58(),\n            ].filter((p) => p) as string[]\n        )\n        .flat();\n\n      // This will pre-cache all accounts used by pools\n      // All those accounts are updated whenever there is a change\n      await getMultipleAccounts(connection, toQuery, \"single\").then(\n        ({ keys, array }) => {\n          return array.map((obj, index) => {\n            const pubKey = new PublicKey(keys[index]);\n            if (obj.data.length === AccountLayout.span) {\n              return cache.addAccount(pubKey, obj);\n            } else if (obj.data.length === MintLayout.span) {\n              return cache.addMint(pubKey, obj);\n            }\n\n            return obj;\n          }) as any[];\n        }\n      );\n\n      return poolsArray;\n    };\n\n    Promise.all([\n      queryPools(programIds().swap),\n      ...programIds().swap_legacy.map((leg) => queryPools(leg, true)),\n    ]).then((all) => {\n      setPools(all.flat());\n    });\n  }, [connection]);\n\n  useEffect(() => {\n    const subID = connection.onProgramAccountChange(\n      programIds().swap,\n      async (info) => {\n        const id = (info.accountId as unknown) as string;\n        if (info.accountInfo.data.length === TokenSwapLayout.span) {\n          const account = info.accountInfo;\n          const updated = {\n            data: TokenSwapLayout.decode(account.data),\n            account: account,\n            pubkey: new PublicKey(id),\n          };\n\n          const index =\n            pools &&\n            pools.findIndex((p) => p.pubkeys.account.toBase58() === id);\n          if (index && index >= 0 && pools) {\n            // TODO: check if account is empty?\n\n            const filtered = pools.filter((p, i) => i !== index);\n            setPools([...filtered, toPoolInfo(updated, programIds().swap)]);\n          } else {\n            let pool = toPoolInfo(updated, programIds().swap);\n\n            pool.pubkeys.feeAccount = new PublicKey(updated.data.feeAccount);\n            pool.pubkeys.holdingMints = [\n              new PublicKey(updated.data.mintA),\n              new PublicKey(updated.data.mintB),\n            ] as PublicKey[];\n\n            setPools([...pools, pool]);\n          }\n        }\n      },\n      \"singleGossip\"\n    );\n\n    return () => {\n      connection.removeProgramAccountChangeListener(subID);\n    };\n  }, [connection, pools]);\n\n  return { pools };\n};\n\nexport const usePoolForBasket = (mints: (string | undefined)[]) => {\n  const connection = useConnection();\n  const { pools } = useCachedPool();\n  const [pool, setPool] = useState<PoolInfo>();\n  const sortedMints = useMemo(() => [...mints].sort(), [...mints]);\n  useEffect(() => {\n    (async () => {\n      // reset pool during query\n      setPool(undefined);\n\n      let matchingPool = pools\n        .filter((p) => !p.legacy)\n        .filter((p) =>\n          p.pubkeys.holdingMints\n            .map((a) => a.toBase58())\n            .sort()\n            .every((address, i) => address === sortedMints[i])\n        );\n\n      for (let i = 0; i < matchingPool.length; i++) {\n        const p = matchingPool[i];\n\n        const account = await cache.queryAccount(\n          connection,\n          p.pubkeys.holdingAccounts[0]\n        );\n\n        if (!account.info.amount.eqn(0)) {\n          setPool(p);\n          return;\n        }\n      }\n    })();\n  }, [connection, sortedMints, pools]);\n\n  return pool;\n};\n\nexport const useOwnedPools = () => {\n  const { pools } = useCachedPool();\n  const { userAccounts } = useUserAccounts();\n\n  const ownedPools = useMemo(() => {\n    const map = userAccounts.reduce((acc, item) => {\n      const key = item.info.mint.toBase58();\n      acc.set(key, [...(acc.get(key) || []), item]);\n      return acc;\n    }, new Map<string, TokenAccount[]>());\n\n    return pools\n      .filter((p) => map.has(p.pubkeys.mint.toBase58()))\n      .map((item) => {\n        let feeAccount = item.pubkeys.feeAccount?.toBase58();\n        return map.get(item.pubkeys.mint.toBase58())?.map((a) => {\n          return {\n            account: a as TokenAccount,\n            isFeeAccount: feeAccount === a.pubkey.toBase58(),\n            pool: item,\n          };\n        }) as {\n          account: TokenAccount;\n          isFeeAccount: boolean;\n          pool: PoolInfo;\n        }[];\n      })\n      .flat();\n  }, [pools, userAccounts]);\n\n  return ownedPools;\n};\n\n// Allow for this much price movement in the pool before adding liquidity to the pool aborts\nconst SLIPPAGE = 0.005;\n\nasync function _addLiquidityExistingPool(\n  pool: PoolInfo,\n  components: LiquidityComponent[],\n  connection: Connection,\n  wallet: any\n) {\n  notify({\n    message: \"Adding Liquidity...\",\n    description: \"Please review transactions to approve.\",\n    type: \"warn\",\n  });\n\n  const poolMint = await cache.queryMint(connection, pool.pubkeys.mint);\n  if (!poolMint.mintAuthority) {\n    throw new Error(\"Mint doesnt have authority\");\n  }\n\n  if (!pool.pubkeys.feeAccount) {\n    throw new Error(\"Invald fee account\");\n  }\n\n  const accountA = await cache.queryAccount(\n    connection,\n    pool.pubkeys.holdingAccounts[0]\n  );\n  const accountB = await cache.queryAccount(\n    connection,\n    pool.pubkeys.holdingAccounts[1]\n  );\n\n  const reserve0 = accountA.info.amount.toNumber();\n  const reserve1 = accountB.info.amount.toNumber();\n  const fromA =\n    accountA.info.mint.toBase58() === components[0].mintAddress\n      ? components[0]\n      : components[1];\n  const fromB = fromA === components[0] ? components[1] : components[0];\n\n  if (!fromA.account || !fromB.account) {\n    throw new Error(\"Missing account info.\");\n  }\n\n  const supply = poolMint.supply.toNumber();\n  const authority = poolMint.mintAuthority;\n\n  // Uniswap whitepaper: https://uniswap.org/whitepaper.pdf\n  // see: https://uniswap.org/docs/v2/advanced-topics/pricing/\n  // as well as native uniswap v2 oracle: https://uniswap.org/docs/v2/core-concepts/oracles/\n  const amount0 = fromA.amount;\n  const amount1 = fromB.amount;\n\n  const liquidity = Math.min(\n    (amount0 * (1 - SLIPPAGE) * supply) / reserve0,\n    (amount1 * (1 - SLIPPAGE) * supply) / reserve1\n  );\n  const instructions: TransactionInstruction[] = [];\n  const cleanupInstructions: TransactionInstruction[] = [];\n\n  const signers: Account[] = [];\n\n  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(\n    AccountLayout.span\n  );\n  const fromKeyA = getWrappedAccount(\n    instructions,\n    cleanupInstructions,\n    fromA.account,\n    wallet.publicKey,\n    amount0 + accountRentExempt,\n    signers\n  );\n  const fromKeyB = getWrappedAccount(\n    instructions,\n    cleanupInstructions,\n    fromB.account,\n    wallet.publicKey,\n    amount1 + accountRentExempt,\n    signers\n  );\n\n  let toAccount = findOrCreateAccountByMint(\n    wallet.publicKey,\n    wallet.publicKey,\n    instructions,\n    [],\n    accountRentExempt,\n    pool.pubkeys.mint,\n    signers,\n    new Set<string>([pool.pubkeys.feeAccount.toBase58()])\n  );\n\n  // create approval for transfer transactions\n  instructions.push(\n    Token.createApproveInstruction(\n      programIds().token,\n      fromKeyA,\n      authority,\n      wallet.publicKey,\n      [],\n      amount0\n    )\n  );\n\n  instructions.push(\n    Token.createApproveInstruction(\n      programIds().token,\n      fromKeyB,\n      authority,\n      wallet.publicKey,\n      [],\n      amount1\n    )\n  );\n\n  // depoist\n  instructions.push(\n    depositInstruction(\n      pool.pubkeys.account,\n      authority,\n      fromKeyA,\n      fromKeyB,\n      pool.pubkeys.holdingAccounts[0],\n      pool.pubkeys.holdingAccounts[1],\n      pool.pubkeys.mint,\n      toAccount,\n      pool.pubkeys.program,\n      programIds().token,\n      liquidity,\n      amount0,\n      amount1\n    )\n  );\n\n  let tx = await sendTransaction(\n    connection,\n    wallet,\n    instructions.concat(cleanupInstructions),\n    signers\n  );\n\n  notify({\n    message: \"Pool Funded. Happy trading.\",\n    type: \"success\",\n    description: `Transaction - ${tx}`,\n  });\n}\n\nfunction findOrCreateAccountByMint(\n  payer: PublicKey,\n  owner: PublicKey,\n  instructions: TransactionInstruction[],\n  cleanupInstructions: TransactionInstruction[],\n  accountRentExempt: number,\n  mint: PublicKey, // use to identify same type\n  signers: Account[],\n  excluded?: Set<string>\n): PublicKey {\n  const accountToFind = mint.toBase58();\n  const account = getCachedAccount(\n    (acc) =>\n      acc.info.mint.toBase58() === accountToFind &&\n      acc.info.owner.toBase58() === owner.toBase58() &&\n      (excluded === undefined || !excluded.has(acc.pubkey.toBase58()))\n  );\n  const isWrappedSol = accountToFind === WRAPPED_SOL_MINT.toBase58();\n\n  let toAccount: PublicKey;\n  if (account && !isWrappedSol) {\n    toAccount = account.pubkey;\n  } else {\n    // creating depositor pool account\n    const newToAccount = createSplAccount(\n      instructions,\n      payer,\n      accountRentExempt,\n      mint,\n      owner,\n      AccountLayout.span\n    );\n\n    toAccount = newToAccount.publicKey;\n    signers.push(newToAccount);\n\n    if (isWrappedSol) {\n      cleanupInstructions.push(\n        Token.createCloseAccountInstruction(\n          programIds().token,\n          toAccount,\n          payer,\n          payer,\n          []\n        )\n      );\n    }\n  }\n\n  return toAccount;\n}\n\nfunction estimateProceedsFromInput(\n  inputQuantityInPool: number,\n  proceedsQuantityInPool: number,\n  inputAmount: number\n): number {\n  return (\n    (proceedsQuantityInPool * inputAmount) / (inputQuantityInPool + inputAmount)\n  );\n}\n\nfunction estimateInputFromProceeds(\n  inputQuantityInPool: number,\n  proceedsQuantityInPool: number,\n  proceedsAmount: number\n): number | string {\n  if (proceedsAmount >= proceedsQuantityInPool) {\n    return \"Not possible\";\n  }\n\n  return (\n    (inputQuantityInPool * proceedsAmount) /\n    (proceedsQuantityInPool - proceedsAmount)\n  );\n}\n\nexport enum PoolOperation {\n  Add,\n  SwapGivenInput,\n  SwapGivenProceeds,\n}\n\nexport async function calculateDependentAmount(\n  connection: Connection,\n  independent: string,\n  amount: number,\n  pool: PoolInfo,\n  op: PoolOperation\n): Promise<number | string | undefined> {\n  const poolMint = await cache.queryMint(connection, pool.pubkeys.mint);\n  const accountA = await cache.queryAccount(\n    connection,\n    pool.pubkeys.holdingAccounts[0]\n  );\n  const accountB = await cache.queryAccount(\n    connection,\n    pool.pubkeys.holdingAccounts[1]\n  );\n  if (!poolMint.mintAuthority) {\n    throw new Error(\"Mint doesnt have authority\");\n  }\n\n  if (poolMint.supply.eqn(0)) {\n    return;\n  }\n\n  const mintA = await cache.queryMint(connection, accountA.info.mint);\n  const mintB = await cache.queryMint(connection, accountB.info.mint);\n\n  if (!mintA || !mintB) {\n    return;\n  }\n\n  const isFirstIndependent = accountA.info.mint.toBase58() === independent;\n  const depPrecision = Math.pow(\n    10,\n    isFirstIndependent ? mintB.decimals : mintA.decimals\n  );\n  const indPrecision = Math.pow(\n    10,\n    isFirstIndependent ? mintA.decimals : mintB.decimals\n  );\n  const indAdjustedAmount = amount * indPrecision;\n\n  let indBasketQuantity = (isFirstIndependent\n    ? accountA\n    : accountB\n  ).info.amount.toNumber();\n  let depBasketQuantity = (isFirstIndependent\n    ? accountB\n    : accountA\n  ).info.amount.toNumber();\n\n  var depAdjustedAmount;\n  switch (+op) {\n    case PoolOperation.Add:\n      {\n        depAdjustedAmount =\n          (depBasketQuantity / indBasketQuantity) * indAdjustedAmount;\n      }\n      break;\n    case PoolOperation.SwapGivenProceeds:\n      {\n        depAdjustedAmount = estimateInputFromProceeds(\n          depBasketQuantity,\n          indBasketQuantity,\n          indAdjustedAmount\n        );\n      }\n      break;\n    case PoolOperation.SwapGivenInput:\n      {\n        depAdjustedAmount = estimateProceedsFromInput(\n          indBasketQuantity,\n          depBasketQuantity,\n          indAdjustedAmount\n        );\n      }\n      break;\n  }\n  if (typeof depAdjustedAmount === \"string\") {\n    return depAdjustedAmount;\n  }\n  if (depAdjustedAmount === undefined) {\n    return undefined;\n  }\n  return depAdjustedAmount / depPrecision;\n}\n\n// TODO: add ui to customize curve type\nasync function _addLiquidityNewPool(\n  wallet: any,\n  connection: Connection,\n  components: LiquidityComponent[],\n  options: PoolConfig\n) {\n  notify({\n    message: \"Creating new pool...\",\n    description: \"Please review transactions to approve.\",\n    type: \"warn\",\n  });\n\n  if (components.some((c) => !c.account)) {\n    notify({\n      message: \"You need to have balance for all legs in the basket...\",\n      description: \"Please review inputs.\",\n      type: \"error\",\n    });\n    return;\n  }\n\n  let instructions: TransactionInstruction[] = [];\n  let cleanupInstructions: TransactionInstruction[] = [];\n\n  const liquidityTokenAccount = new Account();\n  // Create account for pool liquidity token\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: wallet.publicKey,\n      newAccountPubkey: liquidityTokenAccount.publicKey,\n      lamports: await connection.getMinimumBalanceForRentExemption(\n        MintLayout.span\n      ),\n      space: MintLayout.span,\n      programId: programIds().token,\n    })\n  );\n\n  const tokenSwapAccount = new Account();\n\n  const [authority, nonce] = await PublicKey.findProgramAddress(\n    [tokenSwapAccount.publicKey.toBuffer()],\n    programIds().swap\n  );\n\n  // create mint for pool liquidity token\n  instructions.push(\n    Token.createInitMintInstruction(\n      programIds().token,\n      liquidityTokenAccount.publicKey,\n      LIQUIDITY_TOKEN_PRECISION,\n      // pass control of liquidity mint to swap program\n      authority,\n      // swap program can freeze liquidity token mint\n      null\n    )\n  );\n\n  // Create holding accounts for\n  const accountRentExempt = await connection.getMinimumBalanceForRentExemption(\n    AccountLayout.span\n  );\n  const holdingAccounts: Account[] = [];\n  let signers: Account[] = [];\n\n  components.forEach((leg) => {\n    if (!leg.account) {\n      return;\n    }\n\n    const mintPublicKey = leg.account.info.mint;\n    // component account to store tokens I of N in liquidity poll\n    holdingAccounts.push(\n      createSplAccount(\n        instructions,\n        wallet.publicKey,\n        accountRentExempt,\n        mintPublicKey,\n        authority,\n        AccountLayout.span\n      )\n    );\n  });\n\n  // creating depositor pool account\n  const depositorAccount = createSplAccount(\n    instructions,\n    wallet.publicKey,\n    accountRentExempt,\n    liquidityTokenAccount.publicKey,\n    wallet.publicKey,\n    AccountLayout.span\n  );\n\n  // creating fee pool account its set from env variable or to creater of the pool\n  // creater of the pool is not allowed in some versions of token-swap program\n  const feeAccount = createSplAccount(\n    instructions,\n    wallet.publicKey,\n    accountRentExempt,\n    liquidityTokenAccount.publicKey,\n    SWAP_PROGRAM_OWNER_FEE_ADDRESS || wallet.publicKey,\n    AccountLayout.span\n  );\n\n  // create all accounts in one transaction\n  let tx = await sendTransaction(connection, wallet, instructions, [\n    liquidityTokenAccount,\n    depositorAccount,\n    feeAccount,\n    ...holdingAccounts,\n    ...signers,\n  ]);\n\n  notify({\n    message: \"Accounts created\",\n    description: `Transaction ${tx}`,\n    type: \"success\",\n  });\n\n  notify({\n    message: \"Adding Liquidity...\",\n    description: \"Please review transactions to approve.\",\n    type: \"warn\",\n  });\n\n  signers = [];\n  instructions = [];\n  cleanupInstructions = [];\n\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: wallet.publicKey,\n      newAccountPubkey: tokenSwapAccount.publicKey,\n      lamports: await connection.getMinimumBalanceForRentExemption(\n        TokenSwapLayout.span\n      ),\n      space: TokenSwapLayout.span,\n      programId: programIds().swap,\n    })\n  );\n\n  components.forEach((leg, i) => {\n    if (!leg.account) {\n      return;\n    }\n\n    // create temporary account for wrapped sol to perform transfer\n    const from = getWrappedAccount(\n      instructions,\n      cleanupInstructions,\n      leg.account,\n      wallet.publicKey,\n      leg.amount + accountRentExempt,\n      signers\n    );\n\n    instructions.push(\n      Token.createTransferInstruction(\n        programIds().token,\n        from,\n        holdingAccounts[i].publicKey,\n        wallet.publicKey,\n        [],\n        leg.amount\n      )\n    );\n  });\n\n  instructions.push(\n    createInitSwapInstruction(\n      tokenSwapAccount,\n      authority,\n      holdingAccounts[0].publicKey,\n      holdingAccounts[1].publicKey,\n      liquidityTokenAccount.publicKey,\n      feeAccount.publicKey,\n      depositorAccount.publicKey,\n      programIds().token,\n      programIds().swap,\n      nonce,\n      options.curveType,\n      options.tradeFeeNumerator,\n      options.tradeFeeDenominator,\n      options.ownerTradeFeeNumerator,\n      options.ownerTradeFeeDenominator,\n      options.ownerWithdrawFeeNumerator,\n      options.ownerWithdrawFeeDenominator\n    )\n  );\n\n  // All instructions didn't fit in single transaction\n  // initialize and provide inital liquidity to swap in 2nd (this prevents loss of funds)\n  tx = await sendTransaction(\n    connection,\n    wallet,\n    instructions.concat(cleanupInstructions),\n    [tokenSwapAccount, ...signers]\n  );\n\n  notify({\n    message: \"Pool Funded. Happy trading.\",\n    type: \"success\",\n    description: `Transaction - ${tx}`,\n  });\n}\n\nfunction getWrappedAccount(\n  instructions: TransactionInstruction[],\n  cleanupInstructions: TransactionInstruction[],\n  toCheck: TokenAccount,\n  payer: PublicKey,\n  amount: number,\n  signers: Account[]\n) {\n  if (!toCheck.info.isNative) {\n    return toCheck.pubkey;\n  }\n\n  const account = new Account();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: amount,\n      space: AccountLayout.span,\n      programId: programIds().token,\n    })\n  );\n\n  instructions.push(\n    Token.createInitAccountInstruction(\n      programIds().token,\n      WRAPPED_SOL_MINT,\n      account.publicKey,\n      payer\n    )\n  );\n\n  cleanupInstructions.push(\n    Token.createCloseAccountInstruction(\n      programIds().token,\n      account.publicKey,\n      payer,\n      payer,\n      []\n    )\n  );\n\n  signers.push(account);\n\n  return account.publicKey;\n}\n\nfunction createSplAccount(\n  instructions: TransactionInstruction[],\n  payer: PublicKey,\n  accountRentExempt: number,\n  mint: PublicKey,\n  owner: PublicKey,\n  space: number\n) {\n  const account = new Account();\n  instructions.push(\n    SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: account.publicKey,\n      lamports: accountRentExempt,\n      space,\n      programId: programIds().token,\n    })\n  );\n\n  instructions.push(\n    Token.createInitAccountInstruction(\n      programIds().token,\n      mint,\n      account.publicKey,\n      owner\n    )\n  );\n\n  return account;\n}\n"]},"metadata":{},"sourceType":"module"}