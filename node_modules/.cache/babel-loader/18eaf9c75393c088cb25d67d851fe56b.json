{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Slab = exports.SLAB_LAYOUT = void 0;\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar buffer_layout_1 = require(\"buffer-layout\");\n\nvar layout_1 = require(\"./layout\");\n\nvar SLAB_HEADER_LAYOUT = buffer_layout_1.struct([// Number of modified slab nodes\nbuffer_layout_1.u32('bumpIndex'), layout_1.zeros(4), // Linked list of unused nodes\nbuffer_layout_1.u32('freeListLen'), layout_1.zeros(4), buffer_layout_1.u32('freeListHead'), buffer_layout_1.u32('root'), buffer_layout_1.u32('leafCount'), layout_1.zeros(4)], 'header');\nvar SLAB_NODE_LAYOUT = buffer_layout_1.union(buffer_layout_1.u32('tag'), buffer_layout_1.blob(68), 'node');\nSLAB_NODE_LAYOUT.addVariant(0, buffer_layout_1.struct([]), 'uninitialized');\nSLAB_NODE_LAYOUT.addVariant(1, buffer_layout_1.struct([// Only the first prefixLen high-order bits of key are meaningful\nbuffer_layout_1.u32('prefixLen'), layout_1.u128('key'), buffer_layout_1.seq(buffer_layout_1.u32(), 2, 'children')]), 'innerNode');\nSLAB_NODE_LAYOUT.addVariant(2, buffer_layout_1.struct([buffer_layout_1.u8('ownerSlot'), buffer_layout_1.u8('feeTier'), buffer_layout_1.blob(2), layout_1.u128('key'), layout_1.publicKeyLayout('owner'), layout_1.u64('quantity'), layout_1.u64('clientOrderId')]), 'leafNode');\nSLAB_NODE_LAYOUT.addVariant(3, buffer_layout_1.struct([buffer_layout_1.u32('next')]), 'freeNode');\nSLAB_NODE_LAYOUT.addVariant(4, buffer_layout_1.struct([]), 'lastFreeNode');\nexports.SLAB_LAYOUT = buffer_layout_1.struct([SLAB_HEADER_LAYOUT, buffer_layout_1.seq(SLAB_NODE_LAYOUT, buffer_layout_1.offset(SLAB_HEADER_LAYOUT.layoutFor('bumpIndex'), SLAB_HEADER_LAYOUT.offsetOf('bumpIndex') - SLAB_HEADER_LAYOUT.span), 'nodes')]);\n\nvar Slab = /*#__PURE__*/function () {\n  function Slab(header, nodes) {\n    _classCallCheck(this, Slab);\n\n    this.header = header;\n    this.nodes = nodes;\n  }\n\n  _createClass(Slab, [{\n    key: \"get\",\n    value: function get(searchKey) {\n      if (this.header.leafCount === 0) {\n        return null;\n      }\n\n      if (!(searchKey instanceof bn_js_1.default)) {\n        searchKey = new bn_js_1.default(searchKey);\n      }\n\n      var index = this.header.root;\n\n      while (true) {\n        var _this$nodes$index = this.nodes[index],\n            leafNode = _this$nodes$index.leafNode,\n            innerNode = _this$nodes$index.innerNode;\n\n        if (leafNode) {\n          if (leafNode.key.eq(searchKey)) {\n            return leafNode;\n          }\n\n          return null;\n        } else if (innerNode) {\n          if (!innerNode.key.xor(searchKey).iushrn(128 - innerNode.prefixLen).isZero()) {\n            return null;\n          }\n\n          index = innerNode.children[searchKey.testn(128 - innerNode.prefixLen - 1) ? 1 : 0];\n        } else {\n          throw new Error('Invalid slab');\n        }\n      }\n    }\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      return this.items(false);\n    }\n  }, {\n    key: \"items\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function items() {\n      var descending,\n          stack,\n          index,\n          _this$nodes$index2,\n          leafNode,\n          innerNode,\n          _args = arguments;\n\n      return _regeneratorRuntime.wrap(function items$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              descending = _args.length > 0 && _args[0] !== undefined ? _args[0] : false;\n\n              if (!(this.header.leafCount === 0)) {\n                _context.next = 3;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 3:\n              stack = [this.header.root];\n\n            case 4:\n              if (!(stack.length > 0)) {\n                _context.next = 15;\n                break;\n              }\n\n              index = stack.pop();\n              _this$nodes$index2 = this.nodes[index], leafNode = _this$nodes$index2.leafNode, innerNode = _this$nodes$index2.innerNode;\n\n              if (!leafNode) {\n                _context.next = 12;\n                break;\n              }\n\n              _context.next = 10;\n              return leafNode;\n\n            case 10:\n              _context.next = 13;\n              break;\n\n            case 12:\n              if (innerNode) {\n                if (descending) {\n                  stack.push(innerNode.children[0], innerNode.children[1]);\n                } else {\n                  stack.push(innerNode.children[1], innerNode.children[0]);\n                }\n              }\n\n            case 13:\n              _context.next = 4;\n              break;\n\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, items, this);\n    })\n  }], [{\n    key: \"decode\",\n    value: function decode(buffer) {\n      return exports.SLAB_LAYOUT.decode(buffer);\n    }\n  }]);\n\n  return Slab;\n}();\n\nexports.Slab = Slab;\nlayout_1.setLayoutDecoder(exports.SLAB_LAYOUT, function (_ref) {\n  var header = _ref.header,\n      nodes = _ref.nodes;\n  return new Slab(header, nodes);\n});","map":{"version":3,"sources":["../src/slab.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Slab = exports.SLAB_LAYOUT = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst buffer_layout_1 = require(\"buffer-layout\");\nconst layout_1 = require(\"./layout\");\nconst SLAB_HEADER_LAYOUT = buffer_layout_1.struct([\n    // Number of modified slab nodes\n    buffer_layout_1.u32('bumpIndex'),\n    layout_1.zeros(4),\n    // Linked list of unused nodes\n    buffer_layout_1.u32('freeListLen'),\n    layout_1.zeros(4),\n    buffer_layout_1.u32('freeListHead'),\n    buffer_layout_1.u32('root'),\n    buffer_layout_1.u32('leafCount'),\n    layout_1.zeros(4),\n], 'header');\nconst SLAB_NODE_LAYOUT = buffer_layout_1.union(buffer_layout_1.u32('tag'), buffer_layout_1.blob(68), 'node');\nSLAB_NODE_LAYOUT.addVariant(0, buffer_layout_1.struct([]), 'uninitialized');\nSLAB_NODE_LAYOUT.addVariant(1, buffer_layout_1.struct([\n    // Only the first prefixLen high-order bits of key are meaningful\n    buffer_layout_1.u32('prefixLen'),\n    layout_1.u128('key'),\n    buffer_layout_1.seq(buffer_layout_1.u32(), 2, 'children'),\n]), 'innerNode');\nSLAB_NODE_LAYOUT.addVariant(2, buffer_layout_1.struct([\n    buffer_layout_1.u8('ownerSlot'),\n    buffer_layout_1.u8('feeTier'),\n    buffer_layout_1.blob(2),\n    layout_1.u128('key'),\n    layout_1.publicKeyLayout('owner'),\n    layout_1.u64('quantity'),\n    layout_1.u64('clientOrderId'),\n]), 'leafNode');\nSLAB_NODE_LAYOUT.addVariant(3, buffer_layout_1.struct([buffer_layout_1.u32('next')]), 'freeNode');\nSLAB_NODE_LAYOUT.addVariant(4, buffer_layout_1.struct([]), 'lastFreeNode');\nexports.SLAB_LAYOUT = buffer_layout_1.struct([\n    SLAB_HEADER_LAYOUT,\n    buffer_layout_1.seq(SLAB_NODE_LAYOUT, buffer_layout_1.offset(SLAB_HEADER_LAYOUT.layoutFor('bumpIndex'), SLAB_HEADER_LAYOUT.offsetOf('bumpIndex') - SLAB_HEADER_LAYOUT.span), 'nodes'),\n]);\nclass Slab {\n    constructor(header, nodes) {\n        this.header = header;\n        this.nodes = nodes;\n    }\n    static decode(buffer) {\n        return exports.SLAB_LAYOUT.decode(buffer);\n    }\n    get(searchKey) {\n        if (this.header.leafCount === 0) {\n            return null;\n        }\n        if (!(searchKey instanceof bn_js_1.default)) {\n            searchKey = new bn_js_1.default(searchKey);\n        }\n        let index = this.header.root;\n        while (true) {\n            const { leafNode, innerNode } = this.nodes[index];\n            if (leafNode) {\n                if (leafNode.key.eq(searchKey)) {\n                    return leafNode;\n                }\n                return null;\n            }\n            else if (innerNode) {\n                if (!innerNode.key\n                    .xor(searchKey)\n                    .iushrn(128 - innerNode.prefixLen)\n                    .isZero()) {\n                    return null;\n                }\n                index =\n                    innerNode.children[searchKey.testn(128 - innerNode.prefixLen - 1) ? 1 : 0];\n            }\n            else {\n                throw new Error('Invalid slab');\n            }\n        }\n    }\n    [Symbol.iterator]() {\n        return this.items(false);\n    }\n    *items(descending = false) {\n        if (this.header.leafCount === 0) {\n            return;\n        }\n        const stack = [this.header.root];\n        while (stack.length > 0) {\n            const index = stack.pop();\n            const { leafNode, innerNode } = this.nodes[index];\n            if (leafNode) {\n                yield leafNode;\n            }\n            else if (innerNode) {\n                if (descending) {\n                    stack.push(innerNode.children[0], innerNode.children[1]);\n                }\n                else {\n                    stack.push(innerNode.children[1], innerNode.children[0]);\n                }\n            }\n        }\n    }\n}\nexports.Slab = Slab;\nlayout_1.setLayoutDecoder(exports.SLAB_LAYOUT, ({ header, nodes }) => new Slab(header, nodes));\n//# sourceMappingURL=slab.js.map"]},"metadata":{},"sourceType":"script"}