{"ast":null,"code":"import _regeneratorRuntime from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/yclnl/yclnl.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport assert from 'assert';\nimport BN from 'bn.js';\nimport { blob, struct, u8, nu64 } from 'buffer-layout';\nimport { sendAndConfirmTransaction as sendAndConfirmTransaction$1, TransactionInstruction, Transaction, SystemProgram, PublicKey } from '@solana/web3.js';\n/**\n * Layout for a public key\n */\n\nvar publicKey = function publicKey() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'publicKey';\n  return blob(32, property);\n};\n/**\n * Layout for a 64bit unsigned value\n */\n\n\nvar uint64 = function uint64() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'uint64';\n  return blob(8, property);\n};\n\nfunction sendAndConfirmTransaction(title, connection, transaction) {\n  for (var _len = arguments.length, signers = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    signers[_key - 3] = arguments[_key];\n  }\n\n  return sendAndConfirmTransaction$1(connection, transaction, signers, {\n    skipPreflight: false,\n    commitment: 'recent',\n    preflightCommitment: 'recent'\n  });\n}\n/**\n * Some amount of tokens\n */\n\n\nvar Numberu64 = /*#__PURE__*/function (_BN) {\n  _inherits(Numberu64, _BN);\n\n  var _super = _createSuper(Numberu64);\n\n  function Numberu64() {\n    _classCallCheck(this, Numberu64);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Numberu64, [{\n    key: \"toBuffer\",\n\n    /**\n     * Convert to Buffer representation\n     */\n    value: function toBuffer() {\n      var a = _get(_getPrototypeOf(Numberu64.prototype), \"toArray\", this).call(this).reverse();\n\n      var b = Buffer.from(a);\n\n      if (b.length === 8) {\n        return b;\n      }\n\n      assert(b.length < 8, 'Numberu64 too large');\n      var zeroPad = Buffer.alloc(8);\n      b.copy(zeroPad);\n      return zeroPad;\n    }\n    /**\n     * Construct a Numberu64 from Buffer representation\n     */\n\n  }], [{\n    key: \"fromBuffer\",\n    value: function fromBuffer(buffer) {\n      assert(buffer.length === 8, \"Invalid buffer length: \".concat(buffer.length));\n      return new BN(_toConsumableArray(buffer).reverse().map(function (i) {\n        return \"00\".concat(i.toString(16)).slice(-2);\n      }).join(''), 16);\n    }\n  }]);\n\n  return Numberu64;\n}(BN);\n/**\n * Information about a token swap\n */\n\n/**\n * @private\n */\n\n\nvar TokenSwapLayout = struct([u8('isInitialized'), u8('nonce'), publicKey('tokenAccountA'), publicKey('tokenAccountB'), publicKey('tokenPool'), uint64('feesNumerator'), uint64('feesDenominator')]);\n/**\n * An ERC20-like Token\n */\n\nvar TokenSwap = /*#__PURE__*/function () {\n  /**\n   * @private\n   */\n\n  /**\n   * The public key identifying this token\n   */\n\n  /**\n   * Program Identifier for the Token Swap program\n   */\n\n  /**\n   * Fee payer\n   */\n\n  /**\n   * Create a Token object attached to the specific token\n   *\n   * @param connection The connection to use\n   * @param token Public key of the token\n   * @param programId Optional token programId, uses the system programId by default\n   * @param payer Payer of fees\n   */\n  function TokenSwap(connection, tokenSwap, programId, payer) {\n    _classCallCheck(this, TokenSwap);\n\n    _defineProperty(this, \"connection\", void 0);\n\n    _defineProperty(this, \"tokenSwap\", void 0);\n\n    _defineProperty(this, \"programId\", void 0);\n\n    _defineProperty(this, \"payer\", void 0);\n\n    Object.assign(this, {\n      connection: connection,\n      tokenSwap: tokenSwap,\n      programId: programId,\n      payer: payer\n    });\n  }\n  /**\n   * Get the minimum balance for the token swap account to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n\n\n  _createClass(TokenSwap, [{\n    key: \"getInfo\",\n\n    /**\n     * Retrieve tokenSwap information\n     */\n    value: function () {\n      var _getInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var accountInfo, data, tokenSwapInfo;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.connection.getAccountInfo(this.tokenSwap);\n\n              case 2:\n                accountInfo = _context.sent;\n\n                if (!(accountInfo === null)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new Error('Failed to find token swap account');\n\n              case 5:\n                if (accountInfo.owner.equals(this.programId)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Invalid token swap owner: \".concat(JSON.stringify(accountInfo.owner)));\n\n              case 7:\n                data = Buffer.from(accountInfo.data);\n                tokenSwapInfo = TokenSwapLayout.decode(data);\n\n                if (tokenSwapInfo.isInitialized) {\n                  _context.next = 11;\n                  break;\n                }\n\n                throw new Error(\"Invalid token swap state\");\n\n              case 11:\n                // already properly filled in\n                // tokenSwapInfo.nonce = tokenSwapInfo.nonce;\n                tokenSwapInfo.tokenAccountA = new PublicKey(tokenSwapInfo.tokenAccountA);\n                tokenSwapInfo.tokenAccountB = new PublicKey(tokenSwapInfo.tokenAccountB);\n                tokenSwapInfo.tokenPool = new PublicKey(tokenSwapInfo.tokenPool);\n                tokenSwapInfo.feesNumerator = Numberu64.fromBuffer(tokenSwapInfo.feesNumerator);\n                tokenSwapInfo.feesDenominator = Numberu64.fromBuffer(tokenSwapInfo.feesDenominator);\n                tokenSwapInfo.feeRatio = tokenSwapInfo.feesNumerator.toNumber() / tokenSwapInfo.feesDenominator.toNumber();\n                return _context.abrupt(\"return\", tokenSwapInfo);\n\n              case 18:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getInfo() {\n        return _getInfo.apply(this, arguments);\n      }\n\n      return getInfo;\n    }()\n    /**\n     * Swap the tokens in the pool\n     *\n     * @param authority Authority\n     * @param source Source account\n     * @param swapSource Base account to swap into, must be a source token\n     * @param swapDestination Base account to swap from, must be a destination token\n     * @param destination Destination token account\n     * @param tokenProgramId Token program id\n     * @param amount Amount to transfer from source account\n     */\n\n  }, {\n    key: \"swap\",\n    value: function () {\n      var _swap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(authority, source, swapSource, swapDestination, destination, tokenProgramId, amountIn, minimumAmountOut) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return sendAndConfirmTransaction('swap', this.connection, new Transaction().add(TokenSwap.swapInstruction(this.tokenSwap, authority, source, swapSource, swapDestination, destination, this.programId, tokenProgramId, amountIn, minimumAmountOut)), this.payer);\n\n              case 2:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function swap(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8) {\n        return _swap.apply(this, arguments);\n      }\n\n      return swap;\n    }()\n  }, {\n    key: \"deposit\",\n\n    /**\n     * Deposit some tokens into the pool\n     *\n     * @param authority Authority\n     * @param sourceA Source account A\n     * @param sourceB Source account B\n     * @param intoA Base account A to deposit into\n     * @param intoB Base account B to deposit into\n     * @param poolToken Pool token\n     * @param poolAccount Pool account to deposit the generated tokens\n     * @param tokenProgramId Token program id\n     * @param amount Amount of pool token to deposit, token A and B amount are set by the exchange rate relative to the total pool token supply\n     */\n    value: function () {\n      var _deposit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(authority, sourceA, sourceB, intoA, intoB, poolToken, poolAccount, tokenProgramId, poolTokenAmount, maximumTokenA, maximumTokenB) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return sendAndConfirmTransaction('deposit', this.connection, new Transaction().add(TokenSwap.depositInstruction(this.tokenSwap, authority, sourceA, sourceB, intoA, intoB, poolToken, poolAccount, this.programId, tokenProgramId, poolTokenAmount, maximumTokenA, maximumTokenB)), this.payer);\n\n              case 2:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function deposit(_x9, _x10, _x11, _x12, _x13, _x14, _x15, _x16, _x17, _x18, _x19) {\n        return _deposit.apply(this, arguments);\n      }\n\n      return deposit;\n    }()\n  }, {\n    key: \"withdraw\",\n\n    /**\n     * Withdraw the token from the pool at the current ratio\n     *\n     * @param authority Authority\n     * @param sourcePoolAccount Source pool account\n     * @param poolToken Pool token\n     * @param fromA Base account A to withdraw from\n     * @param fromB Base account B to withdraw from\n     * @param userAccountA Token A user account\n     * @param userAccountB token B user account\n     * @param tokenProgramId Token program id\n     * @param amount Amount of pool token to withdraw, token A and B amount are set by the exchange rate relative to the total pool token supply\n     */\n    value: function () {\n      var _withdraw = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(authority, poolMint, sourcePoolAccount, fromA, fromB, userAccountA, userAccountB, tokenProgramId, poolTokenAmount, minimumTokenA, minimumTokenB) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return sendAndConfirmTransaction('withdraw', this.connection, new Transaction().add(TokenSwap.withdrawInstruction(this.tokenSwap, authority, poolMint, sourcePoolAccount, fromA, fromB, userAccountA, userAccountB, this.programId, tokenProgramId, poolTokenAmount, minimumTokenA, minimumTokenB)), this.payer);\n\n              case 2:\n                return _context4.abrupt(\"return\", _context4.sent);\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function withdraw(_x20, _x21, _x22, _x23, _x24, _x25, _x26, _x27, _x28, _x29, _x30) {\n        return _withdraw.apply(this, arguments);\n      }\n\n      return withdraw;\n    }()\n  }], [{\n    key: \"getMinBalanceRentForExemptTokenSwap\",\n    value: function () {\n      var _getMinBalanceRentForExemptTokenSwap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(connection) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return connection.getMinimumBalanceForRentExemption(TokenSwapLayout.span);\n\n              case 2:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function getMinBalanceRentForExemptTokenSwap(_x31) {\n        return _getMinBalanceRentForExemptTokenSwap.apply(this, arguments);\n      }\n\n      return getMinBalanceRentForExemptTokenSwap;\n    }()\n  }, {\n    key: \"createInitSwapInstruction\",\n    value: function createInitSwapInstruction(tokenSwapAccount, authority, nonce, tokenAccountA, tokenAccountB, tokenPool, tokenAccountPool, tokenProgramId, swapProgramId, feeNumerator, feeDenominator) {\n      var keys = [{\n        pubkey: tokenSwapAccount.publicKey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: tokenAccountA,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: tokenAccountB,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: tokenPool,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: tokenAccountPool,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: tokenProgramId,\n        isSigner: false,\n        isWritable: false\n      }];\n      var commandDataLayout = struct([u8('instruction'), nu64('feeNumerator'), nu64('feeDenominator'), u8('nonce')]);\n      var data = Buffer.alloc(1024);\n      {\n        var encodeLength = commandDataLayout.encode({\n          instruction: 0,\n          // InitializeSwap instruction\n          feeNumerator: feeNumerator,\n          feeDenominator: feeDenominator,\n          nonce: nonce\n        }, data);\n        data = data.slice(0, encodeLength);\n      }\n      return new TransactionInstruction({\n        keys: keys,\n        programId: swapProgramId,\n        data: data\n      });\n    }\n    /**\n     * Create a new Token Swap\n     *\n     * @param connection The connection to use\n     * @param payer Pays for the transaction\n     * @param tokenSwapAccount The token swap account\n     * @param authority The authority over the swap and accounts\n     * @param tokenAccountA: The Swap's Token A account\n     * @param tokenAccountB: The Swap's Token B account\n     * @param tokenPool The pool token\n     * @param tokenAccountPool The pool token account\n     * @param tokenProgramId The program id of the token program\n     * @param feeNumerator Numerator of the fee ratio\n     * @param feeDenominator Denominator of the fee ratio\n     * @param swapProgramId Program ID of the token-swap program\n     * @return Token object for the newly minted token, Public key of the account holding the total supply of new tokens\n     */\n\n  }, {\n    key: \"createTokenSwap\",\n    value: function () {\n      var _createTokenSwap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(connection, payer, tokenSwapAccount, authority, tokenAccountA, tokenAccountB, tokenPool, tokenAccountPool, tokenProgramId, nonce, feeNumerator, feeDenominator, swapProgramId) {\n        var transaction, tokenSwap, balanceNeeded, instruction;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                tokenSwap = new TokenSwap(connection, tokenSwapAccount.publicKey, swapProgramId, payer); // Allocate memory for the account\n\n                _context6.next = 3;\n                return TokenSwap.getMinBalanceRentForExemptTokenSwap(connection);\n\n              case 3:\n                balanceNeeded = _context6.sent;\n                transaction = new Transaction();\n                transaction.add(SystemProgram.createAccount({\n                  fromPubkey: payer.publicKey,\n                  newAccountPubkey: tokenSwapAccount.publicKey,\n                  lamports: balanceNeeded,\n                  space: TokenSwapLayout.span,\n                  programId: swapProgramId\n                }));\n                instruction = TokenSwap.createInitSwapInstruction(tokenSwapAccount, authority, nonce, tokenAccountA, tokenAccountB, tokenPool, tokenAccountPool, tokenProgramId, swapProgramId, feeNumerator, feeDenominator);\n                transaction.add(instruction);\n                _context6.next = 10;\n                return sendAndConfirmTransaction('createAccount and InitializeSwap', connection, transaction, payer, tokenSwapAccount);\n\n              case 10:\n                return _context6.abrupt(\"return\", tokenSwap);\n\n              case 11:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function createTokenSwap(_x32, _x33, _x34, _x35, _x36, _x37, _x38, _x39, _x40, _x41, _x42, _x43, _x44) {\n        return _createTokenSwap.apply(this, arguments);\n      }\n\n      return createTokenSwap;\n    }()\n  }, {\n    key: \"swapInstruction\",\n    value: function swapInstruction(tokenSwap, authority, source, swapSource, swapDestination, destination, swapProgramId, tokenProgramId, amountIn, minimumAmountOut) {\n      var dataLayout = struct([u8('instruction'), uint64('amountIn'), uint64('minimumAmountOut')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 1,\n        // Swap instruction\n        amountIn: new Numberu64(amountIn).toBuffer(),\n        minimumAmountOut: new Numberu64(minimumAmountOut).toBuffer()\n      }, data);\n      var keys = [{\n        pubkey: tokenSwap,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: source,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: swapSource,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: swapDestination,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: destination,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: tokenProgramId,\n        isSigner: false,\n        isWritable: false\n      }];\n      return new TransactionInstruction({\n        keys: keys,\n        programId: swapProgramId,\n        data: data\n      });\n    }\n  }, {\n    key: \"depositInstruction\",\n    value: function depositInstruction(tokenSwap, authority, sourceA, sourceB, intoA, intoB, poolToken, poolAccount, swapProgramId, tokenProgramId, poolTokenAmount, maximumTokenA, maximumTokenB) {\n      var dataLayout = struct([u8('instruction'), uint64('poolTokenAmount'), uint64('maximumTokenA'), uint64('maximumTokenB')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 2,\n        // Deposit instruction\n        poolTokenAmount: new Numberu64(poolTokenAmount).toBuffer(),\n        maximumTokenA: new Numberu64(maximumTokenA).toBuffer(),\n        maximumTokenB: new Numberu64(maximumTokenB).toBuffer()\n      }, data);\n      var keys = [{\n        pubkey: tokenSwap,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: sourceA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: sourceB,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: intoA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: intoB,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: poolToken,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: poolAccount,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: tokenProgramId,\n        isSigner: false,\n        isWritable: false\n      }];\n      return new TransactionInstruction({\n        keys: keys,\n        programId: swapProgramId,\n        data: data\n      });\n    }\n  }, {\n    key: \"withdrawInstruction\",\n    value: function withdrawInstruction(tokenSwap, authority, poolMint, sourcePoolAccount, fromA, fromB, userAccountA, userAccountB, swapProgramId, tokenProgramId, poolTokenAmount, minimumTokenA, minimumTokenB) {\n      var dataLayout = struct([u8('instruction'), uint64('poolTokenAmount'), uint64('minimumTokenA'), uint64('minimumTokenB')]);\n      var data = Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 3,\n        // Withdraw instruction\n        poolTokenAmount: new Numberu64(poolTokenAmount).toBuffer(),\n        minimumTokenA: new Numberu64(minimumTokenA).toBuffer(),\n        minimumTokenB: new Numberu64(minimumTokenB).toBuffer()\n      }, data);\n      var keys = [{\n        pubkey: tokenSwap,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authority,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: poolMint,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: sourcePoolAccount,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: fromA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: fromB,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: userAccountA,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: userAccountB,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: tokenProgramId,\n        isSigner: false,\n        isWritable: false\n      }];\n      return new TransactionInstruction({\n        keys: keys,\n        programId: swapProgramId,\n        data: data\n      });\n    }\n  }]);\n\n  return TokenSwap;\n}();\n\nexport { Numberu64, TokenSwap, TokenSwapLayout };","map":{"version":3,"sources":["../client/layout.js","../client/util/send-and-confirm-transaction.js","../client/token-swap.js"],"names":["publicKey","property","BufferLayout","uint64","realSendAndConfirmTransaction","skipPreflight","commitment","preflightCommitment","a","b","Buffer","assert","zeroPad","buffer","i","TokenSwapLayout","Layout","constructor","Object","connection","tokenSwap","programId","payer","keys","pubkey","tokenSwapAccount","isSigner","isWritable","commandDataLayout","data","encodeLength","instruction","feeNumerator","feeDenominator","nonce","balanceNeeded","TokenSwap","transaction","fromPubkey","newAccountPubkey","lamports","space","swapProgramId","sendAndConfirmTransaction","accountInfo","JSON","tokenSwapInfo","Numberu64","dataLayout","amountIn","minimumAmountOut","poolTokenAmount","maximumTokenA","maximumTokenB","minimumTokenA","minimumTokenB"],"mappings":"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","sourcesContent":["// @flow\n\nimport * as BufferLayout from 'buffer-layout';\n\n/**\n * Layout for a public key\n */\nexport const publicKey = (property: string = 'publicKey'): Object => {\n  return BufferLayout.blob(32, property);\n};\n\n/**\n * Layout for a 64bit unsigned value\n */\nexport const uint64 = (property: string = 'uint64'): Object => {\n  return BufferLayout.blob(8, property);\n};\n\n/**\n * Layout for a Rust String type\n */\nexport const rustString = (property: string = 'string'): Object => {\n  const rsl = BufferLayout.struct(\n    [\n      BufferLayout.u32('length'),\n      BufferLayout.u32('lengthPadding'),\n      BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), 'chars'),\n    ],\n    property,\n  );\n  const _decode = rsl.decode.bind(rsl);\n  const _encode = rsl.encode.bind(rsl);\n\n  rsl.decode = (buffer, offset) => {\n    const data = _decode(buffer, offset);\n    return data.chars.toString('utf8');\n  };\n\n  rsl.encode = (str, buffer, offset) => {\n    const data = {\n      chars: Buffer.from(str, 'utf8'),\n    };\n    return _encode(data, buffer, offset);\n  };\n\n  return rsl;\n};\n","// @flow\n\nimport {sendAndConfirmTransaction as realSendAndConfirmTransaction} from '@solana/web3.js';\nimport type {\n  Account,\n  Connection,\n  Transaction,\n  TransactionSignature,\n} from '@solana/web3.js';\n\nexport function sendAndConfirmTransaction(\n  title: string,\n  connection: Connection,\n  transaction: Transaction,\n  ...signers: Array<Account>\n): Promise<TransactionSignature> {\n  return realSendAndConfirmTransaction(connection, transaction, signers, {\n    skipPreflight: false,\n    commitment: 'recent',\n    preflightCommitment: 'recent',\n  });\n}\n","/**\n * @flow\n */\n\nimport assert from 'assert';\nimport BN from 'bn.js';\nimport * as BufferLayout from 'buffer-layout';\nimport type {Connection, TransactionSignature} from '@solana/web3.js';\nimport {\n  Account,\n  PublicKey,\n  SystemProgram,\n  Transaction,\n  TransactionInstruction,\n} from '@solana/web3.js';\n\nimport * as Layout from './layout';\nimport {sendAndConfirmTransaction} from './util/send-and-confirm-transaction';\n\n/**\n * Some amount of tokens\n */\nexport class Numberu64 extends BN {\n  /**\n   * Convert to Buffer representation\n   */\n  toBuffer(): typeof Buffer {\n    const a = super.toArray().reverse();\n    const b = Buffer.from(a);\n    if (b.length === 8) {\n      return b;\n    }\n    assert(b.length < 8, 'Numberu64 too large');\n\n    const zeroPad = Buffer.alloc(8);\n    b.copy(zeroPad);\n    return zeroPad;\n  }\n\n  /**\n   * Construct a Numberu64 from Buffer representation\n   */\n  static fromBuffer(buffer: typeof Buffer): Numberu64 {\n    assert(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);\n    return new BN(\n      [...buffer]\n        .reverse()\n        .map(i => `00${i.toString(16)}`.slice(-2))\n        .join(''),\n      16,\n    );\n  }\n}\n\n/**\n * Information about a token swap\n */\ntype TokenSwapInfo = {|\n  /**\n   * Nonce. Used to generate the valid program address in the program\n   */\n  nonce: number,\n\n  /**\n   * Token A. The Liquidity token is issued against this value.\n   */\n  tokenAccountA: PublicKey,\n\n  /**\n   * Token B\n   */\n  tokenAccountB: PublicKey,\n  /**\n   * Pool tokens are issued when A or B tokens are deposited\n   * Pool tokens can be withdrawn back to the original A or B token\n   */\n  tokenPool: PublicKey,\n\n  /**\n   * Fee numerator\n   */\n  feesNumerator: Numberu64,\n\n  /**\n   * Fee denominator\n   */\n  feesDenominator: Numberu64,\n\n  /**\n   * Fee ratio applied to the input token amount prior to output calculation\n   */\n  feeRatio: number,\n|};\n\n/**\n * @private\n */\nexport const TokenSwapLayout: typeof BufferLayout.Structure = BufferLayout.struct(\n  [\n    BufferLayout.u8('isInitialized'),\n    BufferLayout.u8('nonce'),\n    Layout.publicKey('tokenAccountA'),\n    Layout.publicKey('tokenAccountB'),\n    Layout.publicKey('tokenPool'),\n    Layout.uint64('feesNumerator'),\n    Layout.uint64('feesDenominator'),\n  ],\n);\n\n/**\n * An ERC20-like Token\n */\nexport class TokenSwap {\n  /**\n   * @private\n   */\n  connection: Connection;\n\n  /**\n   * The public key identifying this token\n   */\n  tokenSwap: PublicKey;\n\n  /**\n   * Program Identifier for the Token Swap program\n   */\n  programId: PublicKey;\n\n  /**\n   * Fee payer\n   */\n  payer: Account;\n\n  /**\n   * Create a Token object attached to the specific token\n   *\n   * @param connection The connection to use\n   * @param token Public key of the token\n   * @param programId Optional token programId, uses the system programId by default\n   * @param payer Payer of fees\n   */\n  constructor(\n    connection: Connection,\n    tokenSwap: PublicKey,\n    programId: PublicKey,\n    payer: Account,\n  ) {\n    Object.assign(this, {connection, tokenSwap, programId, payer});\n  }\n\n  /**\n   * Get the minimum balance for the token swap account to be rent exempt\n   *\n   * @return Number of lamports required\n   */\n  static async getMinBalanceRentForExemptTokenSwap(\n    connection: Connection,\n  ): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(\n      TokenSwapLayout.span,\n    );\n  }\n\n  static createInitSwapInstruction(\n    tokenSwapAccount: Account,\n    authority: PublicKey,\n    nonce: number,\n    tokenAccountA: PublicKey,\n    tokenAccountB: PublicKey,\n    tokenPool: PublicKey,\n    tokenAccountPool: PublicKey,\n    tokenProgramId: PublicKey,\n    swapProgramId: PublicKey,\n    feeNumerator: number,\n    feeDenominator: number,\n  ): TransactionInstruction {\n    const keys = [\n      {pubkey: tokenSwapAccount.publicKey, isSigner: false, isWritable: true},\n      {pubkey: authority, isSigner: false, isWritable: false},\n      {pubkey: tokenAccountA, isSigner: false, isWritable: false},\n      {pubkey: tokenAccountB, isSigner: false, isWritable: false},\n      {pubkey: tokenPool, isSigner: false, isWritable: true},\n      {pubkey: tokenAccountPool, isSigner: false, isWritable: true},\n      {pubkey: tokenProgramId, isSigner: false, isWritable: false},\n    ];\n    const commandDataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      BufferLayout.nu64('feeNumerator'),\n      BufferLayout.nu64('feeDenominator'),\n      BufferLayout.u8('nonce'),\n    ]);\n    let data = Buffer.alloc(1024);\n    {\n      const encodeLength = commandDataLayout.encode(\n        {\n          instruction: 0, // InitializeSwap instruction\n          feeNumerator,\n          feeDenominator,\n          nonce,\n        },\n        data,\n      );\n      data = data.slice(0, encodeLength);\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: swapProgramId,\n      data,\n    });\n  }\n\n  /**\n   * Create a new Token Swap\n   *\n   * @param connection The connection to use\n   * @param payer Pays for the transaction\n   * @param tokenSwapAccount The token swap account\n   * @param authority The authority over the swap and accounts\n   * @param tokenAccountA: The Swap's Token A account\n   * @param tokenAccountB: The Swap's Token B account\n   * @param tokenPool The pool token\n   * @param tokenAccountPool The pool token account\n   * @param tokenProgramId The program id of the token program\n   * @param feeNumerator Numerator of the fee ratio\n   * @param feeDenominator Denominator of the fee ratio\n   * @param swapProgramId Program ID of the token-swap program\n   * @return Token object for the newly minted token, Public key of the account holding the total supply of new tokens\n   */\n  static async createTokenSwap(\n    connection: Connection,\n    payer: Account,\n    tokenSwapAccount: Account,\n    authority: PublicKey,\n    tokenAccountA: PublicKey,\n    tokenAccountB: PublicKey,\n    tokenPool: PublicKey,\n    tokenAccountPool: PublicKey,\n    tokenProgramId: PublicKey,\n    nonce: number,\n    feeNumerator: number,\n    feeDenominator: number,\n    swapProgramId: PublicKey,\n  ): Promise<TokenSwap> {\n    let transaction;\n    const tokenSwap = new TokenSwap(\n      connection,\n      tokenSwapAccount.publicKey,\n      swapProgramId,\n      payer,\n    );\n\n    // Allocate memory for the account\n    const balanceNeeded = await TokenSwap.getMinBalanceRentForExemptTokenSwap(\n      connection,\n    );\n    transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: tokenSwapAccount.publicKey,\n        lamports: balanceNeeded,\n        space: TokenSwapLayout.span,\n        programId: swapProgramId,\n      }),\n    );\n\n    const instruction = TokenSwap.createInitSwapInstruction(\n      tokenSwapAccount,\n      authority,\n      nonce,\n      tokenAccountA,\n      tokenAccountB,\n      tokenPool,\n      tokenAccountPool,\n      tokenProgramId,\n      swapProgramId,\n      feeNumerator,\n      feeDenominator,\n    );\n\n    transaction.add(instruction);\n    await sendAndConfirmTransaction(\n      'createAccount and InitializeSwap',\n      connection,\n      transaction,\n      payer,\n      tokenSwapAccount,\n    );\n\n    return tokenSwap;\n  }\n\n  /**\n   * Retrieve tokenSwap information\n   */\n  async getInfo(): Promise<TokenSwapInfo> {\n    const accountInfo = await this.connection.getAccountInfo(this.tokenSwap);\n    if (accountInfo === null) {\n      throw new Error('Failed to find token swap account');\n    }\n    if (!accountInfo.owner.equals(this.programId)) {\n      throw new Error(\n        `Invalid token swap owner: ${JSON.stringify(accountInfo.owner)}`,\n      );\n    }\n\n    const data = Buffer.from(accountInfo.data);\n    const tokenSwapInfo = TokenSwapLayout.decode(data);\n    if (!tokenSwapInfo.isInitialized) {\n      throw new Error(`Invalid token swap state`);\n    }\n    // already properly filled in\n    // tokenSwapInfo.nonce = tokenSwapInfo.nonce;\n    tokenSwapInfo.tokenAccountA = new PublicKey(tokenSwapInfo.tokenAccountA);\n    tokenSwapInfo.tokenAccountB = new PublicKey(tokenSwapInfo.tokenAccountB);\n    tokenSwapInfo.tokenPool = new PublicKey(tokenSwapInfo.tokenPool);\n    tokenSwapInfo.feesNumerator = Numberu64.fromBuffer(\n      tokenSwapInfo.feesNumerator,\n    );\n    tokenSwapInfo.feesDenominator = Numberu64.fromBuffer(\n      tokenSwapInfo.feesDenominator,\n    );\n    tokenSwapInfo.feeRatio =\n      tokenSwapInfo.feesNumerator.toNumber() /\n      tokenSwapInfo.feesDenominator.toNumber();\n\n    return tokenSwapInfo;\n  }\n\n  /**\n   * Swap the tokens in the pool\n   *\n   * @param authority Authority\n   * @param source Source account\n   * @param swapSource Base account to swap into, must be a source token\n   * @param swapDestination Base account to swap from, must be a destination token\n   * @param destination Destination token account\n   * @param tokenProgramId Token program id\n   * @param amount Amount to transfer from source account\n   */\n  async swap(\n    authority: PublicKey,\n    source: PublicKey,\n    swapSource: PublicKey,\n    swapDestination: PublicKey,\n    destination: PublicKey,\n    tokenProgramId: PublicKey,\n    amountIn: number | Numberu64,\n    minimumAmountOut: number | Numberu64,\n  ): Promise<TransactionSignature> {\n    return await sendAndConfirmTransaction(\n      'swap',\n      this.connection,\n      new Transaction().add(\n        TokenSwap.swapInstruction(\n          this.tokenSwap,\n          authority,\n          source,\n          swapSource,\n          swapDestination,\n          destination,\n          this.programId,\n          tokenProgramId,\n          amountIn,\n          minimumAmountOut,\n        ),\n      ),\n      this.payer,\n    );\n  }\n\n  static swapInstruction(\n    tokenSwap: PublicKey,\n    authority: PublicKey,\n    source: PublicKey,\n    swapSource: PublicKey,\n    swapDestination: PublicKey,\n    destination: PublicKey,\n    swapProgramId: PublicKey,\n    tokenProgramId: PublicKey,\n    amountIn: number | Numberu64,\n    minimumAmountOut: number | Numberu64,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('amountIn'),\n      Layout.uint64('minimumAmountOut'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 1, // Swap instruction\n        amountIn: new Numberu64(amountIn).toBuffer(),\n        minimumAmountOut: new Numberu64(minimumAmountOut).toBuffer(),\n      },\n      data,\n    );\n\n    const keys = [\n      {pubkey: tokenSwap, isSigner: false, isWritable: false},\n      {pubkey: authority, isSigner: false, isWritable: false},\n      {pubkey: source, isSigner: false, isWritable: true},\n      {pubkey: swapSource, isSigner: false, isWritable: true},\n      {pubkey: swapDestination, isSigner: false, isWritable: true},\n      {pubkey: destination, isSigner: false, isWritable: true},\n      {pubkey: tokenProgramId, isSigner: false, isWritable: false},\n    ];\n    return new TransactionInstruction({\n      keys,\n      programId: swapProgramId,\n      data,\n    });\n  }\n\n  /**\n   * Deposit some tokens into the pool\n   *\n   * @param authority Authority\n   * @param sourceA Source account A\n   * @param sourceB Source account B\n   * @param intoA Base account A to deposit into\n   * @param intoB Base account B to deposit into\n   * @param poolToken Pool token\n   * @param poolAccount Pool account to deposit the generated tokens\n   * @param tokenProgramId Token program id\n   * @param amount Amount of pool token to deposit, token A and B amount are set by the exchange rate relative to the total pool token supply\n   */\n  async deposit(\n    authority: PublicKey,\n    sourceA: PublicKey,\n    sourceB: PublicKey,\n    intoA: PublicKey,\n    intoB: PublicKey,\n    poolToken: PublicKey,\n    poolAccount: PublicKey,\n    tokenProgramId: PublicKey,\n    poolTokenAmount: number | Numberu64,\n    maximumTokenA: number | Numberu64,\n    maximumTokenB: number | Numberu64,\n  ): Promise<TransactionSignature> {\n    return await sendAndConfirmTransaction(\n      'deposit',\n      this.connection,\n      new Transaction().add(\n        TokenSwap.depositInstruction(\n          this.tokenSwap,\n          authority,\n          sourceA,\n          sourceB,\n          intoA,\n          intoB,\n          poolToken,\n          poolAccount,\n          this.programId,\n          tokenProgramId,\n          poolTokenAmount,\n          maximumTokenA,\n          maximumTokenB,\n        ),\n      ),\n      this.payer,\n    );\n  }\n\n  static depositInstruction(\n    tokenSwap: PublicKey,\n    authority: PublicKey,\n    sourceA: PublicKey,\n    sourceB: PublicKey,\n    intoA: PublicKey,\n    intoB: PublicKey,\n    poolToken: PublicKey,\n    poolAccount: PublicKey,\n    swapProgramId: PublicKey,\n    tokenProgramId: PublicKey,\n    poolTokenAmount: number | Numberu64,\n    maximumTokenA: number | Numberu64,\n    maximumTokenB: number | Numberu64,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('poolTokenAmount'),\n      Layout.uint64('maximumTokenA'),\n      Layout.uint64('maximumTokenB'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 2, // Deposit instruction\n        poolTokenAmount: new Numberu64(poolTokenAmount).toBuffer(),\n        maximumTokenA: new Numberu64(maximumTokenA).toBuffer(),\n        maximumTokenB: new Numberu64(maximumTokenB).toBuffer(),\n      },\n      data,\n    );\n\n    const keys = [\n      {pubkey: tokenSwap, isSigner: false, isWritable: false},\n      {pubkey: authority, isSigner: false, isWritable: false},\n      {pubkey: sourceA, isSigner: false, isWritable: true},\n      {pubkey: sourceB, isSigner: false, isWritable: true},\n      {pubkey: intoA, isSigner: false, isWritable: true},\n      {pubkey: intoB, isSigner: false, isWritable: true},\n      {pubkey: poolToken, isSigner: false, isWritable: true},\n      {pubkey: poolAccount, isSigner: false, isWritable: true},\n      {pubkey: tokenProgramId, isSigner: false, isWritable: false},\n    ];\n    return new TransactionInstruction({\n      keys,\n      programId: swapProgramId,\n      data,\n    });\n  }\n\n  /**\n   * Withdraw the token from the pool at the current ratio\n   *\n   * @param authority Authority\n   * @param sourcePoolAccount Source pool account\n   * @param poolToken Pool token\n   * @param fromA Base account A to withdraw from\n   * @param fromB Base account B to withdraw from\n   * @param userAccountA Token A user account\n   * @param userAccountB token B user account\n   * @param tokenProgramId Token program id\n   * @param amount Amount of pool token to withdraw, token A and B amount are set by the exchange rate relative to the total pool token supply\n   */\n  async withdraw(\n    authority: PublicKey,\n    poolMint: PublicKey,\n    sourcePoolAccount: PublicKey,\n    fromA: PublicKey,\n    fromB: PublicKey,\n    userAccountA: PublicKey,\n    userAccountB: PublicKey,\n    tokenProgramId: PublicKey,\n    poolTokenAmount: number | Numberu64,\n    minimumTokenA: number | Numberu64,\n    minimumTokenB: number | Numberu64,\n  ): Promise<TransactionSignature> {\n    return await sendAndConfirmTransaction(\n      'withdraw',\n      this.connection,\n      new Transaction().add(\n        TokenSwap.withdrawInstruction(\n          this.tokenSwap,\n          authority,\n          poolMint,\n          sourcePoolAccount,\n          fromA,\n          fromB,\n          userAccountA,\n          userAccountB,\n          this.programId,\n          tokenProgramId,\n          poolTokenAmount,\n          minimumTokenA,\n          minimumTokenB,\n        ),\n      ),\n      this.payer,\n    );\n  }\n\n  static withdrawInstruction(\n    tokenSwap: PublicKey,\n    authority: PublicKey,\n    poolMint: PublicKey,\n    sourcePoolAccount: PublicKey,\n    fromA: PublicKey,\n    fromB: PublicKey,\n    userAccountA: PublicKey,\n    userAccountB: PublicKey,\n    swapProgramId: PublicKey,\n    tokenProgramId: PublicKey,\n    poolTokenAmount: number | Numberu64,\n    minimumTokenA: number | Numberu64,\n    minimumTokenB: number | Numberu64,\n  ): TransactionInstruction {\n    const dataLayout = BufferLayout.struct([\n      BufferLayout.u8('instruction'),\n      Layout.uint64('poolTokenAmount'),\n      Layout.uint64('minimumTokenA'),\n      Layout.uint64('minimumTokenB'),\n    ]);\n\n    const data = Buffer.alloc(dataLayout.span);\n    dataLayout.encode(\n      {\n        instruction: 3, // Withdraw instruction\n        poolTokenAmount: new Numberu64(poolTokenAmount).toBuffer(),\n        minimumTokenA: new Numberu64(minimumTokenA).toBuffer(),\n        minimumTokenB: new Numberu64(minimumTokenB).toBuffer(),\n      },\n      data,\n    );\n\n    const keys = [\n      {pubkey: tokenSwap, isSigner: false, isWritable: false},\n      {pubkey: authority, isSigner: false, isWritable: false},\n      {pubkey: poolMint, isSigner: false, isWritable: true},\n      {pubkey: sourcePoolAccount, isSigner: false, isWritable: true},\n      {pubkey: fromA, isSigner: false, isWritable: true},\n      {pubkey: fromB, isSigner: false, isWritable: true},\n      {pubkey: userAccountA, isSigner: false, isWritable: true},\n      {pubkey: userAccountB, isSigner: false, isWritable: true},\n      {pubkey: tokenProgramId, isSigner: false, isWritable: false},\n    ];\n    return new TransactionInstruction({\n      keys,\n      programId: swapProgramId,\n      data,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}