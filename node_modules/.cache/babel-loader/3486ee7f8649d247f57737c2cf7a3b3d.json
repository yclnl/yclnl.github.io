{"ast":null,"code":"var _jsxFileName = \"/home/yclnl/yclnl.github.io/src/utils/accounts.tsx\";\nimport React, { useCallback, useContext, useEffect, useState } from \"react\";\nimport { useConnection } from \"./connection\";\nimport { useWallet } from \"./wallet\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport { programIds, SWAP_HOST_FEE_ADDRESS, WRAPPED_SOL_MINT } from \"./ids\";\nimport { AccountLayout, u64, MintLayout } from \"@solana/spl-token\";\nimport { usePools } from \"./pools\";\nimport { notify } from \"./notifications\";\nimport { chunks } from \"./utils\";\nimport { EventEmitter } from \"./eventEmitter\";\nconst AccountsContext = React.createContext(null);\nconst accountEmitter = new EventEmitter();\nconst pendingMintCalls = new Map();\nconst mintCache = new Map();\nconst pendingAccountCalls = new Map();\nconst accountsCache = new Map();\nconst pendingCalls = new Map();\nconst genericCache = new Map();\n\nconst getAccountInfo = async (connection, pubKey) => {\n  const info = await connection.getAccountInfo(pubKey);\n\n  if (info === null) {\n    throw new Error(\"Failed to find mint account\");\n  }\n\n  return tokenAccountFactory(pubKey, info);\n};\n\nconst getMintInfo = async (connection, pubKey) => {\n  const info = await connection.getAccountInfo(pubKey);\n\n  if (info === null) {\n    throw new Error(\"Failed to find mint account\");\n  }\n\n  const data = Buffer.from(info.data);\n  return deserializeMint(data);\n};\n\nexport const MintParser = (pubKey, info) => {\n  const buffer = Buffer.from(info.data);\n  const data = deserializeMint(buffer);\n  const details = {\n    pubkey: pubKey,\n    account: { ...info\n    },\n    info: data\n  };\n  return details;\n};\nexport const TokenAccountParser = tokenAccountFactory;\nexport const GenericAccountParser = (pubKey, info) => {\n  const buffer = Buffer.from(info.data);\n  const details = {\n    pubkey: pubKey,\n    account: { ...info\n    },\n    info: buffer\n  };\n  return details;\n};\nexport const keyToAccountParser = new Map();\nexport const cache = {\n  query: async (connection, pubKey, parser) => {\n    let id;\n\n    if (typeof pubKey === \"string\") {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    let account = genericCache.get(address);\n\n    if (account) {\n      return account;\n    }\n\n    let query = pendingCalls.get(address);\n\n    if (query) {\n      return query;\n    }\n\n    query = connection.getAccountInfo(id).then(data => {\n      if (!data) {\n        throw new Error(\"Account not found\");\n      }\n\n      return cache.add(id, data, parser);\n    });\n    pendingCalls.set(address, query);\n    return query;\n  },\n  add: (id, obj, parser) => {\n    const address = id.toBase58();\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\n\n    if (!deserialize) {\n      throw new Error(\"Deserializer needs to be registered or passed as a parameter\");\n    }\n\n    cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    const account = deserialize(id, obj);\n    genericCache.set(address, account);\n    return account;\n  },\n  get: pubKey => {\n    let key;\n\n    if (typeof pubKey !== \"string\") {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return genericCache.get(key);\n  },\n  registerParser: (pubkey, parser) => {\n    keyToAccountParser.set(pubkey.toBase58(), parser);\n  },\n  queryAccount: async (connection, pubKey) => {\n    let id;\n\n    if (typeof pubKey === \"string\") {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    let account = accountsCache.get(address);\n\n    if (account) {\n      return account;\n    }\n\n    let query = pendingAccountCalls.get(address);\n\n    if (query) {\n      return query;\n    }\n\n    query = getAccountInfo(connection, id).then(data => {\n      pendingAccountCalls.delete(address);\n      accountsCache.set(address, data);\n      return data;\n    });\n    pendingAccountCalls.set(address, query);\n    return query;\n  },\n  addAccount: (pubKey, obj) => {\n    const account = tokenAccountFactory(pubKey, obj);\n    accountsCache.set(account.pubkey.toBase58(), account);\n    return account;\n  },\n  getAccount: pubKey => {\n    let key;\n\n    if (typeof pubKey !== \"string\") {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return accountsCache.get(key);\n  },\n  queryMint: async (connection, pubKey) => {\n    let id;\n\n    if (typeof pubKey === \"string\") {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    let mint = mintCache.get(address);\n\n    if (mint) {\n      return mint;\n    }\n\n    let query = pendingMintCalls.get(address);\n\n    if (query) {\n      return query;\n    }\n\n    query = getMintInfo(connection, id).then(data => {\n      pendingAccountCalls.delete(address);\n      mintCache.set(address, data);\n      return data;\n    });\n    pendingAccountCalls.set(address, query);\n    return query;\n  },\n  getMint: pubKey => {\n    let key;\n\n    if (typeof pubKey !== \"string\") {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return mintCache.get(key);\n  },\n  addMint: (pubKey, obj) => {\n    const mint = deserializeMint(obj.data);\n    mintCache.set(pubKey.toBase58(), mint);\n    return mint;\n  }\n};\nexport const getCachedAccount = predicate => {\n  for (const account of accountsCache.values()) {\n    if (predicate(account)) {\n      return account;\n    }\n  }\n};\n\nfunction tokenAccountFactory(pubKey, info) {\n  const buffer = Buffer.from(info.data);\n  const data = deserializeAccount(buffer);\n  const details = {\n    pubkey: pubKey,\n    account: { ...info\n    },\n    info: data\n  };\n  return details;\n}\n\nfunction wrapNativeAccount(pubkey, account) {\n  if (!account) {\n    return undefined;\n  }\n\n  return {\n    pubkey: pubkey,\n    account,\n    info: {\n      mint: WRAPPED_SOL_MINT,\n      owner: pubkey,\n      amount: new u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null\n    }\n  };\n}\n\nconst UseNativeAccount = () => {\n  const connection = useConnection();\n  const {\n    wallet\n  } = useWallet();\n  const [nativeAccount, setNativeAccount] = useState();\n  useEffect(() => {\n    if (!connection || !(wallet === null || wallet === void 0 ? void 0 : wallet.publicKey)) {\n      return;\n    }\n\n    connection.getAccountInfo(wallet.publicKey).then(acc => {\n      if (acc) {\n        setNativeAccount(acc);\n      }\n    });\n    connection.onAccountChange(wallet.publicKey, acc => {\n      if (acc) {\n        setNativeAccount(acc);\n      }\n    });\n  }, [setNativeAccount, wallet, wallet.publicKey, connection]);\n  return {\n    nativeAccount\n  };\n};\n\nconst PRECACHED_OWNERS = new Set();\n\nconst precacheUserTokenAccounts = async (connection, owner) => {\n  if (!owner) {\n    return;\n  } // used for filtering account updates over websocket\n\n\n  PRECACHED_OWNERS.add(owner.toBase58()); // user accounts are update via ws subscription\n\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\n    programId: programIds().token\n  });\n  accounts.value.map(info => {\n    const data = deserializeAccount(info.account.data); // need to query for mint to get decimals\n    // TODO: move to web3.js for decoding on the client side... maybe with callback\n\n    const details = {\n      pubkey: info.pubkey,\n      account: { ...info.account\n      },\n      info: data\n    };\n    return details;\n  }).forEach(acc => {\n    accountsCache.set(acc.pubkey.toBase58(), acc);\n  });\n};\n\nexport function AccountsProvider({\n  children = null\n}) {\n  const connection = useConnection();\n  const {\n    wallet,\n    connected\n  } = useWallet();\n  const [tokenAccounts, setTokenAccounts] = useState([]);\n  const [userAccounts, setUserAccounts] = useState([]);\n  const {\n    nativeAccount\n  } = UseNativeAccount();\n  const {\n    pools\n  } = usePools();\n  const selectUserAccounts = useCallback(() => {\n    return [...accountsCache.values()].filter(a => a.info.owner.toBase58() === wallet.publicKey.toBase58());\n  }, [wallet]);\n  useEffect(() => {\n    setUserAccounts([wrapNativeAccount(wallet.publicKey, nativeAccount), ...tokenAccounts].filter(a => a !== undefined));\n  }, [nativeAccount, wallet, tokenAccounts]);\n  useEffect(() => {\n    if (!connection || !wallet || !wallet.publicKey) {\n      setTokenAccounts([]);\n    } else {\n      // cache host accounts to avoid query during swap\n      precacheUserTokenAccounts(connection, SWAP_HOST_FEE_ADDRESS);\n      precacheUserTokenAccounts(connection, wallet.publicKey).then(() => {\n        setTokenAccounts(selectUserAccounts());\n      }); // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter. discuss filter syntax\n\n      const tokenSubID = connection.onProgramAccountChange(programIds().token, info => {\n        // TODO: fix type in web3.js\n        const id = info.accountId; // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n\n        if (info.accountInfo.data.length === AccountLayout.span) {\n          const data = deserializeAccount(info.accountInfo.data); // TODO: move to web3.js for decoding on the client side... maybe with callback\n\n          const details = {\n            pubkey: new PublicKey(info.accountId),\n            account: { ...info.accountInfo\n            },\n            info: data\n          };\n\n          if (PRECACHED_OWNERS.has(details.info.owner.toBase58()) || accountsCache.has(id)) {\n            accountsCache.set(id, details);\n            setTokenAccounts(selectUserAccounts());\n            accountEmitter.raiseAccountUpdated(id);\n          }\n        } else if (info.accountInfo.data.length === MintLayout.span) {\n          if (mintCache.has(id)) {\n            const data = Buffer.from(info.accountInfo.data);\n            const mint = deserializeMint(data);\n            mintCache.set(id, mint);\n            accountEmitter.raiseAccountUpdated(id);\n          }\n\n          accountEmitter.raiseAccountUpdated(id);\n        }\n\n        if (genericCache.has(id)) {\n          cache.add(new PublicKey(id), info.accountInfo);\n        }\n      }, \"singleGossip\");\n      return () => {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, connected, wallet === null || wallet === void 0 ? void 0 : wallet.publicKey]);\n  return /*#__PURE__*/React.createElement(AccountsContext.Provider, {\n    value: {\n      userAccounts,\n      pools,\n      nativeAccount\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 450,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport function useNativeAccount() {\n  const context = useContext(AccountsContext);\n  return {\n    account: context.nativeAccount\n  };\n}\nexport const getMultipleAccounts = async (connection, keys, commitment) => {\n  const result = await Promise.all(chunks(keys, 99).map(chunk => getMultipleAccountsCore(connection, chunk, commitment)));\n  const array = result.map(a => a.array.map(acc => {\n    const {\n      data,\n      ...rest\n    } = acc;\n    const obj = { ...rest,\n      data: Buffer.from(data[0], \"base64\")\n    };\n    return obj;\n  })).flat();\n  return {\n    keys,\n    array\n  };\n};\n\nconst getMultipleAccountsCore = async (connection, keys, commitment) => {\n  const args = connection._buildArgs([keys], commitment, \"base64\");\n\n  const unsafeRes = await connection._rpcRequest(\"getMultipleAccounts\", args);\n\n  if (unsafeRes.error) {\n    throw new Error(\"failed to get info about account \" + unsafeRes.error.message);\n  }\n\n  if (unsafeRes.result.value) {\n    const array = unsafeRes.result.value;\n    return {\n      keys,\n      array\n    };\n  } // TODO: fix\n\n\n  throw new Error();\n};\n\nexport function useMint(id) {\n  const connection = useConnection();\n  const [mint, setMint] = useState();\n  useEffect(() => {\n    if (!id) {\n      return;\n    }\n\n    cache.queryMint(connection, id).then(setMint).catch(err => notify({\n      message: err.message,\n      type: \"error\"\n    }));\n    const dispose = accountEmitter.onAccount(e => {\n      const event = e;\n\n      if (event.id === id) {\n        cache.queryMint(connection, id).then(setMint);\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, id]);\n  return mint;\n}\nexport function useUserAccounts() {\n  const context = useContext(AccountsContext);\n  return {\n    userAccounts: context.userAccounts\n  };\n}\nexport function useAccount(pubKey) {\n  const connection = useConnection();\n  const [account, setAccount] = useState();\n  const key = pubKey === null || pubKey === void 0 ? void 0 : pubKey.toBase58();\n  useEffect(() => {\n    const query = async () => {\n      try {\n        if (!key) {\n          return;\n        }\n\n        const acc = await cache.queryAccount(connection, key).catch(err => notify({\n          message: err.message,\n          type: \"error\"\n        }));\n\n        if (acc) {\n          setAccount(acc);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    query();\n    const dispose = accountEmitter.onAccount(e => {\n      const event = e;\n\n      if (event.id === key) {\n        query();\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, key]);\n  return account;\n}\nexport function useCachedPool() {\n  const context = useContext(AccountsContext);\n  return {\n    pools: context.pools\n  };\n}\nexport const useSelectedAccount = account => {\n  const {\n    userAccounts\n  } = useUserAccounts();\n  const index = userAccounts.findIndex(acc => acc.pubkey.toBase58() === account);\n\n  if (index !== -1) {\n    return userAccounts[index];\n  }\n\n  return;\n};\nexport const useAccountByMint = mint => {\n  const {\n    userAccounts\n  } = useUserAccounts();\n  const index = userAccounts.findIndex(acc => acc.info.mint.toBase58() === mint);\n\n  if (index !== -1) {\n    return userAccounts[index];\n  }\n\n  return;\n}; // TODO: expose in spl package\n\nconst deserializeAccount = data => {\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n}; // TODO: expose in spl package\n\n\nconst deserializeMint = data => {\n  if (data.length !== MintLayout.span) {\n    throw new Error(\"Not a valid Mint\");\n  }\n\n  const mintInfo = MintLayout.decode(data);\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo;\n};","map":{"version":3,"sources":["/home/yclnl/yclnl.github.io/src/utils/accounts.tsx"],"names":["React","useCallback","useContext","useEffect","useState","useConnection","useWallet","PublicKey","programIds","SWAP_HOST_FEE_ADDRESS","WRAPPED_SOL_MINT","AccountLayout","u64","MintLayout","usePools","notify","chunks","EventEmitter","AccountsContext","createContext","accountEmitter","pendingMintCalls","Map","mintCache","pendingAccountCalls","accountsCache","pendingCalls","genericCache","getAccountInfo","connection","pubKey","info","Error","tokenAccountFactory","getMintInfo","data","Buffer","from","deserializeMint","MintParser","buffer","details","pubkey","account","TokenAccountParser","GenericAccountParser","keyToAccountParser","cache","query","parser","id","address","toBase58","get","then","add","set","obj","deserialize","registerParser","delete","key","queryAccount","addAccount","getAccount","queryMint","mint","getMint","addMint","getCachedAccount","predicate","values","deserializeAccount","wrapNativeAccount","undefined","owner","amount","lamports","delegate","delegatedAmount","isInitialized","isFrozen","isNative","rentExemptReserve","closeAuthority","UseNativeAccount","wallet","nativeAccount","setNativeAccount","publicKey","acc","onAccountChange","PRECACHED_OWNERS","Set","precacheUserTokenAccounts","accounts","getTokenAccountsByOwner","programId","token","value","map","forEach","AccountsProvider","children","connected","tokenAccounts","setTokenAccounts","userAccounts","setUserAccounts","pools","selectUserAccounts","filter","a","tokenSubID","onProgramAccountChange","accountId","accountInfo","length","span","has","raiseAccountUpdated","removeProgramAccountChangeListener","useNativeAccount","context","getMultipleAccounts","keys","commitment","result","Promise","all","chunk","getMultipleAccountsCore","array","rest","flat","args","_buildArgs","unsafeRes","_rpcRequest","error","message","useMint","setMint","catch","err","type","dispose","onAccount","e","event","useUserAccounts","useAccount","setAccount","console","useCachedPool","useSelectedAccount","index","findIndex","useAccountByMint","decode","fromBuffer","delegateOption","state","isNativeOption","closeAuthorityOption","mintInfo","mintAuthorityOption","mintAuthority","supply","freezeAuthorityOption","freezeAuthority"],"mappings":"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","sourcesContent":["import React, { useCallback, useContext, useEffect, useState } from \"react\";\nimport { useConnection } from \"./connection\";\nimport { useWallet } from \"./wallet\";\nimport { AccountInfo, Connection, PublicKey } from \"@solana/web3.js\";\nimport { programIds, SWAP_HOST_FEE_ADDRESS, WRAPPED_SOL_MINT } from \"./ids\";\nimport { AccountLayout, u64, MintInfo, MintLayout } from \"@solana/spl-token\";\nimport { usePools } from \"./pools\";\nimport { TokenAccount, PoolInfo } from \"./../models\";\nimport { notify } from \"./notifications\";\nimport { chunks } from \"./utils\";\nimport { EventEmitter } from \"./eventEmitter\";\n\nconst AccountsContext = React.createContext<any>(null);\n\nconst accountEmitter = new EventEmitter();\n\nconst pendingMintCalls = new Map<string, Promise<MintInfo>>();\nconst mintCache = new Map<string, MintInfo>();\nconst pendingAccountCalls = new Map<string, Promise<TokenAccount>>();\nconst accountsCache = new Map<string, TokenAccount>();\n\nconst pendingCalls = new Map<string, Promise<ParsedAccountBase>>();\nconst genericCache = new Map<string, ParsedAccountBase>();\n\nconst getAccountInfo = async (connection: Connection, pubKey: PublicKey) => {\n  const info = await connection.getAccountInfo(pubKey);\n  if (info === null) {\n    throw new Error(\"Failed to find mint account\");\n  }\n\n  return tokenAccountFactory(pubKey, info);\n};\n\nconst getMintInfo = async (connection: Connection, pubKey: PublicKey) => {\n  const info = await connection.getAccountInfo(pubKey);\n  if (info === null) {\n    throw new Error(\"Failed to find mint account\");\n  }\n\n  const data = Buffer.from(info.data);\n\n  return deserializeMint(data);\n};\n\nexport interface ParsedAccountBase {\n  pubkey: PublicKey;\n  account: AccountInfo<Buffer>;\n  info: any; // TODO: change to unkown\n}\n\nexport interface ParsedAccount<T> extends ParsedAccountBase {\n  info: T;\n}\n\nexport type AccountParser = (\n  pubkey: PublicKey,\n  data: AccountInfo<Buffer>\n) => ParsedAccountBase;\nexport const MintParser = (pubKey: PublicKey, info: AccountInfo<Buffer>) => {\n  const buffer = Buffer.from(info.data);\n\n  const data = deserializeMint(buffer);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: data,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const TokenAccountParser = tokenAccountFactory;\n\nexport const GenericAccountParser = (\n  pubKey: PublicKey,\n  info: AccountInfo<Buffer>\n) => {\n  const buffer = Buffer.from(info.data);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: buffer,\n  } as ParsedAccountBase;\n\n  return details;\n};\n\nexport const keyToAccountParser = new Map<string, AccountParser>();\n\nexport const cache = {\n  query: async (\n    connection: Connection,\n    pubKey: string | PublicKey,\n    parser?: AccountParser\n  ) => {\n    let id: PublicKey;\n    if (typeof pubKey === \"string\") {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n\n    let account = genericCache.get(address);\n    if (account) {\n      return account;\n    }\n\n    let query = pendingCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    query = connection.getAccountInfo(id).then((data) => {\n      if (!data) {\n        throw new Error(\"Account not found\");\n      }\n\n      return cache.add(id, data, parser);\n    }) as Promise<TokenAccount>;\n    pendingCalls.set(address, query as any);\n\n    return query;\n  },\n  add: (id: PublicKey, obj: AccountInfo<Buffer>, parser?: AccountParser) => {\n    const address = id.toBase58();\n    const deserialize = parser ? parser : keyToAccountParser.get(address);\n    if (!deserialize) {\n      throw new Error(\n        \"Deserializer needs to be registered or passed as a parameter\"\n      );\n    }\n\n    cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    const account = deserialize(id, obj);\n    genericCache.set(address, account);\n    return account;\n  },\n  get: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== \"string\") {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return genericCache.get(key);\n  },\n  registerParser: (pubkey: PublicKey, parser: AccountParser) => {\n    keyToAccountParser.set(pubkey.toBase58(), parser);\n  },\n\n  queryAccount: async (connection: Connection, pubKey: string | PublicKey) => {\n    let id: PublicKey;\n    if (typeof pubKey === \"string\") {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n\n    let account = accountsCache.get(address);\n    if (account) {\n      return account;\n    }\n\n    let query = pendingAccountCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    query = getAccountInfo(connection, id).then((data) => {\n      pendingAccountCalls.delete(address);\n      accountsCache.set(address, data);\n      return data;\n    }) as Promise<TokenAccount>;\n    pendingAccountCalls.set(address, query as any);\n\n    return query;\n  },\n  addAccount: (pubKey: PublicKey, obj: AccountInfo<Buffer>) => {\n    const account = tokenAccountFactory(pubKey, obj);\n    accountsCache.set(account.pubkey.toBase58(), account);\n    return account;\n  },\n  getAccount: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== \"string\") {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return accountsCache.get(key);\n  },\n  queryMint: async (connection: Connection, pubKey: string | PublicKey) => {\n    let id: PublicKey;\n    if (typeof pubKey === \"string\") {\n      id = new PublicKey(pubKey);\n    } else {\n      id = pubKey;\n    }\n\n    const address = id.toBase58();\n    let mint = mintCache.get(address);\n    if (mint) {\n      return mint;\n    }\n\n    let query = pendingMintCalls.get(address);\n    if (query) {\n      return query;\n    }\n\n    query = getMintInfo(connection, id).then((data) => {\n      pendingAccountCalls.delete(address);\n      mintCache.set(address, data);\n      return data;\n    }) as Promise<MintInfo>;\n    pendingAccountCalls.set(address, query as any);\n\n    return query;\n  },\n  getMint: (pubKey: string | PublicKey) => {\n    let key: string;\n    if (typeof pubKey !== \"string\") {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return mintCache.get(key);\n  },\n  addMint: (pubKey: PublicKey, obj: AccountInfo<Buffer>) => {\n    const mint = deserializeMint(obj.data);\n    mintCache.set(pubKey.toBase58(), mint);\n    return mint;\n  },\n};\n\nexport const getCachedAccount = (\n  predicate: (account: TokenAccount) => boolean\n) => {\n  for (const account of accountsCache.values()) {\n    if (predicate(account)) {\n      return account as TokenAccount;\n    }\n  }\n};\n\nfunction tokenAccountFactory(pubKey: PublicKey, info: AccountInfo<Buffer>) {\n  const buffer = Buffer.from(info.data);\n\n  const data = deserializeAccount(buffer);\n\n  const details = {\n    pubkey: pubKey,\n    account: {\n      ...info,\n    },\n    info: data,\n  } as TokenAccount;\n\n  return details;\n}\n\nfunction wrapNativeAccount(\n  pubkey: PublicKey,\n  account?: AccountInfo<Buffer>\n): TokenAccount | undefined {\n  if (!account) {\n    return undefined;\n  }\n\n  return {\n    pubkey: pubkey,\n    account,\n    info: {\n      mint: WRAPPED_SOL_MINT,\n      owner: pubkey,\n      amount: new u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null,\n    },\n  };\n}\n\nconst UseNativeAccount = () => {\n  const connection = useConnection();\n  const { wallet } = useWallet();\n\n  const [nativeAccount, setNativeAccount] = useState<AccountInfo<Buffer>>();\n  useEffect(() => {\n    if (!connection || !wallet?.publicKey) {\n      return;\n    }\n\n    connection.getAccountInfo(wallet.publicKey).then((acc) => {\n      if (acc) {\n        setNativeAccount(acc);\n      }\n    });\n    connection.onAccountChange(wallet.publicKey, (acc) => {\n      if (acc) {\n        setNativeAccount(acc);\n      }\n    });\n  }, [setNativeAccount, wallet, wallet.publicKey, connection]);\n\n  return { nativeAccount };\n};\n\nconst PRECACHED_OWNERS = new Set<string>();\nconst precacheUserTokenAccounts = async (\n  connection: Connection,\n  owner?: PublicKey\n) => {\n  if (!owner) {\n    return;\n  }\n\n  // used for filtering account updates over websocket\n  PRECACHED_OWNERS.add(owner.toBase58());\n\n  // user accounts are update via ws subscription\n  const accounts = await connection.getTokenAccountsByOwner(owner, {\n    programId: programIds().token,\n  });\n  accounts.value\n    .map((info) => {\n      const data = deserializeAccount(info.account.data);\n      // need to query for mint to get decimals\n\n      // TODO: move to web3.js for decoding on the client side... maybe with callback\n      const details = {\n        pubkey: info.pubkey,\n        account: {\n          ...info.account,\n        },\n        info: data,\n      } as TokenAccount;\n\n      return details;\n    })\n    .forEach((acc) => {\n      accountsCache.set(acc.pubkey.toBase58(), acc);\n    });\n};\n\nexport function AccountsProvider({ children = null as any }) {\n  const connection = useConnection();\n  const { wallet, connected } = useWallet();\n  const [tokenAccounts, setTokenAccounts] = useState<TokenAccount[]>([]);\n  const [userAccounts, setUserAccounts] = useState<TokenAccount[]>([]);\n  const { nativeAccount } = UseNativeAccount();\n  const { pools } = usePools();\n\n  const selectUserAccounts = useCallback(() => {\n    return [...accountsCache.values()].filter(\n      (a) => a.info.owner.toBase58() === wallet.publicKey.toBase58()\n    );\n  }, [wallet]);\n\n  useEffect(() => {\n    setUserAccounts(\n      [\n        wrapNativeAccount(wallet.publicKey, nativeAccount),\n        ...tokenAccounts,\n      ].filter((a) => a !== undefined) as TokenAccount[]\n    );\n  }, [nativeAccount, wallet, tokenAccounts]);\n\n  useEffect(() => {\n    if (!connection || !wallet || !wallet.publicKey) {\n      setTokenAccounts([]);\n    } else {\n      // cache host accounts to avoid query during swap\n      precacheUserTokenAccounts(connection, SWAP_HOST_FEE_ADDRESS);\n\n      precacheUserTokenAccounts(connection, wallet.publicKey).then(() => {\n        setTokenAccounts(selectUserAccounts());\n      });\n\n      // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter. discuss filter syntax\n      const tokenSubID = connection.onProgramAccountChange(\n        programIds().token,\n        (info) => {\n          // TODO: fix type in web3.js\n          const id = (info.accountId as unknown) as string;\n          // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n          if (info.accountInfo.data.length === AccountLayout.span) {\n            const data = deserializeAccount(info.accountInfo.data);\n            // TODO: move to web3.js for decoding on the client side... maybe with callback\n            const details = {\n              pubkey: new PublicKey((info.accountId as unknown) as string),\n              account: {\n                ...info.accountInfo,\n              },\n              info: data,\n            } as TokenAccount;\n\n            if (\n              PRECACHED_OWNERS.has(details.info.owner.toBase58()) ||\n              accountsCache.has(id)\n            ) {\n              accountsCache.set(id, details);\n              setTokenAccounts(selectUserAccounts());\n              accountEmitter.raiseAccountUpdated(id);\n            }\n          } else if (info.accountInfo.data.length === MintLayout.span) {\n            if (mintCache.has(id)) {\n              const data = Buffer.from(info.accountInfo.data);\n              const mint = deserializeMint(data);\n              mintCache.set(id, mint);\n              accountEmitter.raiseAccountUpdated(id);\n            }\n\n            accountEmitter.raiseAccountUpdated(id);\n          }\n\n          if (genericCache.has(id)) {\n            cache.add(new PublicKey(id), info.accountInfo);\n          }\n        },\n        \"singleGossip\"\n      );\n\n      return () => {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, connected, wallet?.publicKey]);\n\n  return (\n    <AccountsContext.Provider\n      value={{\n        userAccounts,\n        pools,\n        nativeAccount,\n      }}\n    >\n      {children}\n    </AccountsContext.Provider>\n  );\n}\n\nexport function useNativeAccount() {\n  const context = useContext(AccountsContext);\n  return {\n    account: context.nativeAccount as AccountInfo<Buffer>,\n  };\n}\n\nexport const getMultipleAccounts = async (\n  connection: any,\n  keys: string[],\n  commitment: string\n) => {\n  const result = await Promise.all(\n    chunks(keys, 99).map((chunk) =>\n      getMultipleAccountsCore(connection, chunk, commitment)\n    )\n  );\n\n  const array = result\n    .map(\n      (a) =>\n        a.array.map((acc) => {\n          const { data, ...rest } = acc;\n          const obj = {\n            ...rest,\n            data: Buffer.from(data[0], \"base64\"),\n          } as AccountInfo<Buffer>;\n          return obj;\n        }) as AccountInfo<Buffer>[]\n    )\n    .flat();\n  return { keys, array };\n};\n\nconst getMultipleAccountsCore = async (\n  connection: any,\n  keys: string[],\n  commitment: string\n) => {\n  const args = connection._buildArgs([keys], commitment, \"base64\");\n\n  const unsafeRes = await connection._rpcRequest(\"getMultipleAccounts\", args);\n  if (unsafeRes.error) {\n    throw new Error(\n      \"failed to get info about account \" + unsafeRes.error.message\n    );\n  }\n\n  if (unsafeRes.result.value) {\n    const array = unsafeRes.result.value as AccountInfo<string[]>[];\n    return { keys, array };\n  }\n\n  // TODO: fix\n  throw new Error();\n};\n\nexport function useMint(id?: string) {\n  const connection = useConnection();\n  const [mint, setMint] = useState<MintInfo>();\n\n  useEffect(() => {\n    if (!id) {\n      return;\n    }\n\n    cache\n      .queryMint(connection, id)\n      .then(setMint)\n      .catch((err) =>\n        notify({\n          message: err.message,\n          type: \"error\",\n        })\n      );\n\n    const dispose = accountEmitter.onAccount((e) => {\n      const event = e;\n      if (event.id === id) {\n        cache.queryMint(connection, id).then(setMint);\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, id]);\n\n  return mint;\n}\n\nexport function useUserAccounts() {\n  const context = useContext(AccountsContext);\n  return {\n    userAccounts: context.userAccounts as TokenAccount[],\n  };\n}\n\nexport function useAccount(pubKey?: PublicKey) {\n  const connection = useConnection();\n  const [account, setAccount] = useState<TokenAccount>();\n\n  const key = pubKey?.toBase58();\n  useEffect(() => {\n    const query = async () => {\n      try {\n        if (!key) {\n          return;\n        }\n\n        const acc = await cache.queryAccount(connection, key).catch((err) =>\n          notify({\n            message: err.message,\n            type: \"error\",\n          })\n        );\n        if (acc) {\n          setAccount(acc);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    };\n\n    query();\n\n    const dispose = accountEmitter.onAccount((e) => {\n      const event = e;\n      if (event.id === key) {\n        query();\n      }\n    });\n    return () => {\n      dispose();\n    };\n  }, [connection, key]);\n\n  return account;\n}\n\nexport function useCachedPool() {\n  const context = useContext(AccountsContext);\n  return {\n    pools: context.pools as PoolInfo[],\n  };\n}\n\nexport const useSelectedAccount = (account: string) => {\n  const { userAccounts } = useUserAccounts();\n  const index = userAccounts.findIndex(\n    (acc) => acc.pubkey.toBase58() === account\n  );\n\n  if (index !== -1) {\n    return userAccounts[index];\n  }\n\n  return;\n};\n\nexport const useAccountByMint = (mint: string) => {\n  const { userAccounts } = useUserAccounts();\n  const index = userAccounts.findIndex(\n    (acc) => acc.info.mint.toBase58() === mint\n  );\n\n  if (index !== -1) {\n    return userAccounts[index];\n  }\n\n  return;\n};\n\n// TODO: expose in spl package\nconst deserializeAccount = (data: Buffer) => {\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n};\n\n// TODO: expose in spl package\nconst deserializeMint = (data: Buffer) => {\n  if (data.length !== MintLayout.span) {\n    throw new Error(\"Not a valid Mint\");\n  }\n\n  const mintInfo = MintLayout.decode(data);\n\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n\n  return mintInfo as MintInfo;\n};\n"]},"metadata":{},"sourceType":"module"}